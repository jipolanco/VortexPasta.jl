import{_ as d,C as p,c as o,o as r,j as e,aA as n,a as i,G as a,w as l}from"./chunks/framework.W_HWv6eC.js";const V=JSON.parse('{"title":"FindNearbySegments","description":"","frontmatter":{},"headers":[],"relativePath":"modules/FindNearbySegments.md","filePath":"modules/FindNearbySegments.md","lastUpdated":null}'),h={name:"modules/FindNearbySegments.md"},k={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},c={class:"jldocstring custom-block",open:""},u={class:"jldocstring custom-block",open:""},y={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},b={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.357ex"},xmlns:"http://www.w3.org/2000/svg",width:"3.43ex",height:"1.357ex",role:"img",focusable:"false",viewBox:"0 -442 1516.2 599.8","aria-hidden":"true"},E={class:"jldocstring custom-block",open:""};function F(f,s,T,_,x,C){const t=p("Badge");return r(),o("div",null,[s[35]||(s[35]=e("h1",{id:"FindNearbySegments",tabindex:"-1"},[i("FindNearbySegments "),e("a",{class:"header-anchor",href:"#FindNearbySegments","aria-label":'Permalink to "FindNearbySegments {#FindNearbySegments}"'},"​")],-1)),e("details",k,[e("summary",null,[s[0]||(s[0]=e("a",{id:"VortexPasta.FindNearbySegments",href:"#VortexPasta.FindNearbySegments"},[e("span",{class:"jlbinding"},"VortexPasta.FindNearbySegments")],-1)),s[1]||(s[1]=i()),a(t,{type:"info",class:"jlObjectType jlModule",text:"Module"})]),s[3]||(s[3]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">FindNearbySegments</span></span></code></pre></div><p>A module for finding pairs of nearby filament segments.</p><p>This is a common operation, used for instance for:</p><ul><li><p>computing short-range Biot-Savart interactions between filament segments;</p></li><li><p>detecting vortex reconnection candidates.</p></li></ul>',4)),a(t,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[2]||(s[2]=[e("a",{href:"https://github.com/jipolanco/VortexPasta.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[36]||(s[36]=e("h2",{id:"Backends",tabindex:"-1"},[i("Backends "),e("a",{class:"header-anchor",href:"#Backends","aria-label":'Permalink to "Backends {#Backends}"'},"​")],-1)),e("details",g,[e("summary",null,[s[4]||(s[4]=e("a",{id:"VortexPasta.FindNearbySegments.NaiveSegmentFinder",href:"#VortexPasta.FindNearbySegments.NaiveSegmentFinder"},[e("span",{class:"jlbinding"},"VortexPasta.FindNearbySegments.NaiveSegmentFinder")],-1)),s[5]||(s[5]=i()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[7]||(s[7]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">NaiveSegmentFinder </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NearbySegmentFinder</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NaiveSegmentFinder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector{&lt;:AbstractFilament}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Initialise nearby segment finder based on a naive searching method.</p><p>When using this segment finder, <a href="/VortexPasta.jl/dev/modules/FindNearbySegments#VortexPasta.FindNearbySegments.nearby_segments"><code>nearby_segments</code></a> iterates through <em>all</em> segments in all filaments <code>fs</code>, performing no filtering at all. One should manually use <a href="/VortexPasta.jl/dev/modules/FindNearbySegments#VortexPasta.FindNearbySegments.segment_is_close"><code>segment_is_close</code></a> to filter the returned segments while iterating.</p>`,3)),a(t,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[6]||(s[6]=[e("a",{href:"https://github.com/jipolanco/VortexPasta.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",m,[e("summary",null,[s[8]||(s[8]=e("a",{id:"VortexPasta.FindNearbySegments.CellListSegmentFinder",href:"#VortexPasta.FindNearbySegments.CellListSegmentFinder"},[e("span",{class:"jlbinding"},"VortexPasta.FindNearbySegments.CellListSegmentFinder")],-1)),s[9]||(s[9]=i()),a(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[11]||(s[11]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CellListSegmentFinder </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> NearbySegmentFinder</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CellListSegmentFinder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector{&lt;:AbstractFilament}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    r_cut</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Ls</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NTuple{3, Real}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    nsubdiv </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Initialise nearby segment finder based on cell lists algorithm.</p><p>Only supports fully periodic domains.</p><p>See the <a href="/VortexPasta.jl/dev/modules/CellLists#CellLists"><code>CellLists</code></a> module for more details.</p><p><strong>Mandatory arguments</strong></p><ul><li><p><code>fs</code>: vector of filaments;</p></li><li><p><code>r_cut::Real</code>: cut-off distance;</p></li><li><p><code>Ls::NTuple{3, Real}</code>: domain period in each direction. Note that this backend doesn&#39;t support non-periodic (<code>Infinity</code>) directions.</p></li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><code>nsubdiv = Val(M)</code>: number of cell lists subdivisions. Here <code>M</code> must be a positive integer (<code>M = 1</code> means no subdivisions). See <a href="/VortexPasta.jl/dev/modules/CellLists#VortexPasta.CellLists.PeriodicCellList"><code>PeriodicCellList</code></a> for details.</li></ul>`,8)),a(t,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[10]||(s[10]=[e("a",{href:"https://github.com/jipolanco/VortexPasta.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[37]||(s[37]=e("h2",{id:"Functions",tabindex:"-1"},[i("Functions "),e("a",{class:"header-anchor",href:"#Functions","aria-label":'Permalink to "Functions {#Functions}"'},"​")],-1)),e("details",c,[e("summary",null,[s[12]||(s[12]=e("a",{id:"VortexPasta.FindNearbySegments.set_filaments!",href:"#VortexPasta.FindNearbySegments.set_filaments!"},[e("span",{class:"jlbinding"},"VortexPasta.FindNearbySegments.set_filaments!")],-1)),s[13]||(s[13]=i()),a(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[15]||(s[15]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set_filaments!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NearbySegmentFinder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, fs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector{&lt;:AbstractFilament}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Store (and optionally process) the list of filaments.</p><p>This must be called to set the filament list before using <a href="/VortexPasta.jl/dev/modules/FindNearbySegments#VortexPasta.FindNearbySegments.nearby_segments"><code>nearby_segments</code></a>.</p>',3)),a(t,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[14]||(s[14]=[e("a",{href:"https://github.com/jipolanco/VortexPasta.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",u,[e("summary",null,[s[16]||(s[16]=e("a",{id:"VortexPasta.FindNearbySegments.nearby_segments",href:"#VortexPasta.FindNearbySegments.nearby_segments"},[e("span",{class:"jlbinding"},"VortexPasta.FindNearbySegments.nearby_segments")],-1)),s[17]||(s[17]=i()),a(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[29]||(s[29]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nearby_segments</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NearbySegmentFinder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x⃗</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return an iterator over the segments that are &quot;close&quot; to the location <code>x⃗</code>.</p>',2)),e("p",null,[s[20]||(s[20]=i("A segment is considered to be close to ",-1)),s[21]||(s[21]=e("code",null,"x⃗",-1)),s[22]||(s[22]=i(" if the minimum",-1)),s[23]||(s[23]=e("sup",{class:"footnote-ref"},[e("a",{href:"#fn1",id:"fnref1"},"[1]")],-1)),s[24]||(s[24]=i(" distance between ",-1)),s[25]||(s[25]=e("code",null,"x⃗",-1)),s[26]||(s[26]=i(" and the segment midpoint is smaller than the cutoff distance ",-1)),e("mjx-container",y,[(r(),o("svg",b,[...s[18]||(s[18]=[n('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z" style="stroke-width:3;"></path></g><g data-mml-node="TeXAtom" transform="translate(484,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mtext"><path data-c="63" d="M370 305T349 305T313 320T297 358Q297 381 312 396Q317 401 317 402T307 404Q281 408 258 408Q209 408 178 376Q131 329 131 219Q131 137 162 90Q203 29 272 29Q313 29 338 55T374 117Q376 125 379 127T395 129H409Q415 123 415 120Q415 116 411 104T395 71T366 33T318 2T249 -11Q163 -11 99 53T34 214Q34 318 99 383T250 448T370 421T404 357Q404 334 387 320Z" style="stroke-width:3;"></path><path data-c="75" d="M383 58Q327 -10 256 -10H249Q124 -10 105 89Q104 96 103 226Q102 335 102 348T96 369Q86 385 36 385H25V408Q25 431 27 431L38 432Q48 433 67 434T105 436Q122 437 142 438T172 441T184 442H187V261Q188 77 190 64Q193 49 204 40Q224 26 264 26Q290 26 311 35T343 58T363 90T375 120T379 144Q379 145 379 161T380 201T380 248V315Q380 361 370 372T320 385H302V431Q304 431 378 436T457 442H464V264Q464 84 465 81Q468 61 479 55T524 46H542V0Q540 0 467 -5T390 -11H383V58Z" transform="translate(444,0)" style="stroke-width:3;"></path><path data-c="74" d="M27 422Q80 426 109 478T141 600V615H181V431H316V385H181V241Q182 116 182 100T189 68Q203 29 238 29Q282 29 292 100Q293 108 293 146V181H333V146V134Q333 57 291 17Q264 -10 221 -10Q187 -10 162 2T124 33T105 68T98 100Q97 107 97 248V385H18V422H27Z" transform="translate(1000,0)" style="stroke-width:3;"></path></g></g></g></g></g>',1)])])),s[19]||(s[19]=e("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("msub",null,[e("mi",null,"r"),e("mrow",{"data-mjx-texclass":"ORD"},[e("mtext",null,"cut")])])])],-1))]),s[27]||(s[27]=i(".",-1))]),s[30]||(s[30]=n('<p>Typical usage:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x⃗ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Vec3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> segment </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">∈</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nearby_segments</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c, x⃗)</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Get the filament `f` and the index `i` of the segment within the filament.</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # The segment is between the filament nodes `f[i]` and `f[i + 1]`.</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    (; f, i,) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> segment</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Do something with the segment...</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div>',2)),a(t,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[28]||(s[28]=[e("a",{href:"https://github.com/jipolanco/VortexPasta.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e("details",E,[e("summary",null,[s[31]||(s[31]=e("a",{id:"VortexPasta.FindNearbySegments.segment_is_close",href:"#VortexPasta.FindNearbySegments.segment_is_close"},[e("span",{class:"jlbinding"},"VortexPasta.FindNearbySegments.segment_is_close")],-1)),s[32]||(s[32]=i()),a(t,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[34]||(s[34]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">segment_is_close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Segment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x⃗, r_cut</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, r²_cut</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Ls, Lhs) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Bool</span></span></code></pre></div><p>Determine whether segment <code>s</code> is close to the point <code>x⃗</code>.</p><p>Here <code>r_cut</code> is the critical distance below which <code>s</code> and <code>x⃗</code> will be considered to be &quot;close&quot;, and <code>r²_cut = r_cut^2</code> is its squared value.</p><p>Moreover, <code>Ls = (Lx, Ly, Lz)</code> contains the domain period along each dimension (components can be <code>Infinity()</code> for infinite non-periodic domains), and <code>Lhs = (Lx/2, Ly/2, Lz/2)</code> contains half the domain periods.</p>',4)),a(t,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[33]||(s[33]=[e("a",{href:"https://github.com/jipolanco/VortexPasta.jl",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[38]||(s[38]=n('<hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>When periodicity is enabled, the relevant distance is the <em>minimum</em> distance between the two points, after considering all their periodic images. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>',2))])}const v=d(h,[["render",F]]);export{V as __pageData,v as default};
