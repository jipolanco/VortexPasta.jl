import{_ as i,o as a,c as e,aA as n}from"./chunks/framework.zAZgiY4E.js";const c=JSON.parse('{"title":"Parallelisation and clusters","description":"","frontmatter":{},"headers":[],"relativePath":"tips/parallelisation.md","filePath":"tips/parallelisation.md","lastUpdated":null}'),t={name:"tips/parallelisation.md"};function l(h,s,p,r,o,k){return a(),e("div",null,[...s[0]||(s[0]=[n(`<h1 id="Parallelisation-and-clusters" tabindex="-1">Parallelisation and clusters <a class="header-anchor" href="#Parallelisation-and-clusters" aria-label="Permalink to &quot;Parallelisation and clusters {#Parallelisation-and-clusters}&quot;">​</a></h1><p>VortexPasta.jl can take advantage of thread-based CPU parallelisation (equivalent to OpenMP). In particular, it can be run on a single node of a computing cluster.</p><h2 id="Starting-Julia-with-multiple-threads" tabindex="-1">Starting Julia with multiple threads <a class="header-anchor" href="#Starting-Julia-with-multiple-threads" aria-label="Permalink to &quot;Starting Julia with multiple threads {#Starting-Julia-with-multiple-threads}&quot;">​</a></h2><p>There are <a href="https://docs.julialang.org/en/v1/manual/multi-threading/" target="_blank" rel="noreferrer">a few ways</a> of starting Julia with multiple threads:</p><ol><li><p>either via the <a href="https://docs.julialang.org/en/v1/manual/environment-variables/#JULIA_NUM_THREADS" target="_blank" rel="noreferrer"><code>JULIA_NUM_THREADS</code></a> environment variable,</p></li><li><p>or via the <code>-t / --threads</code> command-line option.</p></li></ol><p>If both are used, the second takes precedence.</p><p>The command-line flag can be used in two ways:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> julia</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -t</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     # start Julia with 8 threads</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> julia</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -t</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> auto</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # start Julia with the number of CPUs available to this Julia process</span></span></code></pre></div><p>The second option can be useful in particular when running <a href="/VortexPasta.jl/stable/tips/parallelisation#slurm-job">SLURM jobs</a>, as Julia will use the number of CPUs associated to the SLURM allocation.</p><h2 id="Pinning-threads" tabindex="-1">Pinning threads <a class="header-anchor" href="#Pinning-threads" aria-label="Permalink to &quot;Pinning threads {#Pinning-threads}&quot;">​</a></h2><p>When Julia is started with multiple threads, it can (and often does) assign more than one thread to the same CPU, even when the requested number of threads is smaller or equal to the total number of CPUs. This is clearly suboptimal.</p><p>The <a href="https://github.com/carstenbauer/ThreadPinning.jl" target="_blank" rel="noreferrer">ThreadPinning.jl</a> package solves this issue. The easiest way to use it by putting <a href="https://carstenbauer.github.io/ThreadPinning.jl/stable/examples/ex_pinning_julia_threads/#pinthreads" target="_blank" rel="noreferrer">the following lines</a> at the top of your Julia script:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ThreadPinning</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pinthreads</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:cores</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Note that this should be changed <a href="/VortexPasta.jl/stable/tips/parallelisation#Pinning-SLURM-threads">when using SLURM</a>.</p><p>One can then check that threads are correctly pinned to separate CPUs using <a href="https://carstenbauer.github.io/ThreadPinning.jl/stable/examples/ex_pinning_julia_threads/#threadinfo_example" target="_blank" rel="noreferrer"><code>threadinfo</code></a>.</p><h2 id="slurm-job" tabindex="-1">Running SLURM jobs <a class="header-anchor" href="#slurm-job" aria-label="Permalink to &quot;Running SLURM jobs {#slurm-job}&quot;">​</a></h2><h3 id="slurm-submitting-jobs" tabindex="-1">Submitting jobs <a class="header-anchor" href="#slurm-submitting-jobs" aria-label="Permalink to &quot;Submitting jobs {#slurm-submitting-jobs}&quot;">​</a></h3><p>Here is a sample SLURM script for running a simulation on which can be submitted using <code>sbatch</code>:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#!/bin/bash</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#SBATCH --job-name=&quot;JOB_NAME&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#SBATCH --partition=PARTITION_NAME_ON_CLUSTER</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#SBATCH --time=1:00:00</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#SBATCH --distribution=block:block</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#SBATCH --nodes=1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#SBATCH --ntasks=1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#SBATCH --hint=nomultithread</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#SBATCH --cpus-per-task=32</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#SBATCH --ntasks-per-node=1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#SBATCH --threads-per-core=1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#SBATCH --exclusive</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#SBATCH --mem=120G</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot; - SLURM_JOB_ID = </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$SLURM_JOB_ID</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot; - SLURM_JOB_NODELIST = </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$SLURM_JOB_NODELIST</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot; - SLURM_TASKS_PER_NODE = </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$SLURM_TASKS_PER_NODE</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot; - SLURM_CPUS_PER_TASK = </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$SLURM_CPUS_PER_TASK</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">srun</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --cpu-bind=verbose,cores</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  --cpus-per-task=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$SLURM_CPUS_PER_TASK</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  --ntasks-per-node=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$SLURM_NTASKS_PER_NODE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  --threads-per-core=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$SLURM_THREADS_PER_CORE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  julia</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -t</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> auto</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --heap-size-hint=100G</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --project=.</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> script.jl</span></span></code></pre></div><p>Here the number of threads is set via the <code>--cpus-per-task</code> option.</p><p>Some other notes:</p><ul><li><p>the precise <code>SBATCH</code> flags that need to be passed depend on the actual cluster. For example, in some clusters one may also need to pass <code>--constraint</code> and <code>--account</code> flags, while the <code>--partition</code> flag is not necessarily needed.</p></li><li><p>the <code>--exclusive</code> flag is optional; it is recommended if one wants to use a full node (i.e. if the number of requested CPUs corresponds to the total number of CPUs on a node);</p></li><li><p>above, we passed the <code>--heap-size-hint=100G</code> option to the <code>julia</code> command. This may help avoid out of memory errors, by telling Julia&#39;s garbage collector that the total used memory should stay below the specified value. Just to be sure, we also explicitly requested a (slightly larger) amount of memory to SLURM using the <code>--mem</code> option;</p></li><li><p>the <code>--hint=nomultithread</code> option tells SLURM to avoid using hyperthreading, which is generally not good for performance.</p></li></ul><h3 id="Pinning-SLURM-threads" tabindex="-1">Pinning SLURM threads <a class="header-anchor" href="#Pinning-SLURM-threads" aria-label="Permalink to &quot;Pinning SLURM threads {#Pinning-SLURM-threads}&quot;">​</a></h3><p>As mentioned <a href="/VortexPasta.jl/stable/tips/parallelisation#Pinning-threads">above</a>, it is a good idea to pin Julia threads to the CPUs available to the Julia process.</p><p>When using SLURM, one can achieve this by using the <code>:affinitymask</code> criterion in ThreadPinning&#39;s <a href="https://carstenbauer.github.io/ThreadPinning.jl/stable/refs/api_pinning/#ThreadPinning.pinthreads" target="_blank" rel="noreferrer"><code>pinthreads</code></a>:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ThreadPinning</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pinthreads</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:affinitymask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>It can be convenient to have a Julia script which does the Right Thing (TM) depending on whether it runs within a SLURM job or not. To achieve this, one can do:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ThreadPinning</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> haskey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ENV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;SLURM_JOB_ID&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    pinthreads</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:affinitymask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    pinthreads</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:cores</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><h2 id="Using-MKL-FFT-routines" tabindex="-1">Using MKL FFT routines <a class="header-anchor" href="#Using-MKL-FFT-routines" aria-label="Permalink to &quot;Using MKL FFT routines {#Using-MKL-FFT-routines}&quot;">​</a></h2><p>When running on CPUs, the default <a href="/VortexPasta.jl/stable/modules/BiotSavart#VortexPasta.BiotSavart.NonuniformFFTsBackend"><code>NonuniformFFTsBackend</code></a> in VortexPasta.jl computes threaded FFTs using the <a href="https://github.com/JuliaMath/FFTW.jl" target="_blank" rel="noreferrer">FFTW.jl</a> package, which by default wraps the FFTW libraries written in C. However, FFTW.jl has an <a href="https://github.com/JuliaMath/FFTW.jl/issues/236" target="_blank" rel="noreferrer">unresolved issue</a> which can be encountered (somewhat randomly) when computing FFTs using a large number of threads.</p><h3 id="Switching-to-MKL-in-FFTW.jl" tabindex="-1">Switching to MKL in FFTW.jl <a class="header-anchor" href="#Switching-to-MKL-in-FFTW.jl" aria-label="Permalink to &quot;Switching to MKL in FFTW.jl {#Switching-to-MKL-in-FFTW.jl}&quot;">​</a></h3><p>One workaround is to switch to the FFT implementation in Intel&#39;s MKL libraries, which don&#39;t seem to display this issue. The FFTW.jl package makes it easy to <a href="https://github.com/JuliaMath/FFTW.jl?tab=readme-ov-file#mkl" target="_blank" rel="noreferrer">switch</a> to the MKL implementation via their <a href="https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-fortran/2023-0/fftw3-interface-to-onemkl.html" target="_blank" rel="noreferrer">FFTW interface</a>.</p><p>One simply needs to do:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FFTW</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">FFTW</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set_provider!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;mkl&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>and restart Julia. This will create (or update) a <code>LocalPreferences.toml</code> file next to the <code>Project.toml</code> file associated to the active Julia project.</p><h3 id="Correctly-using-threads-with-MKL" tabindex="-1">Correctly using threads with MKL <a class="header-anchor" href="#Correctly-using-threads-with-MKL" aria-label="Permalink to &quot;Correctly using threads with MKL {#Correctly-using-threads-with-MKL}&quot;">​</a></h3><p>The above change is not enough if one wants MKL&#39;s FFTs to be efficient when using threads. One also needs to set the following environment variables (for example in a <a href="/VortexPasta.jl/stable/tips/parallelisation#slurm-submitting-jobs">SLURM script</a>):</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MKL_NUM_THREADS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$SLURM_CPUS_PER_TASK      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># on SLURM</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MKL_NUM_THREADS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$NUMBER_OF_JULIA_THREADS  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># in general</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MKL_DYNAMIC</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">false</span></span></code></pre></div><p>The <code>MKL_DYNAMIC=false</code> option tells MKL <a href="https://carstenbauer.github.io/ThreadPinning.jl/stable/examples/ex_blas/#Intel-MKL" target="_blank" rel="noreferrer">not to mess around with thread pinning</a>.</p><p>Secondly, one also needs to add:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MKL</span></span></code></pre></div><p>at the start of the Julia script to be run (one may need to <code>]add MKL</code> first). Failing to do this can really degrade performance.</p><p>Note that one can also set the environment variables directly in the Julia script. Including <a href="/VortexPasta.jl/stable/tips/parallelisation#Pinning-SLURM-threads">thread pinning</a>, the beginning of the Julia script could look like:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MKL</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ThreadPinning</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ENV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;MKL_NUM_THREADS&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Threads</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nthreads</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># same as number of Julia threads</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ENV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;MKL_DYNAMIC&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> haskey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ENV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;SLURM_JOB_ID&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    pinthreads</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:affinitymask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    pinthreads</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:cores</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Tell threadinfo to give us information about BLAS (and MKL) and optionally about the SLURM set-up.</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">threadinfo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(blas </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, hints </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, slurm </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> haskey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ENV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;SLURM_JOB_ID&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><p>Note that, with the <code>hints = true</code> option, ThreadPinning will complain about our choice of using <code>MKL_NUM_THREADS = number_of_julia_threads</code>. This warning can be ignored, since FFTs are executed from a single Julia thread and it&#39;s therefore what we want.</p><h2 id="Heterogeneous-clusters" tabindex="-1">Heterogeneous clusters <a class="header-anchor" href="#Heterogeneous-clusters" aria-label="Permalink to &quot;Heterogeneous clusters {#Heterogeneous-clusters}&quot;">​</a></h2><p>It is common to find clusters with heterogeneous CPU architectures. For example, the CPUs used in login and compute nodes are often not the same. This can lead to problems or to suboptimal performance when code is compiled on the login node and executed on a compute node.</p><p>This problem also exists in Julia, as code is &quot;precompiled&quot; when packages are installed or updated by the user (typically in a login node). The <a href="https://juliahpc.github.io/user_gettingstarted/#set_julia_cpu_target_appropriately" target="_blank" rel="noreferrer">solution</a> is to set the <code>JULIA_CPU_TARGET</code> environment variable in the <code>~/.bashrc</code> file (or similar). This could look something like:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> JULIA_CPU_TARGET</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;generic;znver5,clone_all;znver4,clone_all&quot;</span></span></code></pre></div><p>The actual values to put in <code>JULIA_CPU_TARGET</code> (instead of <code>znver4</code> and <code>znver5</code> above) depend on your cluster! To find them, you can run from the login node:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">julia</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -E</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Sys.CPU_NAME&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # this gives the architecture of the login node</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">srun</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -n</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [options...] julia -E </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Sys.CPU_NAME&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # this gives the architecture of a compute node (assuming the cluster uses SLURM)</span></span></code></pre></div>`,51)])])}const g=i(t,[["render",l]]);export{c as __pageData,g as default};
