<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Filaments · VortexPasta</title><meta name="title" content="Filaments · VortexPasta"/><meta property="og:title" content="Filaments · VortexPasta"/><meta property="twitter:title" content="Filaments · VortexPasta"/><meta name="description" content="Documentation for VortexPasta."/><meta property="og:description" content="Documentation for VortexPasta."/><meta property="twitter:description" content="Documentation for VortexPasta."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/fonts.css" rel="stylesheet" type="text/css"/><script src="../../assets/tomate.js"></script><script src="../../assets/sa.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">VortexPasta</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">VortexPasta.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/01-vortex_ring/">Vortex ring</a></li><li><a class="tocitem" href="../../tutorials/02-kelvin_waves/">Kelvin waves</a></li></ul></li><li><span class="tocitem">Explanations</span><ul><li><a class="tocitem" href="../../methods/VFM/">The vortex filament model</a></li><li><a class="tocitem" href="../../methods/Ewald/">Ewald summation for Biot–Savart</a></li></ul></li><li><span class="tocitem">Tips and tricks</span><ul><li><a class="tocitem" href="../../tips/parallelisation/">Parallelisation</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../PaddedArrays/">PaddedArrays</a></li><li><a class="tocitem" href="../PredefinedCurves/">PredefinedCurves</a></li><li><a class="tocitem" href="../CellLists/">CellLists</a></li><li><a class="tocitem" href="../BasicTypes/">BasicTypes</a></li><li><a class="tocitem" href="../Quadratures/">Quadratures</a></li><li class="is-active"><a class="tocitem" href>Filaments</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Initialisation"><span>Initialisation</span></a></li><li><a class="tocitem" href="#Curve-representation"><span>Curve representation</span></a></li><li><a class="tocitem" href="#Obtaining-information"><span>Obtaining information</span></a></li><li><a class="tocitem" href="#Modifying-filaments"><span>Modifying filaments</span></a></li><li><a class="tocitem" href="#Curve-parametrisations"><span>Curve parametrisations</span></a></li><li><a class="tocitem" href="#Other-functions"><span>Other functions</span></a></li><li><a class="tocitem" href="#Refinement"><span>Refinement</span></a></li><li><a class="tocitem" href="#Geometric-quantities"><span>Geometric quantities</span></a></li><li><a class="tocitem" href="#Segments"><span>Segments</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li></ul></li><li><a class="tocitem" href="../FilamentIO/">FilamentIO</a></li><li><a class="tocitem" href="../FindNearbySegments/">FindNearbySegments</a></li><li><a class="tocitem" href="../BiotSavart/">BiotSavart</a></li><li><a class="tocitem" href="../Reconnections/">Reconnections</a></li><li><a class="tocitem" href="../Timestepping/">Timestepping</a></li><li><a class="tocitem" href="../Diagnostics/">Diagnostics</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Filaments</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Filaments</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jipolanco/VortexPasta.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jipolanco/VortexPasta.jl/blob/master/docs/src/modules/Filaments.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Filaments"><a class="docs-heading-anchor" href="#Filaments">Filaments</a><a id="Filaments-1"></a><a class="docs-heading-anchor-permalink" href="#Filaments" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments" href="#VortexPasta.Filaments"><code>VortexPasta.Filaments</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Filaments</code></pre><p>Module for dealing with the discretisation of curves in 3D space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/Filaments.jl#L1-L5">source</a></section></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.AbstractFilament" href="#VortexPasta.Filaments.AbstractFilament"><code>VortexPasta.Filaments.AbstractFilament</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractFilament{T} &lt;: AbstractVector{Vec3{T}}</code></pre><p>Abstract type representing a curve in 3D space.</p><p>The curve coordinates are parametrised as <span>$\bm{s}(t)$</span> with <span>$t ∈ ℝ$</span>.</p><p>The curve is discretised by a set of <em>nodes</em> (or discretisation points) <span>$\bm{s}(t_i) = \bm{s}_i$</span> for <span>$i ∈ \{1, 2, …, N\}$</span>.</p><p>See <a href="#VortexPasta.Filaments.ClosedFilament"><code>ClosedFilament</code></a> for a concrete implementation of <code>AbstractFilament</code>.</p><p>An <code>AbstractFilament</code> is treated as an <code>AbstractVector</code> of length <code>N</code>, in which each element is a discretisation point <span>$\bm{s}_i$</span>. Therefore, one can use the usual indexing notation to retrieve and to modify discretisation points. See <a href="#VortexPasta.Filaments.ClosedFilament"><code>ClosedFilament</code></a> for some examples.</p><p><strong>Extended help</strong></p><p><strong>Evaluating coordinates and derivatives</strong></p><p>Different ways are proposed of evaluating filament coordinates and derivatives along a filament <code>f</code>, depending on whether one wants values on discretisation points or in-between them.</p><p>In short, square brackets <code>f[...]</code> should be used to evaluate on filament nodes, while round brackets <code>f(...)</code> to evaluate in-between nodes.</p><p><strong>Values on discretisation points</strong></p><p>Coordinates <span>$\bm{s}_i$</span> of discretisation points can be simply obtained by indexing the filament object:</p><pre><code class="nohighlight hljs">s⃗ = f[i]</code></pre><p>Derivatives at discretisation points can be similarly obtained by doing:</p><pre><code class="nohighlight hljs">s⃗′ = f[i, Derivative(1)]
s⃗″ = f[i, Derivative(2)]</code></pre><p>(Note that this also works with <code>Derivative(0)</code>, in which case it&#39;s the same as <code>f[i]</code>.)</p><p>For convenience, other geometric quantities can be evaluated in a similar way:</p><pre><code class="nohighlight hljs">ρ⃗ = f[i, CurvatureVector()]</code></pre><p>(See <a href="#VortexPasta.Filaments.GeometricQuantity"><code>GeometricQuantity</code></a> for available quantities.)</p><p><strong>Values in-between discretisation points</strong></p><p>In this case, one wants to evaluate a value in-between two discretisation points, i.e. for <span>$t ∈ [t_i, t_{i + 1}]$</span> for some index <code>i</code>. Two options are proposed:</p><ul><li><p>if one knows the parametrisation of the filament (see <a href="#VortexPasta.Filaments.knots"><code>knots</code></a> to obtain the parametrisation knots), then one can evaluate using a value of <code>t</code>:</p><pre><code class="nohighlight hljs">s⃗  = f(t)
s⃗′ = f(t, Derivative(1))
s⃗″ = f(t, Derivative(2))</code></pre></li><li><p>alternatively, if one knows the index <code>i</code> associated to the segment of interest, then one can do</p><pre><code class="nohighlight hljs">s⃗  = f(i, ζ)
s⃗′ = f(i, ζ, Derivative(1))
s⃗″ = f(i, ζ, Derivative(2))</code></pre><p>where <code>ζ</code> must be in <span>$[0, 1]$</span>, and the two limits correspond to knots <span>$t_i$</span> and <span>$t_{i + 1}$</span>. This is convenient if one wants to evaluate, say, right in the middle between two discretisation points, in which case one would choose <code>ζ = 0.5</code>.</p></li></ul><p>For convenience, other geometric quantities can be evaluated in a similar way:</p><pre><code class="nohighlight hljs">ρ⃗ = f(t, CurvatureVector())
ρ⃗ = f(i, ζ, CurvatureVector())</code></pre><div class="admonition is-info"><header class="admonition-header">Derivatives</header><div class="admonition-body"><p>In all cases, derivatives are computed with respect to the parametrisation <span>$t$</span>. In particular, in <code>f(i, ζ, Derivative(1))</code>, the derivative is <em>not</em> with respect to <span>$ζ$</span>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Derivative normalisation</header><div class="admonition-body"><p>Since <span>$t$</span> is a rough approximation for the arc length <span>$ξ$</span>, first derivatives almost represent the <strong>unit tangent vector</strong> to the filament, and second derivatives are a rough approximation of the local <strong>curvature vector</strong>.</p><p>One should use for example <a href="#VortexPasta.Filaments.UnitTangent"><code>UnitTangent</code></a> or <a href="#VortexPasta.Filaments.CurvatureVector"><code>CurvatureVector</code></a> if one wants the derivatives with respect to the arc length <span>$ξ$</span> (which are more geometrically meaningful, and guaranteed to be orthogonal to each other). There is also <a href="#VortexPasta.Filaments.normalise_derivatives"><code>normalise_derivatives</code></a> which can be more efficient when one already has the derivatives with respect to <span>$t$</span>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/Filaments.jl#L58-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.ClosedFilament" href="#VortexPasta.Filaments.ClosedFilament"><code>VortexPasta.Filaments.ClosedFilament</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ClosedFilament{T, D &lt;: DiscretisationMethod} &lt;: AbstractFilament{T}</code></pre><p>Describes a closed curve (a loop) in 3D space.</p><p>It can also be used to represent infinite but unclosed curves described by a periodic function (such as an infinite straight line or a sinusoidal curve).</p><p><code>ClosedFilament</code>s should be generally constructed using <a href="#VortexPasta.Filaments.init"><code>Filaments.init</code></a>.</p><p><strong>Extended help</strong></p><p><strong>Examples</strong></p><p>The following examples use the <a href="#VortexPasta.Filaments.CubicSplineMethod"><code>CubicSplineMethod</code></a> for representing filament curves, but other methods are also available.</p><p>Initialise filament from a set of discretisation points:</p><pre><code class="language-julia-repl hljs">julia&gt; f = Filaments.init(ClosedFilament, 16, CubicSplineMethod());

julia&gt; θs = range(-1, 1; length = 17)[1:16]
-1.0:0.125:0.875

julia&gt; @. f = Vec3(cospi(θs), sinpi(θs), 0);

julia&gt; f[4]
3-element SVector{3, Float64} with indices SOneTo(3):
 -0.3826834323650898
 -0.9238795325112867
  0.0

julia&gt; f[5] = (f[4] + 2 * f[6]) ./ 2
3-element SVector{3, Float64} with indices SOneTo(3):
  0.1913417161825449
 -1.38581929876693
  0.0

julia&gt; update_coefficients!(f);</code></pre><p>Note that <a href="#VortexPasta.Filaments.update_coefficients!"><code>update_coefficients!</code></a> should be called whenever filament coordinates are changed, before doing other operations such as estimating derivatives.</p><p>Estimate derivatives at discretisation points:</p><pre><code class="language-julia-repl hljs">julia&gt; f[4, Derivative(1)]
3-element SVector{3, Float64} with indices SOneTo(3):
  0.9090457394297018
 -0.7273334611006509
  0.0

julia&gt; f[4, Derivative(2)]
3-element SVector{3, Float64} with indices SOneTo(3):
  0.20911715113294102
 -2.09047051482799
  0.0</code></pre><p>Estimate coordinates and derivatives in-between discretisation points:</p><pre><code class="language-julia-repl hljs">julia&gt; f(4, 0.32)
3-element SVector{3, Float64} with indices SOneTo(3):
 -0.16753415613203387
 -1.1324592487590195
  0.0

julia&gt; Ẋ, Ẍ = f(4, 0.32, Derivative(1)), f(4, 0.32, Derivative(2))
([0.8947546127964856, -0.9527970723463657, 0.0], [-0.3303413370703831, 0.17798009799460934, 0.0])

julia&gt; X′, X″ = f(4, 0.32, UnitTangent()), f(4, 0.32, CurvatureVector())
([0.6845546705034081, -0.7289615237390588, 0.0], [-0.050762951240829336, -0.047670575508846375, 0.0])</code></pre><p><strong>Curve parametrisation</strong></p><p>The parametrisation knots <span>$t_i$</span> are directly obtained from the interpolation point positions. A standard choice, which is used here by default, is for the knot increments to approximate the arc length between two interpolation points:</p><p class="math-container">\[ℓ_{i} ≡ t_{i + 1} - t_{i} = |\bm{s}_{i + 1} - \bm{s}_i|,\]</p><p>which is a zero-th order approximation (and a lower bound) for the actual arc length between points <span>$\bm{s}_i$</span> and <span>$\bm{s}_{i + 1}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/closed_filament.jl#L3-L95">source</a></section></article><h2 id="Initialisation"><a class="docs-heading-anchor" href="#Initialisation">Initialisation</a><a id="Initialisation-1"></a><a class="docs-heading-anchor-permalink" href="#Initialisation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.init" href="#VortexPasta.Filaments.init"><code>VortexPasta.Filaments.init</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Filaments.init(
    ClosedFilament{T}, N::Integer, method::DiscretisationMethod;
    offset = zero(Vec3{T}),
    parametrisation = Filaments.default_parametrisation(method),
    nderivs = Val(2),
) -&gt; ClosedFilament{T}</code></pre><p>Allocate data for a closed filament with <code>N</code> discretisation points.</p><p>The element type <code>T</code> can be omitted, in which case the default <code>T = Float64</code> is used.</p><p>The optional <code>offset</code> keyword argument allows to define a filament with a spatial offset between points <code>f[i]</code> and <code>f[i + N]</code>. By default the offset is zero, meaning that the filament is a closed loop. This can be used for defining infinite (so not really closed) filaments living in periodic domains.</p><p>Possible discretisation methods include <a href="#VortexPasta.Filaments.CubicSplineMethod"><code>CubicSplineMethod</code></a>, <a href="#VortexPasta.Filaments.QuinticSplineMethod"><code>QuinticSplineMethod</code></a> and <a href="#VortexPasta.Filaments.FiniteDiffMethod"><code>FiniteDiffMethod</code></a>.</p><hr/><pre><code class="nohighlight hljs">Filaments.init(
    ClosedFilament, points::AbstractVector{&lt;:Vec3}, method::DiscretisationMethod;
    kwargs...,
)</code></pre><p>Initialise new filament with the chosen discretisation points.</p><p>Note that <a href="#VortexPasta.Filaments.update_coefficients!"><code>update_coefficients!</code></a> does not need to be called after using this variant (until node locations change, of course!).</p><hr/><pre><code class="nohighlight hljs">Filaments.init(S::Function, ClosedFilament{T}, τs::AbstractVector, method::DiscretisationMethod)
Filaments.init(S::Function, ClosedFilament{T}, N::Integer, method::DiscretisationMethod)</code></pre><p>Construct new filament from parametric function <span>$S(τ): [0, 1] ↦ ℝ³$</span>.</p><p>The parametric function <span>$S(τ)$</span> must generate a 3D coordinate (for example as an <code>SVector{3}</code> or an <code>NTuple{3}</code>) for any <span>$τ ∈ [0, 1]$</span>. The curve described by <span>$S$</span> is closed if and only if <span>$S(0) = S(1)$</span>. More generally, for infinite but unclosed curves, the end-to-end offset is obtained as <span>$Δ = S(1) - S(0)$</span>.</p><p>In particular, one can pass functions generated by <a href="../PredefinedCurves/#VortexPasta.PredefinedCurves.define_curve"><code>PredefinedCurves.define_curve</code></a>.</p><p>Two variants of this method are provided:</p><ul><li><p>in the first variant, the function <span>$S$</span> is evaluated at user-provided values of <span>$τ$</span>, which should be in <span>$[0, 1)$</span>;</p></li><li><p>in the second variant, one simply passes the desired number <span>$N$</span> of nodes of the resulting filament, and the function chooses an equispaced list of <span>$τ$</span> values.</p></li></ul><p>The element type <code>T</code> can be omitted, in which case the default <code>T = Float64</code> is used.</p><p>Some examples are given further below (&quot;Initialising filament from parametric function&quot;). See also <a href="#VortexPasta.Filaments.from_vector_field"><code>from_vector_field</code></a> to initialise a filament from an analytical vector field.</p><hr/><p><strong>Extended help</strong></p><p><strong>Evaluating high-order derivatives</strong></p><p>By default the filament discretisation allows to evaluate up to the second derivative of the curve with respect to its parametrisation. This means in particular than one has access to the tangent, curvature and binormal vectors.</p><p>One may want to evaluate higher order derivatives, for example to also have access to the curve torsion (which depends on the 3rd derivative). This is only possible for some high-order discretisation methods (<a href="#VortexPasta.Filaments.QuinticSplineMethod"><code>QuinticSplineMethod</code></a>, as well as <a href="#VortexPasta.Filaments.FourierMethod"><code>FourierMethod</code></a> with the limitation that one has to evaluate on discretisation points). Moreover, one needs to explicitly pass <code>nderivs = Val(3)</code> (or higher) to the <code>init</code> function.</p><p><strong>Customising the filament parametrisation</strong></p><p>By default the filament is parametrised as <span>$\bm{s}(t)$</span> such that the parameter <span>$t$</span> roughly corresponds to the arc length <span>$ξ$</span>.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> More precisely, the discrete values <span>$t_i$</span> at the discretisation points are defined from the distances between discretisation points:</p><p class="math-container">\[t_{i + 1} = t_{i} + |\bm{s}_{i + 1} - \bm{s}_i|, \quad t_1 = 0.\]</p><p>One can use the <code>parametrisation</code> keyword argument to change this. This may be a function <code>parametrisation(Xs, i)</code> which takes the vector <code>Xs</code> of discretisation points and the index <code>i</code> associated to the start of the current segment.</p><p>For instance, to parametrise filaments according to the <span>$z$</span> increments between discretisation points, one can pass:</p><pre><code class="nohighlight hljs">parametrisation = (Xs, i) -&gt; abs(Xs[i + 1].z - Xs[i].z)</code></pre><p>One can also pass a predefined parametrisation. See <a href="#VortexPasta.Filaments.AbstractParametrisation"><code>AbstractParametrisation</code></a> for a list of options.</p><p><strong>Examples</strong></p><p><strong>Initialising filament from parametric function</strong></p><p>Initialise circular filament with <code>N = 16</code> nodes:</p><pre><code class="language-julia-repl hljs">julia&gt; S(t) = (cos(2π * t), sin(2π * t), 0)  # define a circular ring with period T = 1
S (generic function with 1 method)

julia&gt; N = 16;

julia&gt; f = Filaments.init(S, ClosedFilament, N, CubicSplineMethod())
16-element ClosedFilament{SVector{3, Float64}, CubicSplineMethod}:
 [0.9807852804032304, 0.19509032201612825, 0.0]
 [0.8314696123025452, 0.5555702330196022, 0.0]
 [0.5555702330196023, 0.8314696123025452, 0.0]
 [0.19509032201612833, 0.9807852804032304, 0.0]
 [-0.1950903220161282, 0.9807852804032304, 0.0]
 [-0.555570233019602, 0.8314696123025453, 0.0]
 [-0.8314696123025453, 0.5555702330196022, 0.0]
 [-0.9807852804032304, 0.1950903220161286, 0.0]
 [-0.9807852804032304, -0.19509032201612836, 0.0]
 [-0.8314696123025455, -0.555570233019602, 0.0]
 [-0.5555702330196022, -0.8314696123025452, 0.0]
 [-0.19509032201612866, -0.9807852804032303, 0.0]
 [0.1950903220161283, -0.9807852804032304, 0.0]
 [0.5555702330196018, -0.8314696123025455, 0.0]
 [0.8314696123025452, -0.5555702330196022, 0.0]
 [0.9807852804032303, -0.19509032201612872, 0.0]</code></pre><p>Same but choosing the locations <code>τ</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; τs = range(0, 1; length = N + 1)[1:N]  # make sure the location τ = 1 is *not* included!
0.0:0.0625:0.9375

julia&gt; f = Filaments.init(S, ClosedFilament, τs, CubicSplineMethod())
16-element ClosedFilament{SVector{3, Float64}, CubicSplineMethod}:
 [1.0, 0.0, 0.0]
 [0.9238795325112867, 0.3826834323650898, 0.0]
 [0.7071067811865476, 0.7071067811865475, 0.0]
 [0.38268343236508984, 0.9238795325112867, 0.0]
 [6.123233995736766e-17, 1.0, 0.0]
 [-0.3826834323650897, 0.9238795325112867, 0.0]
 [-0.7071067811865475, 0.7071067811865476, 0.0]
 [-0.9238795325112867, 0.3826834323650899, 0.0]
 [-1.0, 1.2246467991473532e-16, 0.0]
 [-0.9238795325112868, -0.38268343236508967, 0.0]
 [-0.7071067811865477, -0.7071067811865475, 0.0]
 [-0.38268343236509034, -0.9238795325112865, 0.0]
 [-1.8369701987210297e-16, -1.0, 0.0]
 [0.38268343236509, -0.9238795325112866, 0.0]
 [0.7071067811865474, -0.7071067811865477, 0.0]
 [0.9238795325112865, -0.3826834323650904, 0.0]</code></pre><p>Using <a href="../PredefinedCurves/#PredefinedCurves"><code>VortexPasta.PredefinedCurves</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; using VortexPasta.PredefinedCurves

julia&gt; trefoil = define_curve(TrefoilKnot());

julia&gt; f = Filaments.init(trefoil, ClosedFilament, N, CubicSplineMethod())
16-element ClosedFilament{SVector{3, Float64}, CubicSplineMethod}:
 [0.9604571867463079, -0.866973784619343, -0.5555702330196022]
 [2.4033292980421757, 0.06610274757236567, -0.9807852804032304]
 [2.679228677325119, 1.3209370977497819, -0.19509032201612828]
 [1.74615214513341, 2.042849387038702, 0.8314696123025452]
 [0.21541841567305087, 1.6526687430064453, 0.8314696123025452]
 [-1.0162894527200281, 0.20979663171057739, -0.19509032201612828]
 [-1.2921888320029713, -1.5968364770327248, -0.9807852804032304]
 [-0.5702765427140513, -2.828544345425804, -0.5555702330196022]
 [0.5702765427140513, -2.828544345425804, 0.5555702330196022]
 [1.2921888320029713, -1.5968364770327248, 0.9807852804032304]
 [1.0162894527200281, 0.20979663171057739, 0.19509032201612828]
 [-0.21541841567305087, 1.6526687430064453, -0.8314696123025452]
 [-1.74615214513341, 2.042849387038702, -0.8314696123025452]
 [-2.679228677325119, 1.3209370977497819, 0.19509032201612828]
 [-2.4033292980421757, 0.06610274757236567, 0.9807852804032304]
 [-0.9604571867463079, -0.866973784619343, 0.5555702330196022]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/Filaments.jl#L388-L573">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.from_vector_field" href="#VortexPasta.Filaments.from_vector_field"><code>VortexPasta.Filaments.from_vector_field</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Filaments.from_vector_field(
    ClosedFilament, ωf::Function, s⃗₀, dτ, method::DiscretisationMethod;
    max_steps = 1000, nsubsteps = 1, redistribute = true,
) -&gt; ClosedFilament</code></pre><p>Initialise closed filament from vector field.</p><p>Here <code>ωf</code> is a function <span>$\bm{ω}(\bm{x})$</span> which takes a 3D vector <code>x⃗</code> and returns a vector value <code>ω⃗</code>. A filament will be created such that, for each point <span>$\bm{s}$</span> on the filament, the tangent vector <span>$\bm{s}&#39;$</span> is parallel to the vector field at that point, <span>$\bm{ω}(\bm{s})$</span>. The field should be such that lines constructed this way are closed.</p><p>A possible application of this function is for constructing a filament which approximates <strong>vortex lines</strong> from a vorticity field <span>$\bm{ω}(\bm{x})$</span>, which are precisely defined in this way. In that case, if one actually knows the <strong>velocity field</strong> <span>$\bm{v}(\bm{x})$</span> – such that <span>$\bm{ω} = \bm{\nabla} × \bm{v}$</span> – and one is too lazy to analytically derive the corresponding vorticity field, one can pass <code>ωf = Filaments.curl(vf)</code> (see <a href="#VortexPasta.Filaments.curl"><code>curl</code></a>) where <code>vf</code> is a function defining the velocity field.</p><p>One may use <a href="#VortexPasta.Filaments.distance_to_field"><code>Filaments.distance_to_field</code></a> to verify the result of this function.</p><p><strong>Positional arguments</strong></p><ul><li><p><code>ωf::Function</code>: function taking a 3D coordinate <code>x⃗</code> and returning a vector value <code>ω⃗</code>;</p></li><li><p><code>s⃗₀::Vec3</code>: location where to start iterating.  This point is guaranteed to be in the generated filament;</p></li><li><p><code>dτ::Real</code>: approximately distance between filament nodes. Determines the number of nodes in the resulting filament. The value of <code>dτ/nsubsteps</code> should be small enough to converge and so that the discretised lines are properly closed (see below for details);</p></li><li><p><code>method::DiscretisationMethod</code>: discretisation method to use (e.g. <a href="#VortexPasta.Filaments.QuinticSplineMethod"><code>QuinticSplineMethod()</code></a>).</p></li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><p><code>max_steps::Int = 1000</code>: maximum number of steps before we stop iterating. This is also the maximum possible length of the returned filament;</p></li><li><p><code>nsubsteps::Int = 1</code>: number of solver substeps to perform for each spatial increment <code>dτ</code>. Larger values may be used to improve accuracy;</p></li><li><p><code>redistribute = true</code>: if <code>true</code> (default), <a href="#VortexPasta.Filaments.redistribute_nodes!"><code>redistribute_nodes!</code></a> is called at the end to make sure that nodes are approximately distributed in a uniform way along the filament.</p></li></ul><p><strong>Extended help</strong></p><p><strong>Example</strong></p><p>Generate a single filament aligned with the Taylor–Green vorticity field.</p><p>For convenience, we work with the Taylor–Green <strong><em>velocity</em></strong> field, and the vorticity is obtained via automatic differentiation (but we could directly work with the analytical vorticity instead).</p><pre><code class="language-julia-repl hljs">julia&gt; function taylor_green_velocity(x⃗::Vec3)
           x, y, z = x⃗
           Vec3(
               cos(x) * sin(y) * cos(z),
               -sin(x) * cos(y) * cos(z),
               0,
           )
       end
taylor_green_velocity (generic function with 1 method)

julia&gt; ωf = Filaments.curl(taylor_green_velocity)  # vorticity field (via automatic differentiation)
#60 (generic function with 1 method)

julia&gt; s⃗₀ = Vec3(0.1, 1.8, 0.42);  # starting point for creating the filament

julia&gt; dτ = 0.1;  # pseudo time-step (has units of length; determines line resolution)

julia&gt; nsubsteps = 4;  # this is just to ensure convergence (should be larger for larger dτ)

julia&gt; f = Filaments.from_vector_field(ClosedFilament, ωf, s⃗₀, dτ, QuinticSplineMethod(); nsubsteps);

julia&gt; summary(f)
&quot;29-element ClosedFilament{SVector{3, Float64}, QuinticSplineMethod}&quot;

julia&gt; Filaments.distance_to_field(ωf, f)  # check that we&#39;re close to the actual vortex line
3.9561046185765664e-5</code></pre><p><strong>Implementation details</strong></p><p>The filament is generated by numerically solving the ODE:</p><p class="math-container">\[\frac{\mathrm{d}\bm{s}(τ)}{\mathrm{d}τ} = \hat{\bm{ω}}(\bm{s}), \quad \bm{s}(0) = \bm{s}_0,\]</p><p>where <span>$τ$</span> denotes a &quot;pseudo-time&quot; (which actually has units of a length) and <span>$\hat{\bm{ω}} = \bm{ω} / |\bm{ω}|$</span> is a unitary vector aligned with the vector field. The ODE is solved numerically using a standard 4th order Runge–Kutta scheme.</p><p>In this context, the <span>$dτ$</span> argument is actually the &quot;timestep&quot; used when solving this ODE. It must be small enough so that the curve is accurately tracked.</p><p>Note that the curve will be automatically closed (and the ODE stopped) if we reach an <span>$\bm{s}(τ)$</span> which is sufficiently close (closer than <span>$dτ/2$</span>) to the starting point <span>$\bm{s}_0$</span>. If that never happens, we stop after we have performed <code>max_steps</code> solver iterations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/from_vector_field.jl#L6-L112">source</a></section></article><h2 id="Curve-representation"><a class="docs-heading-anchor" href="#Curve-representation">Curve representation</a><a id="Curve-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Curve-representation" title="Permalink"></a></h2><h3 id="Discretisation-methods"><a class="docs-heading-anchor" href="#Discretisation-methods">Discretisation methods</a><a id="Discretisation-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Discretisation-methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.DiscretisationMethod" href="#VortexPasta.Filaments.DiscretisationMethod"><code>VortexPasta.Filaments.DiscretisationMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DiscretisationMethod</code></pre><p>Abstract type defining a filament discretisation method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/discretisations.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.SplineMethod" href="#VortexPasta.Filaments.SplineMethod"><code>VortexPasta.Filaments.SplineMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SplineMethod{k} &lt;: DiscretisationMethod</code></pre><p>Represents parametric curves using splines of order <span>$k$</span>.</p><p>A spline of order <span>$k$</span> is a piecewise polynomial with polynomial degree <span>$k - 1$</span> in-between interpolation nodes. For instance, cubic splines correspond to <span>$k = 4$</span>. On an interpolation node, the function has continuity <span>$C^{k - 2}$</span>.</p><p>See also <a href="#VortexPasta.Filaments.CubicSplineMethod"><code>CubicSplineMethod</code></a> and <a href="#VortexPasta.Filaments.QuinticSplineMethod"><code>QuinticSplineMethod</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/spline/spline.jl#L8-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.CubicSplineMethod" href="#VortexPasta.Filaments.CubicSplineMethod"><code>VortexPasta.Filaments.CubicSplineMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CubicSplineMethod &lt;: DiscretisationMethod</code></pre><p>Represents curves using cubic splines.</p><p>This is an alias for <code>SplineMethod{4}</code> (see <a href="#VortexPasta.Filaments.SplineMethod"><code>SplineMethod</code></a>).</p><p>In the case of closed curves, periodic cubic splines are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/spline/spline.jl#L35-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.QuinticSplineMethod" href="#VortexPasta.Filaments.QuinticSplineMethod"><code>VortexPasta.Filaments.QuinticSplineMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuinticSplineMethod &lt;: DiscretisationMethod</code></pre><p>Represents curves using quintic splines.</p><p>This is an alias for <code>SplineMethod{6}</code> (see <a href="#VortexPasta.Filaments.SplineMethod"><code>SplineMethod</code></a>).</p><p>A quintic spline is made of polynomials of degree 5 and has global continuity <span>$C^4$</span>.</p><p>In the case of closed curves, periodic quintic splines are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/spline/spline.jl#L50-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.FiniteDiffMethod" href="#VortexPasta.Filaments.FiniteDiffMethod"><code>VortexPasta.Filaments.FiniteDiffMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FiniteDiffMethod{M} &lt;: DiscretisationMethod{M}
FiniteDiffMethod([M = 2], [interpolation = HermiteInterpolation(M)])</code></pre><p>Estimation of curve derivatives at filament nodes using finite differences.</p><p>For now, only the case <code>M = 2</code> (default) is implemented (4th order / 5-point finite differences), following the method used by <a href="../../references/#Baggaley2011">Baggaley and Barenghi (2011)</a> based on a paper by <a href="../../references/#Gamet1999">Gamet <em>et al.</em> (1999)</a>.</p><p><code>FiniteDiffMethod</code> also requires specifying an interpolation scheme for evaluating coordinates and derivatives in-between discretisation points. By default, Hermite interpolations of continuity <span>$C^M$</span> are used. For the case <code>M = 2</code>, that means quintic Hermite interpolations, which match the first two derivatives estimated by finite differences at the discretisation points.</p><p><strong>References</strong></p><ul><li>(<a href="../../references/#Baggaley2011">Baggaley and Barenghi, 2011</a>) Baggaley &amp; Barenghi, Phys. Rev. B <strong>83</strong>, 134509 (2011)</li><li>(<a href="../../references/#Gamet1999">Gamet <em>et al.</em>, 1999</a>) Gamet <em>et al.</em>, Int. J. Numer. Meth. Fluids <strong>29</strong>, 2 (1999)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/finitediff/finitediff.jl#L4-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.FourierMethod" href="#VortexPasta.Filaments.FourierMethod"><code>VortexPasta.Filaments.FourierMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FourierMethod &lt;: DiscretisationMethod
FourierMethod(interpolation = HermiteInterpolation(2))</code></pre><p>Represents closed curves using Fourier series.</p><p>Derivatives at nodes are estimated using FFTs. To interpolate in-between nodes, a local interpolation method (typically <a href="#VortexPasta.Filaments.HermiteInterpolation"><code>HermiteInterpolation</code></a>) is used, which is much faster (but less accurate) than evaluating Fourier series.</p><p>Note that using FFTs require the knot locations <span>$t_i$</span> to be equidistant. The default parametrisation used by this method ensures this. However, this usually works best when the distance between discretisation points is more or less constant.</p><p>This method should only be used for simple settings and for verification of filament derivatives in other methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/fourier/fourier.jl#L6-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.discretisation_method" href="#VortexPasta.Filaments.discretisation_method"><code>VortexPasta.Filaments.discretisation_method</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">discretisation_method(f::AbstractFilament) -&gt; DiscretisationMethod</code></pre><p>Return the method used to discretise the filament based on its node locations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/Filaments.jl#L192-L196">source</a></section></article><h3 id="Interpolation"><a class="docs-heading-anchor" href="#Interpolation">Interpolation</a><a id="Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.interpolation_method" href="#VortexPasta.Filaments.interpolation_method"><code>VortexPasta.Filaments.interpolation_method</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolation_method(m::DiscretisationMethod)</code></pre><p>Return the interpolation method associated to a <a href="#VortexPasta.Filaments.DiscretisationMethod"><code>DiscretisationMethod</code></a>.</p><p>For <a href="#VortexPasta.Filaments.FiniteDiffMethod"><code>FiniteDiffMethod</code></a> and <a href="#VortexPasta.Filaments.FourierMethod"><code>FourierMethod</code></a>, this is usually a <a href="#VortexPasta.Filaments.HermiteInterpolation"><code>HermiteInterpolation</code></a> (which requires derivatives at the interpolation nodes). For <a href="#VortexPasta.Filaments.SplineMethod"><code>SplineMethod</code></a>s, since splines don&#39;t rely on a separate interpolation scheme, this simply returns <code>m</code> (i.e. the passed <code>SplineMethod</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/discretisations.jl#L12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.required_derivatives" href="#VortexPasta.Filaments.required_derivatives"><code>VortexPasta.Filaments.required_derivatives</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">required_derivatives(m::DiscretisationMethod) -&gt; Int</code></pre><p>Return the number of derivatives on interpolation nodes required by the discretisation method.</p><p>This is generally larger than 0 for methods relying on Hermite interpolations (which require derivatives on interpolation nodes). This is 0 for other methods such as <a href="#VortexPasta.Filaments.SplineMethod"><code>SplineMethod</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/discretisations.jl#L24-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.init_coefficients" href="#VortexPasta.Filaments.init_coefficients"><code>VortexPasta.Filaments.init_coefficients</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_coefficients(method::DiscretisationMethod, ys::AbstractVector, [nderivs::Val]) -&gt; DiscretisationCoefs
init_coefficients(method::DiscretisationMethod, cs::PaddedVector, cderivs::NTuple)  -&gt; DiscretisationCoefs</code></pre><p>Initialise interpolation coefficients.</p><p>In the first case, the <code>ys</code> vector is interpreted as a vector of values at interpolation nodes, and it will not be modified by the function. Note that this requires the allocation of a coefficient vector. Moreover, the <code>nderivs</code> argument indicates the number of derivatives that one wants to be able to compute. By default, <code>nderiv</code> is chosen as the minimum number of derivatives required by the method (see <a href="#VortexPasta.Filaments.required_derivatives"><code>required_derivatives</code></a>).</p><p>In the second case, <code>cs</code> is interpreted as a vector of interpolation coefficients, and is thus stored in the returned structure. Moreover, to compute one or more derivatives, one can pass <code>cderivs</code> vectors which should have the same type and length as <code>cs</code>.</p><div class="admonition is-info"><header class="admonition-header">Hermite interpolations</header><div class="admonition-body"><p>Some discretisation methods (<a href="#VortexPasta.Filaments.FiniteDiffMethod"><code>FiniteDiffMethod</code></a>, <a href="#VortexPasta.Filaments.FourierMethod"><code>FourierMethod</code></a>) require one or more derivatives to evaluate Hermite interpolations, as determined by <a href="#VortexPasta.Filaments.required_derivatives"><code>required_derivatives</code></a>.</p><p>In the first variant, if one passes e.g. <code>nderivs = Val(0)</code>, then this argument will be silently replaced by the required number of derivatives to make things work.</p><p>In the second variant, things will fail if <code>length(cderivs) &lt; required_derivatives(method)</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/discretisations.jl#L45-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.compute_coefficients!" href="#VortexPasta.Filaments.compute_coefficients!"><code>VortexPasta.Filaments.compute_coefficients!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_coefficients!(coefs::DiscretisationCoefs, [ys::AbstractVector], ts::PaddedVector)</code></pre><p>Compute interpolation coefficients of parametric function <span>$f(t)$</span>.</p><p>Here <code>ys</code> contains values at interpolation nodes, and <code>ts</code> contains the values of the curve parameter <span>$t$</span> at the nodes.</p><p>If <code>ys</code> is not passed, then the <code>coefs.cs</code> vector is expected to have the values at interpolation points (which will be overwritten with the interpolation coefficients).</p><p>This should be called before evaluating an interpolation using <a href="#VortexPasta.Filaments.evaluate"><code>evaluate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/discretisations.jl#L108-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.evaluate" href="#VortexPasta.Filaments.evaluate"><code>VortexPasta.Filaments.evaluate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate(coefs::DiscretisationCoefs, ts::PaddedVector, t::Real, [Derivative(0)]; [ileft = nothing])
evaluate(coefs::DiscretisationCoefs, ts::PaddedVector, i::Int, ζ::Real, [Derivative(0)])</code></pre><p>Evaluate interpolation at a given location <span>$t$</span> or <span>$ζ$</span>.</p><p>In the first case, <span>$t$</span> corresponds to the <em>global</em> curve parametrisation. One can optionally indicate the segment index <code>i</code> (such that <code>ts[i] ≤ t &lt; ts[i + 1]</code>) using the <code>ileft</code> keyword argument.</p><p>In the second case, <span>$ζ ∈ [0, 1]$</span> corresponds to the <em>local</em> curve parametrisation, within the segment <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/discretisations.jl#L127-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.LocalInterpolationMethod" href="#VortexPasta.Filaments.LocalInterpolationMethod"><code>VortexPasta.Filaments.LocalInterpolationMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LocalInterpolationMethod</code></pre><p>Abstract type defining a local interpolation method for estimating curve properties (coordinates, derivatives) in-between interpolation points using local information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/interpolation/interpolation.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.HermiteInterpolation" href="#VortexPasta.Filaments.HermiteInterpolation"><code>VortexPasta.Filaments.HermiteInterpolation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HermiteInterpolation{M} &lt;: LocalInterpolationMethod</code></pre><p>Hermite interpolation of continuity <span>$C^M$</span> at interpolation points.</p><p>Hermite interpolations are obtained using curve derivatives up to order <span>$M$</span>.</p><p><strong>Allowed cases</strong></p><ul><li><p>for <span>$M = 0$</span> this is simply linear interpolation (note that curvatures cannot be estimated from linear interpolations);</p></li><li><p>for <span>$M = 1$</span> this is the standard Hermite interpolation (piecewise cubic polynomials, requires first derivatives at interpolation points);</p></li><li><p>for <span>$M = 2$</span> this is a quintic Hermite interpolation requiring first and second derivatives at interpolation points.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/interpolation/hermite.jl#L4-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.interpolate" href="#VortexPasta.Filaments.interpolate"><code>VortexPasta.Filaments.interpolate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolate(
    method::LocalInterpolationMethod, derivative::Derivative, t::Number,
    values_at_interpolation_points...,
)</code></pre><p>Interpolate coordinates <span>$\bm{X}(t)$</span> or their derivatives at a given location <span>$t$</span>.</p><p>Under this form, the location <span>$t$</span> must be normalised such that the interval of interest is in <span>$t ∈ [0, 1]$</span>. Note that input and output derivatives must also be normalised accordingly.</p><p>The <code>values_at_interpolation_points</code> depend on the interpolation method:</p><ul><li>for <a href="#VortexPasta.Filaments.HermiteInterpolation"><code>HermiteInterpolation</code></a>, one should pass the coordinates <span>$\bm{X}$</span> and the first <span>$M$</span> derivatives at the two endpoints of the interval (<span>$t = 0$</span> and <span>$1$</span>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/interpolation/interpolation.jl#L11-L29">source</a></section></article><h2 id="Obtaining-information"><a class="docs-heading-anchor" href="#Obtaining-information">Obtaining information</a><a id="Obtaining-information-1"></a><a class="docs-heading-anchor-permalink" href="#Obtaining-information" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.knots" href="#VortexPasta.Filaments.knots"><code>VortexPasta.Filaments.knots</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">knots(f::AbstractFilament{T}) -&gt; AbstractVector{T}</code></pre><p>Return parametrisation knots <span>$t_i$</span> of the filament.</p><p>Filaments are parametrised by <span>$\bm{s}(t)$</span> for <span>$t ∈ [0, T]$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/Filaments.jl#L275-L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.knotlims" href="#VortexPasta.Filaments.knotlims"><code>VortexPasta.Filaments.knotlims</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">knotlims(f::AbstractFilament) -&gt; (t_begin, t_end)</code></pre><p>Return limits within which the filament can be evaluated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/Filaments.jl#L313-L317">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.end_to_end_offset" href="#VortexPasta.Filaments.end_to_end_offset"><code>VortexPasta.Filaments.end_to_end_offset</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">end_to_end_offset(f::ClosedFilament{T}) -&gt; Vec3{T}</code></pre><p>Return the end-to-end offset <code>Δ⃗ = f[end + 1] - f[begin]</code> of a &quot;closed&quot; filament.</p><p>For actually closed filaments, the end-to-end offset is zero. However, <code>ClosedFilament</code> also supports the case of infinite (but unclosed) filaments, which infinitely extend along one or more Cartesian directions. The restriction imposed by <code>ClosedFilament</code> is that infinite filaments repeat themselves periodically, such that <code>f[i + m * N] == f[i] + m * Δ⃗</code> where <code>N</code> is the <code>length</code> of the filament (i.e. the number of degrees of freedom, or the total number of <em>independent</em> filament nodes).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/closed_filament.jl#L195-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.minimum" href="#Base.minimum"><code>Base.minimum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.minimum(node_distance, f::AbstractFilament) -&gt; Real
Base.minimum(node_distance, fs::AbstractVector{&lt;:AbstractFilament}) -&gt; Real</code></pre><p>Return the minimum distance <span>$δ$</span> between neighbouring discretisation points of a filament.</p><p>If a vector of filaments is passed (variant 2), then the minimum among all filaments is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/Filaments.jl#L216-L223">source</a></section><section><div><pre><code class="language-julia hljs">Base.minimum(knot_increment, f::AbstractFilament) -&gt; Real
Base.minimum(knot_increment, fs::AbstractVector{&lt;:AbstractFilament}) -&gt; Real</code></pre><p>Return the minimum increment <span>$Δt = t_{i + 1} - t_{i}$</span> between filament knots.</p><p>This is generally a good approximation for the minimum segment length, at least when the default <a href="#VortexPasta.Filaments.ChordalParametrisation"><code>ChordalParametrisation</code></a> is used. If this is not the case, it is better to pass <code>node_distance</code> instead of <code>knot_increment</code>, which always returns the distance between two neighbouring nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/Filaments.jl#L233-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.maximum" href="#Base.maximum"><code>Base.maximum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.maximum(node_distance, f::AbstractFilament) -&gt; Real
Base.maximum(node_distance, fs::AbstractVector{&lt;:AbstractFilament}) -&gt; Real</code></pre><p>Return the maximum distance <span>$δ$</span> between neighbouring discretisation points of a filament.</p><p>If a vector of filaments is passed (variant 2), then the maximum among all filaments is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/Filaments.jl#L216-L223">source</a></section><section><div><pre><code class="language-julia hljs">Base.maximum(knot_increment, f::AbstractFilament) -&gt; Real
Base.maximum(knot_increment, fs::AbstractVector{&lt;:AbstractFilament}) -&gt; Real</code></pre><p>Return the maximum increment <span>$Δt = t_{i + 1} - t_{i}$</span> between filament knots.</p><p>This is generally a good approximation for the maximum segment length, at least when the default <a href="#VortexPasta.Filaments.ChordalParametrisation"><code>ChordalParametrisation</code></a> is used. If this is not the case, it is better to pass <code>node_distance</code> instead of <code>knot_increment</code>, which always returns the distance between two neighbouring nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/Filaments.jl#L233-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.minimum_node_distance" href="#VortexPasta.Filaments.minimum_node_distance"><code>VortexPasta.Filaments.minimum_node_distance</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minimum_node_distance(f::AbstractFilament) -&gt; Real
minimum_node_distance(fs::AbstractVector{&lt;:AbstractFilament}) -&gt; Real</code></pre><p>Return the minimum distance <span>$δ$</span> between neighbouring discretisation points of a filament.</p><p>This is equivalent to calling <code>minimum(node_distance, f)</code>.</p><p>See also <a href="#Base.minimum"><code>minimum</code></a> and <a href="#VortexPasta.Filaments.minimum_knot_increment"><code>minimum_knot_increment</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/Filaments.jl#L263-L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.minimum_knot_increment" href="#VortexPasta.Filaments.minimum_knot_increment"><code>VortexPasta.Filaments.minimum_knot_increment</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minimum_knot_increment(f::AbstractFilament) -&gt; Real
minimum_knot_increment(fs::AbstractVector{&lt;:AbstractFilament}) -&gt; Real</code></pre><p>Return the minimum increment <span>$Δt = t_{i + 1} - t_{i}$</span> between filament knots.</p><p>This is equivalent to calling <code>minimum(knot_increment, f)</code>.</p><p>This is generally a good and fast approximation for the minimum segment length. However, this approximation is generally incorrect if one is using the <a href="#VortexPasta.Filaments.FourierMethod"><code>FourierMethod</code></a> discretisation method.</p><p>See also <a href="#Base.minimum"><code>minimum</code></a>, <a href="#VortexPasta.Filaments.minimum_node_distance"><code>minimum_node_distance</code></a> and <a href="#VortexPasta.Filaments.maximum_knot_increment"><code>maximum_knot_increment</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/Filaments.jl#L284-L297">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.maximum_knot_increment" href="#VortexPasta.Filaments.maximum_knot_increment"><code>VortexPasta.Filaments.maximum_knot_increment</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">maximum_knot_increment(f::AbstractFilament) -&gt; Real
maximum_knot_increment(fs::AbstractVector{&lt;:AbstractFilament}) -&gt; Real</code></pre><p>Return the maximum increment <span>$Δt = t_{i + 1} - t_{i}$</span> between filament knots.</p><p>This is equivalent to calling <code>maximum(knot_increment, f)</code>.</p><p>This is generally a good approximation for the maximum segment length. See also <a href="#Base.maximum"><code>maximum</code></a> and <a href="#VortexPasta.Filaments.minimum_knot_increment"><code>minimum_knot_increment</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/Filaments.jl#L300-L310">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.nodes" href="#VortexPasta.Filaments.nodes"><code>VortexPasta.Filaments.nodes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nodes(f::AbstractFilament{T}) -&gt; AbstractVector{T}</code></pre><p>Return the nodes (or discretisation points) <span>$\bm{s}_i$</span> of the filament.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/Filaments.jl#L199-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.filament_length" href="#VortexPasta.Filaments.filament_length"><code>VortexPasta.Filaments.filament_length</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filament_length(f::AbstractFilament; quad = nothing) -&gt; Real
filament_length(fs::AbstractVector{&lt;:AbstractFilament}; quad = nothing) -&gt; Real</code></pre><p>Estimate the length of one or more filaments.</p><p>By default, the filament length is estimated using a straight segment approximation, which is fast but doesn&#39;t account for the actual curve geometry in-between discretisation points, underestimating the actual length. A quadrature rule may be optionally passed using <code>quad</code> (e.g. <code>quad = GaussLegendre(4)</code>) to obtain a more accurate result.</p><p>See also <a href="#VortexPasta.Filaments.segment_length"><code>segment_length</code></a>, which is used by this function.</p><p><strong>Requirements</strong></p><p>In the straight-segment implementation (<code>quad = nothing</code>), one needs the filaments to be closed, i.e. <code>f[end + 1]</code> should be set to the right value. This can be achieved either by <a href="#VortexPasta.Filaments.update_coefficients!"><code>update_coefficients!</code></a> or <a href="#VortexPasta.Filaments.close_filament!"><code>close_filament!</code></a>.</p><p>In the quadrature-based implementation (<code>quad &lt;: AbstractQuadrature</code>), the interpolation coefficients must already have been computed via <a href="#VortexPasta.Filaments.update_coefficients!"><code>update_coefficients!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/utils.jl#L142-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.distance_to_field" href="#VortexPasta.Filaments.distance_to_field"><code>VortexPasta.Filaments.distance_to_field</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Filaments.distance_to_field(ωf::Function, f::AbstractFilament) -&gt; Real</code></pre><p>Return an estimate of the normalised &quot;distance&quot; between a filament and a target vector field.</p><p>This function is meant to be used to verify the result of <a href="#VortexPasta.Filaments.from_vector_field"><code>Filaments.from_vector_field</code></a>, more specifically to verify that the filament is everywhere tangent to the objective vector field.</p><p>Returns 0 if the filament is perfectly tangent to the vector field at all discretisation points.</p><p>See <a href="#VortexPasta.Filaments.from_vector_field"><code>Filaments.from_vector_field</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/from_vector_field.jl#L200-L213">source</a></section></article><h2 id="Modifying-filaments"><a class="docs-heading-anchor" href="#Modifying-filaments">Modifying filaments</a><a id="Modifying-filaments-1"></a><a class="docs-heading-anchor-permalink" href="#Modifying-filaments" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.update_coefficients!" href="#VortexPasta.Filaments.update_coefficients!"><code>VortexPasta.Filaments.update_coefficients!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_coefficients!(f::AbstractFilament; knots = nothing)</code></pre><p>Compute coefficients needed to perform inter-node interpolations and estimate derivatives.</p><p>Uses the current locations of the filament nodes. If nodes change, this function should be called to update the coefficients.</p><p>By default, this function also updates the parametrisation knots <span>$t_i$</span> according to the current node positions. One can override this by passing a <code>knots</code> vector as a keyword argument. In particular, one can pass <code>knots = knots(f)</code> to keep the parametrisation knots unchanged.</p><p>This function will fail if the number of filament nodes is smaller than that required by the discretisation method. For instance, closed filaments discretised using cubic splines must have at least 3 nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/Filaments.jl#L588-L605">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.close_filament!" href="#VortexPasta.Filaments.close_filament!"><code>VortexPasta.Filaments.close_filament!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">close_filament!(f::ClosedFilament) -&gt; f</code></pre><p>Set the filamend endpoint based on its starting point and its end-to-end offset.</p><p>This sets <code>f[end + 1] = f[begin] + Δ⃗</code> where <code>Δ⃗</code> is the end-to-end offset of the filament (see <a href="#VortexPasta.Filaments.end_to_end_offset"><code>end_to_end_offset</code></a>).</p><p>Calling this function is <em>not</em> needed if one has recently used <a href="#VortexPasta.Filaments.update_coefficients!"><code>update_coefficients!</code></a>, which already closes the filaments. This function should be used as a cheaper alternative to <code>update_coefficients!</code>, when one only wants to close a filament (for instance to compute its length via <a href="#VortexPasta.Filaments.filament_length"><code>filament_length</code></a>). This function can also be used when the filament is no longer considered as &quot;valid&quot; by the chosen discretisation method, which happens when the number of nodes falls below some threshold (see <a href="#VortexPasta.Filaments.check_nodes"><code>check_nodes</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/utils.jl#L118-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.change_offset" href="#VortexPasta.Filaments.change_offset"><code>VortexPasta.Filaments.change_offset</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">change_offset(f::ClosedFilament, offset::Vec3{&lt;:Real}) -&gt; f′</code></pre><p>Change spatial offset between a filament start and endpoints.</p><p>See <a href="#VortexPasta.Filaments.init"><code>init</code></a> for more details on optional spatial offsets.</p><p>This function is allocation-free. It returns a new filament which shares the same arrays as <code>f</code>, and only differs in the offset. Modifying nodes of the returned filament also modifies nodes of <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/closed_filament.jl#L209-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.fold_periodic!" href="#VortexPasta.Filaments.fold_periodic!"><code>VortexPasta.Filaments.fold_periodic!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fold_periodic!(Xs::AbstractVector{&lt;:Vec3}, Ls::NTuple{3, Real}) -&gt; Bool</code></pre><p>Fold a set of coordinates onto the main unit cell.</p><p>The idea is that the filament coordinates are (mainly) in the main unit cell, given by <span>$[0, L₁] × [0, L₂] × [0, L₃]$</span>, where <span>$Lᵢ$</span> is the period in each direction.</p><p>This is nice for visualisations, and might also improve performance of the folding required by long-range computations.</p><p>To avoid creating discontinuities in the filament, what this function actually does is to make sure that the <em>average</em> among all filament nodes is in the main unit cell.</p><p>Returns <code>true</code> if coordinates were modified, <code>false</code> otherwise. In the first case, one may want to call <a href="#VortexPasta.Filaments.update_coefficients!"><code>update_coefficients!</code></a> to update the curve representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/utils.jl#L3-L21">source</a></section><section><div><pre><code class="language-julia hljs">fold_periodic!(f::AbstractFilament, Ls) -&gt; Bool</code></pre><p>Fold filament nodes onto the main unit cell.</p><p>Returns <code>true</code> if coordinates were modified, <code>false</code> otherwise.</p><p>If <code>true</code>, coefficients may need to be updated afterwards using <a href="#VortexPasta.Filaments.update_coefficients!"><code>update_coefficients!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/utils.jl#L35-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.redistribute_nodes!" href="#VortexPasta.Filaments.redistribute_nodes!"><code>VortexPasta.Filaments.redistribute_nodes!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">redistribute_nodes!(f::AbstractFilament) -&gt; f</code></pre><p>Redistribute nodes of the filament so that they are (approximately) equally spaced.</p><p>More precisely, this function repositions the filament nodes such that the knot spacing <span>$t_{i + 1} - t_{i}$</span> is constant. In other words, the new locations satisfy <code>f[i] = f((i - 1) * Δt)</code> where <span>$Δt = t_{N + 1} / N$</span> is the knot spacing, <span>$N$</span> is the number of nodes, and the index <span>$N + 1$</span> refers to the filament endpoint (which is equal to the starting point for a closed filament).</p><p>One does not need to call <a href="#VortexPasta.Filaments.update_coefficients!"><code>update_coefficients!</code></a> after calling this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/Filaments.jl#L720-L732">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.split!" href="#VortexPasta.Filaments.split!"><code>VortexPasta.Filaments.split!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split!(f::ClosedFilament, i::Int, j::Int; p⃗ = Vec3(0, 0, 0)) -&gt; (f₁, f₂)</code></pre><p>Split closed filament into two filaments.</p><p>Assuming <code>j &gt; i</code>, the resulting filaments are respectively composed of nodes <code>f[i + 1:j]</code> and <code>f[(j + 1:end) ∪ (begin:i)]</code>.</p><p>In practice, a split makes sense when the nodes <code>f[i]</code> and <code>f[j] - p⃗</code> are spatially &quot;close&quot;. Here <code>p⃗</code> is an optional offset which usually takes into account domain periodicity (see also <a href="#VortexPasta.Filaments.find_min_distance"><code>find_min_distance</code></a>).</p><p>Note that this function modifies the filament <code>f</code>, which should then be discarded.</p><p>One should generally call <a href="#VortexPasta.Filaments.update_coefficients!"><code>update_coefficients!</code></a> on both filaments after a split.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/split_merge.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.merge!" href="#VortexPasta.Filaments.merge!"><code>VortexPasta.Filaments.merge!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">merge!(f::ClosedFilament, g::ClosedFilament, i::Int, j::Int; p⃗ = Vec3(0, 0, 0)) -&gt; ClosedFilament</code></pre><p>Merge two closed filaments into one.</p><p>The resulting filament is composed of nodes:</p><pre><code class="nohighlight hljs">f[begin:i] ∪ {g[(j + 1:end) ∪ (begin:j)] - p⃗} ∪ f[i + 1:end]</code></pre><p>Here <code>p⃗</code> is an optional offset which usually takes into account domain periodicity (see also <a href="#VortexPasta.Filaments.find_min_distance"><code>find_min_distance</code></a>).</p><p>This function returns a new filament <code>h</code> which may share memory with <code>f</code>. The filament <code>g</code> is not modified.</p><p>One should generally call <a href="#VortexPasta.Filaments.update_coefficients!"><code>update_coefficients!</code></a> on the returned filament after merging.</p><p><strong>Merging a filament with its shifted image</strong></p><p>This function supports merging a filament <code>f</code> with a shifted version of itself, <code>g = f + p⃗</code>. For this, one should simply pass <code>g = f</code> and a non-zero offset <code>p⃗</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/split_merge.jl#L71-L92">source</a></section></article><h2 id="Curve-parametrisations"><a class="docs-heading-anchor" href="#Curve-parametrisations">Curve parametrisations</a><a id="Curve-parametrisations-1"></a><a class="docs-heading-anchor-permalink" href="#Curve-parametrisations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.AbstractParametrisation" href="#VortexPasta.Filaments.AbstractParametrisation"><code>VortexPasta.Filaments.AbstractParametrisation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractParametrisation</code></pre><p>Abstract type representing a curve parametrisation.</p><p>For a parametric curve <span>$\bm{s}(t)$</span>, the choice of the discrete knots <span>$t_i$</span> at given discrete nodes <span>$\bm{s}_i$</span> is not unique. The parametrisation determines the way the knots <span>$t_i$</span> are chosen.</p><p>Some predefined parametrisations include:</p><ul><li><a href="#VortexPasta.Filaments.ChordalParametrisation"><code>ChordalParametrisation</code></a>,</li><li><a href="#VortexPasta.Filaments.CentripetalParametrisation"><code>CentripetalParametrisation</code></a>,</li><li><a href="#VortexPasta.Filaments.FourierParametrisation"><code>FourierParametrisation</code></a>.</li></ul><p>Moreover, <a href="#VortexPasta.Filaments.CustomParametrisation"><code>CustomParametrisation</code></a> allows to define custom parametrisation functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/parametrisations.jl#L6-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.ChordalParametrisation" href="#VortexPasta.Filaments.ChordalParametrisation"><code>VortexPasta.Filaments.ChordalParametrisation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ChordalParametrisation &lt;: AbstractParametrisation
ChordalParametrisation()</code></pre><p>Represents the <em>chordal</em> parametrisation.</p><p>In this case, the increment between two knots is roughly equal to the length of the segment between the knots:</p><p class="math-container">\[t_{i + 1} = t_{i} + |\bm{s}_{i + 1} - \bm{s}_i|\]</p><p>This is known as the chordal parametrisation in the context of <a href="https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline">Catmull–Rom splines</a>.</p><p>This is the recommended (and default) parametrisation for general cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/parametrisations.jl#L25-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.CentripetalParametrisation" href="#VortexPasta.Filaments.CentripetalParametrisation"><code>VortexPasta.Filaments.CentripetalParametrisation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CentripetalParametrisation &lt;: AbstractParametrisation
CentripetalParametrisation()</code></pre><p>Represents the <em>centripetal</em> parametrisation.</p><p>In this case, the increment between two knots is given by:</p><p class="math-container">\[t_{i + 1} = t_{i} + |\bm{s}_{i + 1} - \bm{s}_i|^{1/2}\]</p><p>This is known as the centripetal parametrisation in the context of <a href="https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline">Catmull–Rom splines</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/parametrisations.jl#L46-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.FourierParametrisation" href="#VortexPasta.Filaments.FourierParametrisation"><code>VortexPasta.Filaments.FourierParametrisation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FourierParametrisation &lt;: AbstractParametrisation
FourierParametrisation()</code></pre><p>Curve parametrisation adapted for Fourier series representation of curves.</p><p>In this case, the increment between two knots is constant and given by:</p><p class="math-container">\[t_{i + 1} = t_{i} + \frac{2π}{N}\]</p><p>where <span>$N$</span> is the number of nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/parametrisations.jl#L66-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.CustomParametrisation" href="#VortexPasta.Filaments.CustomParametrisation"><code>VortexPasta.Filaments.CustomParametrisation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CustomParametrisation{F &lt;: Function} &lt;: AbstractParametrisation
CustomParametrisation(f::Function)</code></pre><p>Allows to define a custom curve parametrisation.</p><p>Here the function <code>f</code> should have the signature <code>f(Xs, i) → Δt</code> where <code>Xs</code> is the vector of discretisation nodes. It must return the knot increment <code>Δt = t_{i + 1} - t_{i}</code>.</p><p>For instance, the <a href="#VortexPasta.Filaments.ChordalParametrisation"><code>ChordalParametrisation</code></a> corresponds to defining</p><pre><code class="nohighlight hljs">f(Xs, i) = norm(Xs[i + 1] - Xs[i])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/parametrisations.jl#L83-L96">source</a></section></article><h2 id="Other-functions"><a class="docs-heading-anchor" href="#Other-functions">Other functions</a><a id="Other-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{AbstractFilament, Int64}" href="#Base.getindex-Tuple{AbstractFilament, Int64}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.getindex(f::AbstractFilament{T}, i::Int) -&gt; Vec3{T}
Base.getindex(f::AbstractFilament{T}, i::Int, ::Derivative{n}) -&gt; Vec3{T}
Base.getindex(f::AbstractFilament{T}, i::Int, ::GeometricQuantity)</code></pre><p>Return coordinates of discretisation point <span>$\bm{s}_i$</span>.</p><p>One may also obtain derivatives and other geometric quantities at point <span>$\bm{s}_i$</span> by passing an optional <a href="../BasicTypes/#VortexPasta.BasicTypes.Derivative"><code>Derivative</code></a> or <a href="#VortexPasta.Filaments.GeometricQuantity"><code>GeometricQuantity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/Filaments.jl#L367-L376">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.setindex!-Tuple{AbstractFilament, Any, Int64}" href="#Base.setindex!-Tuple{AbstractFilament, Any, Int64}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.setindex!(f::AbstractFilament{T}, v, i::Int) -&gt; Vec3{T}</code></pre><p>Set coordinates of discretisation point <span>$\bm{s}_i$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/Filaments.jl#L322-L326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.normalise_derivatives" href="#VortexPasta.Filaments.normalise_derivatives"><code>VortexPasta.Filaments.normalise_derivatives</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalise_derivatives(ṡ::Vec3, s̈::Vec3) -&gt; (s⃗′, s⃗″)
normalise_derivatives((ṡ, s̈)::NTuple)   -&gt; (s⃗′, s⃗″)</code></pre><p>Return derivatives with respect to the arc length <span>$ξ$</span>, from derivatives with respect to the parameter <span>$t$</span>.</p><p>The returned derivatives satisfy:</p><ul><li><p><span>$\bm{s}&#39; ≡ t̂$</span> is the <strong>unit tangent</strong> vector;</p></li><li><p><span>$\bm{s}&#39;&#39; ≡ ρ n̂$</span> is the <strong>curvature</strong> vector, where <span>$n̂$</span> is the normal unit vector (with <span>$t̂ ⋅ n̂ = 0$</span>) and <span>$ρ = R^{-1}$</span> is the curvature (and R the curvature radius).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/Filaments.jl#L641-L655">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.normalise_derivatives!" href="#VortexPasta.Filaments.normalise_derivatives!"><code>VortexPasta.Filaments.normalise_derivatives!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalise_derivatives!(Ẋ::AbstractVector, Ẍ::AbstractVector)</code></pre><p>Normalise vectors containing derivatives at filament locations.</p><p>If possible, prefer using <a href="#VortexPasta.Filaments.normalise_derivatives"><code>normalise_derivatives</code></a>, which works on a single filament location at a time.</p><p>See <a href="#VortexPasta.Filaments.normalise_derivatives"><code>normalise_derivatives</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/Filaments.jl#L664-L673">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.integrate" href="#VortexPasta.Filaments.integrate"><code>VortexPasta.Filaments.integrate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate(integrand::Function, f::AbstractFilament, i::Int, quad::AbstractQuadrature; limits = nothing)
integrate(integrand::Function, s::Segment, quad::AbstractQuadrature; limits = nothing)</code></pre><p>Estimate integral along a filament segment using the chosen quadrature.</p><p>Integration is performed in the segment <code>(f[i], f[i + 1])</code>.</p><p>The function <code>integrand(ζ)</code> takes the arguments <code>f</code>, <code>i</code> and <span>$ζ ∈ [0, 1]$</span>. The first two are a bit redundant since they&#39;re the same filament and node index passed to this function, while <code>ζ</code> corresponds to the position of a point within the segment. See further below for some examples.</p><p>By default, the integration is performed along the whole segment, that is, for the range <span>$ζ ∈ [0, 1]$</span>. It is possible to integrate over a subset of the segment, i.e. for <span>$ζ ∈ [a, b]$</span> with <span>$0 ≤ a ≤ b ≤ 1$</span>. For this, one should pass the keyword argument <code>limits = (a, b)</code>.</p><p><strong>Examples</strong></p><p>Estimate arc length of segment <span>$[i, i + 1]$</span>, given by <span>$ℓ = ∫_{t_{i}}^{t_{i + 1}} |∂_t \bm{X}(t)| \, \mathrm{d}t$</span>:</p><pre><code class="language-julia hljs">quad = GaussLegendre(4)  # quadrature rule
ℓ = integrate(f, i, quad) do f, i, ζ
    norm(f(i, ζ, Derivative(1)))  # = |∂ₜ𝐗|
end</code></pre><p>Alternatively:</p><pre><code class="language-julia hljs">quad = GaussLegendre(4)  # quadrature rule
s = Segment(f, i)
ℓ = integrate(s, quad) do s, ζ
    norm(s(ζ, Derivative(1)))  # = |∂ₜ𝐗|
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/integrate.jl#L3-L39">source</a></section><section><div><pre><code class="language-julia hljs">integrate(integrand::Function, f::AbstractFilament, quad::AbstractQuadrature; limits = nothing)</code></pre><p>Estimate integral over a whole filament.</p><p>The integral is computed as the sum of the integrals over each filament segment. The given quadrature rule is applied over each segment, meaning that the total number of evaluations is given by the number of segments multiplied by the length of the quadrature rule.</p><p>The signature of the integrated function must be <code>integrand(f::AbstractFilament, i::Int, ζ::Real)</code>, where <code>i</code> is the index of the segment of interest. See below for some examples.</p><p><strong>Examples</strong></p><p>Estimate the total length of a closed filament, <span>$L = ∮ |∂_t \bm{X}(t)| \, \mathrm{d}t$</span>:</p><pre><code class="language-julia hljs">quad = GaussLegendre(4)  # quadrature rule

integrand(f, i, ζ) = norm(f(i, ζ, Derivative(1)))  # = |∂ₜ𝐗|

# Here `f` is an existent filament.
L = integrate(integrand, f, quad)

# Or, more conveniently, using a `do` block to define an anonymous function.
L = integrate(f, quad) do ff, i, ζ
    norm(ff(i, ζ, Derivative(1)))  # = |∂ₜ𝐗|
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/integrate.jl#L71-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.find_min_distance" href="#VortexPasta.Filaments.find_min_distance"><code>VortexPasta.Filaments.find_min_distance</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_min_distance(
    fx::AbstractFilament, fy::AbstractFilament, i::Int, j::Int;
    periods::NTuple{3, Real} = (Infinity(), Infinity(), Infinity()),
    maxiter = 4, rtol = 1e-2,
)</code></pre><p>Determine the minimum distance between filament segments.</p><p>This function estimates the minimum distance between filament segments <code>fx[i:i+1]</code> and <code>fy[j:j+1]</code> via an iterative (Newton–Raphson) method.</p><p>The filaments <code>fx</code> and <code>fy</code> may be the same filament.</p><p><strong>Returns</strong></p><p>Returns a <code>NamedTuple</code> with the following fields:</p><ul><li><p><code>ζx</code>, <code>ζy</code>: optimal locations in <span>$[0, 1]$</span> within each segment;</p></li><li><p><code>x⃗</code>, <code>y⃗</code>: optimal locations within each segment;</p></li><li><p><code>p⃗</code>: periodic offset (each component is a multiple of the domain period along that direction);</p></li><li><p><code>d⃗</code>: minimum distance vector, <code>d⃗ = x⃗ - y⃗ + p⃗</code>.</p></li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><p><code>periods</code>: the period of the spatial domain. This should be given if one wants to take into account periodic images of the filaments;</p></li><li><p><code>maxiter = 4</code>: maximum number of iterations of the Newton method;</p></li><li><p><code>rtol = 1e-2</code>: relative tolerance for stopping the iterations. By default it&#39;s not very small since in general we don&#39;t need to be very precise.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/min_distance.jl#L28-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.check_nodes" href="#VortexPasta.Filaments.check_nodes"><code>VortexPasta.Filaments.check_nodes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_nodes(Bool, f::AbstractFilament) -&gt; Bool
check_nodes(f::AbstractFilament)</code></pre><p>Check whether current filament nodes are compatible with the filament discretisation method.</p><p>In its first form, this function returns <code>false</code> in case of incompatibility, while it throws an error in its second form.</p><p>For now, the only requirement is that the number of nodes must be larger than some small value. In particular, one can&#39;t have a closed filament with less than 3 nodes (but the specific discretisation method might impose some other small value).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/Filaments.jl#L608-L620">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.number_type" href="#VortexPasta.Filaments.number_type"><code>VortexPasta.Filaments.number_type</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">number_type(x) -&gt; Type{&lt;:Number}</code></pre><p>Obtain the number type associated to a container <code>x</code>.</p><p>This is expected to return a concrete type <code>T &lt;: Number</code>.</p><p>This function can be useful when the actual number type is hidden behind many nested array types.</p><p>Some examples:</p><ul><li>if <code>x</code> is a single <code>AbstractFilament{T}</code>, this returns <code>T</code>;</li><li>if <code>x</code> is a vector or tuple of <code>AbstractFilament{T}</code>, this also returns <code>T</code>; </li><li>if <code>x</code> is a vector of vectors of <code>SVector{3, T}</code>, this returns <code>T</code>.</li></ul><p>Note that, in the last two cases, this corresponds to <code>eltype(eltype(eltype(x)))</code>, which is less readable and prone to errors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/utils.jl#L189-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.curl" href="#VortexPasta.Filaments.curl"><code>VortexPasta.Filaments.curl</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Filaments.curl(vf::Function) -&gt; Function
Filaments.curl(vf::Function, x⃗::Vec3) -&gt; Vec3</code></pre><p>Return curl of a vector-valued field, <span>$\bm{ω}(\bm{x}) = \bm{∇} × \bm{v}(\bm{x})$</span>.</p><p>Here <code>vf</code> is a function <span>$\bm{v}(\bm{x})$</span> which takes a 3D vector <code>x⃗</code> and returns a vector value <code>v⃗</code>.</p><p>The curl of <code>vf</code> is obtained via automatic differentiation using ForwardDiff.jl.</p><p>The first variant returns a function which can be then evaluated at any <code>x⃗</code>. The second variant directly evaluates the curl at some <code>x⃗</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/from_vector_field.jl#L248-L261">source</a></section></article><h2 id="Refinement"><a class="docs-heading-anchor" href="#Refinement">Refinement</a><a id="Refinement-1"></a><a class="docs-heading-anchor-permalink" href="#Refinement" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.RefinementCriterion" href="#VortexPasta.Filaments.RefinementCriterion"><code>VortexPasta.Filaments.RefinementCriterion</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RefinementCriterion</code></pre><p>Abstract type describing a curve refinement criterion.</p><p>Implemented refinement criteria are:</p><ul><li><p><a href="#VortexPasta.Filaments.NoRefinement"><code>NoRefinement</code></a>: disables refinement;</p></li><li><p><a href="#VortexPasta.Filaments.RefineBasedOnSegmentLength"><code>RefineBasedOnSegmentLength</code></a>: enforces a minimum and maximum distance between neighbouring filament nodes;</p></li><li><p><a href="#VortexPasta.Filaments.RefineBasedOnCurvature"><code>RefineBasedOnCurvature</code></a>: inserts more nodes on highly-curved filament segments.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/refinement.jl#L55-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.NoRefinement" href="#VortexPasta.Filaments.NoRefinement"><code>VortexPasta.Filaments.NoRefinement</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoRefinement &lt;: RefinementCriterion
NoRefinement()</code></pre><p>Used to disable filament refinement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/refinement.jl#L173-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.RefineBasedOnSegmentLength" href="#VortexPasta.Filaments.RefineBasedOnSegmentLength"><code>VortexPasta.Filaments.RefineBasedOnSegmentLength</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RefineBasedOnSegmentLength &lt;: RefinementCriterion
RefineBasedOnSegmentLength(ℓ_min, ℓ_max = 2 * ℓ_min)</code></pre><p>Refinement criterion imposing a minimum segment length.</p><p>This refinement criterion imposes neighbouring filament nodes to be at a distance <span>$ℓ ∈ [ℓ_{\min}, ℓ_{\max}]$</span>. This means that:</p><ul><li><p>nodes are <strong>inserted</strong> if the distance between two nodes is <span>$ℓ &gt; ℓ_{\max}$</span>. The insertion is done at an intermediate position using the functional representation of the filament (e.g. splines or Hermite interpolation);</p></li><li><p>nodes are <strong>removed</strong> if the distance between two nodes is <span>$ℓ &lt; ℓ_{\min}$</span>. For a filament which is strongly curved at that point, this means that local information is lost and that the filament is smoothed.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/refinement.jl#L257-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.RefineBasedOnCurvature" href="#VortexPasta.Filaments.RefineBasedOnCurvature"><code>VortexPasta.Filaments.RefineBasedOnCurvature</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RefineBasedOnCurvature &lt;: RefinementCriterion
RefineBasedOnCurvature(ρℓ_max::Real, ρℓ_min = ρℓ_max / 2.5; ℓ_min = 0.0, ℓ_max = Inf)</code></pre><p>Curvature-based refinement criterion.</p><p><strong>Node insertion</strong></p><p>According to this criterion, a filament is locally refined if:</p><p class="math-container">\[ρ \left|\bm{X}_{i + 1} - \bm{X}_{i}\right| &gt; (ρℓ)_{\max}\]</p><p>where <span>$ρ$</span> is some estimation of the curvature of segment <span>$[i, i + 1]$</span>.</p><p>For splines, this uses a classical knot insertion algorithm which preserves the shape of the curve.</p><p><strong>Node removal</strong></p><p>Similarly, filaments nodes are removed based on the value of <code>ρℓ_min</code>. This value should be less than <code>ρℓ_max / 2</code> to avoid alternatively adding and removing nodes when repeatedly calling <a href="#VortexPasta.Filaments.refine!"><code>refine!</code></a>.</p><p>For safety, two adjacent nodes will never be removed in a single call to <code>refine!</code>.</p><p>Note that, when filaments are nearly straight, this may lead to the removal of most nodes. To limit this, set the keyword argument <code>ℓ_max</code> to some finite value determining the maximum length of a segment. Similarly, the keyword argument <code>ℓ_min</code> sets a lower limit for the distance between neighbouring nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/refinement.jl#L192-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.refine!" href="#VortexPasta.Filaments.refine!"><code>VortexPasta.Filaments.refine!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">refine!(f::AbstractFilament, crit::RefinementCriterion) -&gt; (Int, Int)</code></pre><p>Refine the filament according to a given criterion.</p><p>More precisely, this function can add and remove discretisation points according to the chosen refinement criterion.</p><p>Returns the number of added and removed nodes.</p><p>Example usage:</p><pre><code class="nohighlight hljs">crit = RefineBasedOnCurvature(0.5)
refine!(f, crit)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/refinement.jl#L97-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.insert_node!" href="#VortexPasta.Filaments.insert_node!"><code>VortexPasta.Filaments.insert_node!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">insert_node!(f::AbstractFilament, i::Integer, [ζ = 0.5]) -&gt; Vec3</code></pre><p>Insert node in-between locations <code>f[i]</code> and <code>f[i + 1]</code>.</p><p>The optional argument <code>ζ ∈ [0, 1]</code> corresponds to the relative location of the new node within the segment. By default it is set to <code>ζ = 0.5</code>, which corresponds to an estimation of the middle of the segment.</p><p>Note that <a href="#VortexPasta.Filaments.update_after_changing_nodes!"><code>update_after_changing_nodes!</code></a> must be called after inserting one or more nodes.</p><p>See also <a href="#VortexPasta.Filaments.remove_node!"><code>remove_node!</code></a>.</p><p>Returns the inserted node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/refinement.jl#L8-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.remove_node!" href="#VortexPasta.Filaments.remove_node!"><code>VortexPasta.Filaments.remove_node!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_node!(f::AbstractFilament, i::Integer) -&gt; Vec3</code></pre><p>Remove node at location <code>f[i]</code>.</p><p>Note that <a href="#VortexPasta.Filaments.update_after_changing_nodes!"><code>update_after_changing_nodes!</code></a> must be called after removing one or more nodes.</p><p>See also <a href="#VortexPasta.Filaments.insert_node!"><code>insert_node!</code></a>.</p><p>Returns the removed node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/refinement.jl#L28-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.update_after_changing_nodes!" href="#VortexPasta.Filaments.update_after_changing_nodes!"><code>VortexPasta.Filaments.update_after_changing_nodes!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_after_changing_nodes!(f::AbstractFilament)</code></pre><p>Update filament fields after changing nodes.</p><p>Depending on the filament discretisation method, this can recompute derivatives, knots or discretisation coefficients.</p><p>Should be called after inserting or removing filament nodes. See <a href="#VortexPasta.Filaments.insert_node!"><code>insert_node!</code></a> and <a href="#VortexPasta.Filaments.remove_node!"><code>remove_node!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/refinement.jl#L42-L52">source</a></section></article><h2 id="Geometric-quantities"><a class="docs-heading-anchor" href="#Geometric-quantities">Geometric quantities</a><a id="Geometric-quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-quantities" title="Permalink"></a></h2><p>The following types are provided as a convenient way of evaluating scalar and vector quantities of interest along filaments.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.GeometricQuantity" href="#VortexPasta.Filaments.GeometricQuantity"><code>VortexPasta.Filaments.GeometricQuantity</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeometricQuantity</code></pre><p>Abstract type defining a geometric quantity defined for a filament.</p><p>Some available geometric quantities include:</p><ul><li><p><a href="#VortexPasta.Filaments.UnitTangent"><code>UnitTangent</code></a>,</p></li><li><p><a href="#VortexPasta.Filaments.CurvatureVector"><code>CurvatureVector</code></a>,</p></li><li><p><a href="#VortexPasta.Filaments.CurvatureScalar"><code>CurvatureScalar</code></a>,</p></li><li><p><a href="#VortexPasta.Filaments.CurvatureBinormal"><code>CurvatureBinormal</code></a>,</p></li><li><p><a href="#VortexPasta.Filaments.TorsionScalar"><code>TorsionScalar</code></a>.</p></li></ul><p>Evaluating geometric quantities works in the same way as evaluating derivatives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/quantities.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.UnitTangent" href="#VortexPasta.Filaments.UnitTangent"><code>VortexPasta.Filaments.UnitTangent</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitTangent &lt;: GeometricQuantity</code></pre><p>Represents the unit tangent vector <span>$\bm{T}$</span> at a filament location.</p><p>In terms of an arbitrary parametrisation <span>$\bm{s}(t)$</span> (where <span>$t$</span> is in general different from the arc length <span>$ξ$</span>), the unit tangent vector is</p><p class="math-container">\[\bm{T} = \frac{\bm{s}&#39;}{|\bm{s}&#39;|}\]</p><p>where derivatives are with respect to the parameter <span>$t$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/quantities.jl#L39-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.CurvatureVector" href="#VortexPasta.Filaments.CurvatureVector"><code>VortexPasta.Filaments.CurvatureVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CurvatureVector &lt;: GeometricQuantity</code></pre><p>Represents the curvature vector associated to a filament.</p><p>In terms of an arbitrary parametrisation <span>$\bm{s}(t)$</span> (where <span>$t$</span> is in general different from the arc length <span>$ξ$</span>), the curvature vector is</p><p class="math-container">\[\bm{ρ}
= \frac{{|\bm{s}&#39;|}^2 \bm{s}&#39;&#39; - (\bm{s}&#39; ⋅ \bm{s}&#39;&#39;) \, \bm{s}&#39;}{|\bm{s}&#39;|^4}
= \frac{\bm{s}&#39; × (\bm{s}&#39;&#39; × \bm{s}&#39;)}{|\bm{s}&#39;|^4}\]</p><p>where derivatives are with respect to the parameter <span>$t$</span>.</p><p>The curvature vector can be written as <span>$\bm{ρ} = ρ \bm{N}$</span> where <span>$\bm{N}$</span> is the unit normal vector and <span>$ρ$</span> the scalar curvature (the inverse of the curvature radius).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/quantities.jl#L60-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.CurvatureScalar" href="#VortexPasta.Filaments.CurvatureScalar"><code>VortexPasta.Filaments.CurvatureScalar</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CurvatureScalar &lt;: GeometricQuantity</code></pre><p>Represents the scalar curvature associated to a filament.</p><p>This is simply the norm of <a href="#VortexPasta.Filaments.CurvatureVector"><code>CurvatureVector</code></a>. It is explicitly given by</p><p class="math-container">\[ρ = \frac{\bm{s}&#39; × \bm{s}&#39;&#39;}{|\bm{s}&#39;|^3}\]</p><p>where derivatives are with respect to the arbitrary parametrisation <span>$\bm{s}(t)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/quantities.jl#L88-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.CurvatureBinormal" href="#VortexPasta.Filaments.CurvatureBinormal"><code>VortexPasta.Filaments.CurvatureBinormal</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CurvatureBinormal &lt;: GeometricQuantity</code></pre><p>Represents the scaled binormal vector associated to a filament.</p><p>The scaled binormal vector is defined as <span>$\bm{b} = \bm{T} × ρ⃗ = ρ \, (\bm{T} × \bm{N}) = ρ \bm{B}$</span>, where <span>$\bm{B}$</span> is the (unit) binormal vector and <span>$ρ$</span> is the scalar curvature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/quantities.jl#L112-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.TorsionScalar" href="#VortexPasta.Filaments.TorsionScalar"><code>VortexPasta.Filaments.TorsionScalar</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TorsionScalar &lt;: GeometricQuantity</code></pre><p>Torsion of a filament.</p><p>The torsion <span>$τ$</span> describes the variation of the binormal vector along the curve.</p><p>It can be obtained as</p><p class="math-container">\[τ = \frac{(\bm{s}&#39; × \bm{s}&#39;&#39;) ⋅ \bm{s}&#39;&#39;&#39;}{|\bm{s}&#39; × \bm{s}&#39;&#39;|^2}\]</p><p>where derivatives are with respect to an arbitrary curve parametrisation.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Because it is obtained from third derivatives, estimating the torsion requires a high-order filament discretisation scheme such as <a href="#VortexPasta.Filaments.QuinticSplineMethod"><code>QuinticSplineMethod</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/quantities.jl#L129-L149">source</a></section></article><h2 id="Segments"><a class="docs-heading-anchor" href="#Segments">Segments</a><a id="Segments-1"></a><a class="docs-heading-anchor-permalink" href="#Segments" title="Permalink"></a></h2><h3 id="Segment-iterators"><a class="docs-heading-anchor" href="#Segment-iterators">Segment iterators</a><a id="Segment-iterators-1"></a><a class="docs-heading-anchor-permalink" href="#Segment-iterators" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.SegmentIterator" href="#VortexPasta.Filaments.SegmentIterator"><code>VortexPasta.Filaments.SegmentIterator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SegmentIterator{Filament &lt;: AbstractFilament}</code></pre><p>Convenience type allowing to iterate over the segments of a filament.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/segments.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.segments" href="#VortexPasta.Filaments.segments"><code>VortexPasta.Filaments.segments</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">segments(f::AbstractFilament) -&gt; SegmentIterator(f)</code></pre><p>Create a <a href="#VortexPasta.Filaments.SegmentIterator"><code>SegmentIterator</code></a> object for iterating over the segments of a filament.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/segments.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length-Tuple{VortexPasta.Filaments.SegmentIterator}" href="#Base.length-Tuple{VortexPasta.Filaments.SegmentIterator}"><code>Base.length</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.length(s::SegmentIterator{&lt;:AbstractFilament}) -&gt; Int</code></pre><p>Return the number of segments in a filament.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/segments.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.eachindex-Tuple{VortexPasta.Filaments.SegmentIterator}" href="#Base.eachindex-Tuple{VortexPasta.Filaments.SegmentIterator}"><code>Base.eachindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.eachindex(s::SegmentIterator{&lt;:AbstractFilament}) -&gt; AbstractRange</code></pre><p>Return the indices associated to the segments of a filament.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/segments.jl#L27-L31">source</a></section></article><h3 id="Single-segments"><a class="docs-heading-anchor" href="#Single-segments">Single segments</a><a id="Single-segments-1"></a><a class="docs-heading-anchor-permalink" href="#Single-segments" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.Segment" href="#VortexPasta.Filaments.Segment"><code>VortexPasta.Filaments.Segment</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Segment{&lt;:Filament}
Segment(f::AbstractFilament, i::Integer)</code></pre><p>Represents a single filament segment.</p><p>The segment goes from nodes <code>f[i]</code> to <code>f[i + 1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/segments.jl#L56-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.midpoint" href="#VortexPasta.Filaments.midpoint"><code>VortexPasta.Filaments.midpoint</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">midpoint(s::Segment) -&gt; Vec3</code></pre><p>Return an estimation of the segment midpoint (prioritising performance over accuracy).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/segments.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.segment_length" href="#VortexPasta.Filaments.segment_length"><code>VortexPasta.Filaments.segment_length</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Filaments.segment_length(s::Segment; quad = nothing)</code></pre><p>Estimate length of a filament segment.</p><p>One may pass a quadrature rule as <code>quad</code> for better accuracy. Otherwise, if <code>quad = nothing</code>, this simply returns the straight distance between the two segment extremities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/segments.jl#L99-L107">source</a></section></article><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.filamentplot!" href="#VortexPasta.Filaments.filamentplot!"><code>VortexPasta.Filaments.filamentplot!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filamentplot!([ax,] f::AbstractFilament, [velocities]; kws...)
MakieCore.plot!(ax, f::AbstractFilament, [velocities]; kws...)</code></pre><p>Plot filament onto existent 3D axis.</p><p>The first argument should typically be an <code>Axis3</code> or an <code>LScene</code>.</p><p>Example usage:</p><pre><code class="language-julia hljs">using GLMakie
fig = Figure()
ax = Axis3(fig[1, 1])
plot!(ax, f)  # f is a filament</code></pre><p><strong>Optional arguments and their defaults</strong></p><ul><li><p><code>refinement::Int = 1</code>: level of refinement of the curves (must be ≥ 1)</p></li><li><p><code>periods = (nothing, nothing, nothing)</code>. This can be a tuple of values representing the domain period, for instance <code>(2π, 2π, 2π)</code>. In that case, filaments will be &quot;broken&quot; when they exit the main unit cell, so that all vortex elements are within the cell.</p></li><li><p><code>color = :black</code></p></li><li><p><code>linewidth = 1.5f0</code></p></li><li><p><code>linestyle = :solid</code></p></li><li><p><code>markercolor = nothing</code> (<code>nothing</code> → same as <code>color</code>)</p></li><li><p><code>marker = :circle</code></p></li><li><p><code>markersize = 10.0f0</code></p></li><li><p><code>colormap = :viridis</code></p></li><li><p><code>colorrange = MakieCore.Automatic()</code></p></li></ul><p><strong>Arrow arguments</strong></p><p>The following are used when plotting arrows (tangents, curvatures, velocities, …):</p><ul><li><p><code>arrowscale = 1.0f0</code> allows to scale vectors (controls their <em>length</em>). Corresponds to <code>lengthscale</code> in <code>Makie.arrows</code>;</p></li><li><p><code>arrowsize = MakieCore.Automatic()</code> controls the head size. It has the same name in <code>Makie.arrows</code>. It should be a tuple <code>(sx, sy, sz)</code>, where the first 2 set the width of the cone, and <code>sz</code> its height;</p></li><li><p><code>arrowwidth = MakieCore.Automatic()</code> sets the linewidth of the arrow. Corresponds to <code>linewidth</code> in <code>Makie.arrows</code>.</p></li></ul><p>See also the <a href="https://docs.makie.org/stable/reference/plots/arrows/index.html">Makie docs on arrows</a>.</p><p><strong>Plotting tangent and curvature vectors</strong></p><p>Tangent and curvature vectors can be optionally plotted via the <code>tangents</code> and <code>curvatures</code> arguments. A single vector will be plotted for each filament segments. By default, vectors are evaluated at filament nodes, but one can also evaluate them in-between nodes using the <code>vectorpos</code> argument.</p><ul><li><p><code>tangents::Bool = false</code>: plot unit tangent vectors.</p></li><li><p><code>curvatures::Bool = false</code>: plot curvature vectors. Note that the magnitude is the local curvature <span>$ρ = 1 / R$</span>, where <span>$R$</span> is the curvature <em>radius</em>.</p></li><li><p><code>tangentcolor = nothing</code></p></li><li><p><code>curvaturecolor = nothing</code></p></li><li><p><code>vectorpos = 0.0</code>: relative vector positions within each segment. Must be in <span>$[0, 1]$</span>.</p></li></ul><p><strong>Plotting velocities of filament nodes</strong></p><p>Similarly, it is possible to plot vector quantities attached to filament nodes, such as filament velocities. For this pass a vector of velocities as a positional argument after the filament <code>f</code>.</p><p>Associated keyword arguments:</p><ul><li><code>velocitycolor = nothing</code> colour of velocity vectors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/plotting.jl#L22-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Filaments.filamentplot" href="#VortexPasta.Filaments.filamentplot"><code>VortexPasta.Filaments.filamentplot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filamentplot(f::AbstractFilament, [velocities]; kws...)
MakieCore.plot(f::AbstractFilament, [velocities]; kws...)</code></pre><p>Plot a filament using Makie.jl.</p><p>Example usage:</p><pre><code class="language-julia hljs">using GLMakie
plot(f; refinement = 4)  # f is a filament</code></pre><p>See <a href="#VortexPasta.Filaments.filamentplot!"><code>filamentplot!</code></a> for details and for optional keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/33beefdd21ce3b042cacfc1e85b3b03c3b670ad8/src/Filaments/plotting.jl#L5-L19">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Except for <a href="#VortexPasta.Filaments.FourierMethod"><code>FourierMethod</code></a>, which requires the parametrisation to have a   constant increment.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Quadratures/">« Quadratures</a><a class="docs-footer-nextpage" href="../FilamentIO/">FilamentIO »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 29 October 2024 09:37">Tuesday 29 October 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
