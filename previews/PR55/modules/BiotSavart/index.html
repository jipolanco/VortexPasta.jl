<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>BiotSavart · VortexPasta</title><meta name="title" content="BiotSavart · VortexPasta"/><meta property="og:title" content="BiotSavart · VortexPasta"/><meta property="twitter:title" content="BiotSavart · VortexPasta"/><meta name="description" content="Documentation for VortexPasta."/><meta property="og:description" content="Documentation for VortexPasta."/><meta property="twitter:description" content="Documentation for VortexPasta."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/fonts.css" rel="stylesheet" type="text/css"/><script src="../../assets/sa.js" data-collect-dnt="true" async></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">VortexPasta</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">VortexPasta.jl</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/01-vortex_ring/">Vortex ring</a></li><li><a class="tocitem" href="../../tutorials/02-kelvin_waves/">Kelvin waves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Explanations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../methods/VFM/">The vortex filament model</a></li><li><a class="tocitem" href="../../methods/Ewald/">Ewald summation for Biot–Savart</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Tips and tricks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tips/parallelisation/">Parallelisation and clusters</a></li><li><a class="tocitem" href="../../tips/gpu/">GPU usage</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../PaddedArrays/">PaddedArrays</a></li><li><a class="tocitem" href="../PredefinedCurves/">PredefinedCurves</a></li><li><a class="tocitem" href="../CellLists/">CellLists</a></li><li><a class="tocitem" href="../Quadratures/">Quadratures</a></li><li><a class="tocitem" href="../Filaments/">Filaments</a></li><li><a class="tocitem" href="../FilamentIO/">FilamentIO</a></li><li><a class="tocitem" href="../FindNearbySegments/">FindNearbySegments</a></li><li><a class="tocitem" href="../Constants/">Constants</a></li><li class="is-active"><a class="tocitem" href>BiotSavart</a><ul class="internal"><li><a class="tocitem" href="#Biot–Savart-parameters"><span>Biot–Savart parameters</span></a></li><li><a class="tocitem" href="#Exported-functions"><span>Exported functions</span></a></li><li><a class="tocitem" href="#Other-convenience-functions"><span>Other convenience functions</span></a></li><li><a class="tocitem" href="#Short-range-interactions"><span>Short-range interactions</span></a></li><li><a class="tocitem" href="#Long-range-interactions"><span>Long-range interactions</span></a></li><li><a class="tocitem" href="#KernelAbstractions-utils"><span>KernelAbstractions utils</span></a></li><li><a class="tocitem" href="#Internals-3"><span>Internals</span></a></li></ul></li><li><a class="tocitem" href="../SyntheticFields/">SyntheticFields</a></li><li><a class="tocitem" href="../Forcing/">Forcing</a></li><li><a class="tocitem" href="../Containers/">Containers</a></li><li><a class="tocitem" href="../Reconnections/">Reconnections</a></li><li><a class="tocitem" href="../Timestepping/">Timestepping</a></li><li><a class="tocitem" href="../Diagnostics/">Diagnostics</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>BiotSavart</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>BiotSavart</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jipolanco/VortexPasta.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jipolanco/VortexPasta.jl/blob/master/docs/src/modules/BiotSavart.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="BiotSavart"><a class="docs-heading-anchor" href="#BiotSavart">BiotSavart</a><a id="BiotSavart-1"></a><a class="docs-heading-anchor-permalink" href="#BiotSavart" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart" href="#VortexPasta.BiotSavart"><code>VortexPasta.BiotSavart</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BiotSavart</code></pre><p>Module for estimation of Biot–Savart integrals along vortex filaments using fast Ewald splitting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/BiotSavart.jl#L1-L6">source</a></section></article><h2 id="Biot–Savart-parameters"><a class="docs-heading-anchor" href="#Biot–Savart-parameters">Biot–Savart parameters</a><a id="Biot–Savart-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Biot–Savart-parameters" title="Permalink"></a></h2><h3 id="Setting-the-parameters"><a class="docs-heading-anchor" href="#Setting-the-parameters">Setting the parameters</a><a id="Setting-the-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-the-parameters" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.ParamsBiotSavart" href="#VortexPasta.BiotSavart.ParamsBiotSavart"><code>VortexPasta.BiotSavart.ParamsBiotSavart</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParamsBiotSavart{T &lt;: AbstractFloat}</code></pre><p>Contains parameters for calculation of Biot–Savart integrals using fast Ewald splitting.</p><p>The type parameter <code>T</code> corresponds to the precision used in computations (typically <code>Float64</code> or <code>Float32</code>).</p><p><strong>Construction</strong></p><pre><code class="nohighlight hljs">ParamsBiotSavart([T = Float64]; Γ, a, α, Ls, Ns, rcut, optional_kws...)</code></pre><p>where the optional parameter <code>T</code> sets the numerical precision.</p><p>Mandatory and optional keyword arguments are detailed in the extended help below.</p><p>See also <a href="#VortexPasta.BiotSavart.autotune"><code>BiotSavart.autotune</code></a> for an alternative way of setting Biot–Savart parameters.</p><p><strong>Extended help</strong></p><p><strong>Mandatory keyword arguments</strong></p><ul><li><p><code>Γ::Real</code>: vortex circulation (assumed constant);</p></li><li><p><code>a::Real</code>: vortex core size (assumed constant);</p></li><li><p><code>α::Real</code>: Ewald splitting parameter (inverse length scale). One can set <code>α = Zero()</code> to efficiently disable long-range computations.</p></li><li><p><code>Ls::Union{Real, NTuple{3, Real}}</code>: domain period in each Cartesian direction. If a single value is passed (e.g. <code>Ls = 2π</code>), it is assumed that periods are the same in all directions.</p><p>One can set <code>Ls = Infinity()</code> to disable periodicity. This should be done in combination with <code>α = Zero()</code>.</p></li><li><p><code>Ns::Dims{3}</code>: dimensions of physical grid used for long-range interactions. This parameter is not required if <code>α = Zero()</code>.</p></li><li><p><code>rcut</code>: cutoff distance for computation of short-range interactions. For performance and practical reasons, the cutoff distance must be less than half the cell unit size in each direction, i.e. <code>rcut &lt; minimum(Ls) / 2</code>. This parameter is not required if <code>α = Zero()</code>.</p></li></ul><p><strong>Optional keyword arguments (and their defaults)</strong></p><p><strong>General</strong></p><ul><li><code>quadrature::StaticSizeQuadrature = GaussLegendre(3)</code>: quadrature rule for short- and long-range interactions. For example, if <code>quadrature = GaussLegendre(4)</code>, then 4 evaluations of the Biot–Savart integrand will be done for each filament segment.</li></ul><p><strong>Short-range interactions</strong></p><ul><li><code>backend_short::ShortRangeBackend</code>: backend used to compute short-range interactions. The default is <code>CellListsBackend(2)</code>, unless periodicity is disabled, in which case <code>NaiveShortRangeBackend()</code> is used. See <a href="#VortexPasta.BiotSavart.ShortRangeBackend"><code>ShortRangeBackend</code></a> for a list of possible backends;</li></ul><p><strong>Long-range interactions</strong></p><ul><li><p><code>backend_long::LongRangeBackend = NonuniformFFTsBackend()</code>: backend used to compute long-range interactions. See <a href="#VortexPasta.BiotSavart.LongRangeBackend"><code>LongRangeBackend</code></a> for a list of possible backends;</p></li><li><p><code>longrange_truncate_spherical = false</code>: if <code>true</code>, perform a spherical truncation in Fourier space, discarding all wavenumbers such that <span>$|\bm{k}| &gt; k_{\text{max}}$</span>. This is not recommended as it leads to precision loss, and should be used for testing only (in particular, for verifying error estimates which assume this kind of truncation).</p></li></ul><p><strong>Local self-induced velocity</strong></p><ul><li><p><code>Δ = 0.25</code>: coefficient appearing in the local self-induced velocity (LIA term), which depends on the vorticity profile at the vortex core.</p><p>Some common values of <code>Δ</code> are:</p><ul><li><p><code>Δ = 0.25</code> for a constant vorticity profile (default);</p></li><li><p><code>Δ = 0.5</code> for a hollow vortex;</p></li><li><p><code>Δ ≈ 0.905 ≈ 0.558 + ln(2) / 2</code> for a Gaussian vorticity profile (taking <code>a</code> as the Gaussian standard deviation <code>σ</code>);</p></li><li><p><code>Δ ≈ 0.615</code> for a Gross–Pitaevskii vortex with healing length <code>a</code>.</p></li></ul><p>See Saffman (1992), sections 10.2–10.3 for the first three.</p></li><li><p><code>lia_segment_fraction = nothing</code>: can be used to indicate that the LIA term should be evaluated over a <em>fraction</em> of the two segments surrounding a node. In this case, it should be a real value in <span>$(0, 1]$</span>. The default (<code>nothing</code>) is equivalent to 1, and means that the LIA term is evaluated over the full segments. If smaller than 1, the velocity induced by the excluded part of the segments will be evaluated using the regular Biot–Savart law (using quadratures within each subsegment). This may improve accuracy, especially when the discretisation distance is relatively large. Since this means integrating near the singularity of the BS integral, this integral is by default estimated using adaptive quadratures (see <code>quadrature_near_singularity</code> below).</p></li><li><p><code>quadrature_near_singularity = AdaptiveTanhSinh(T; nlevels = 5)</code>: quadrature rule to be used when integrating near a singularity, in particular when <code>lia_segment_fraction</code> is enabled. By default an adaptive quadrature rule <a href="../Quadratures/#VortexPasta.Quadratures.AdaptiveTanhSinh"><code>AdaptiveTanhSinh</code></a> is used, which is generally accurate but can be costly. One can also pass a <a href="../Quadratures/#VortexPasta.Quadratures.StaticSizeQuadrature"><code>StaticSizeQuadrature</code></a> such as <a href="../Quadratures/#VortexPasta.Quadratures.GaussLegendre"><code>GaussLegendre</code></a>, but in that case accuracy is not guaranteed.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/params.jl#L198-L301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.autotune" href="#VortexPasta.BiotSavart.autotune"><code>VortexPasta.BiotSavart.autotune</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BiotSavart.autotune(fs::AbstractVector{&lt;:AbstractFilament{T}}, [β::Real = 3.5]; kwargs...) -&gt; ParamsBiotSavart{T}</code></pre><p>Generate Biot-Savart parameters optimised for a given filament geometry and accuracy parameter <span>$β$</span>.</p><p>Based on the given value of <span>$β$</span>, this function will try to automatically set the following Ewald-related parameters:</p><ul><li>inverse splitting parameter <span>$α$</span>;</li><li>cut-off distance <span>$r_{\text{cut}} = β / α$</span>;</li><li>Fourier-space cut-off <span>$k_{\text{max}} = 2αβ ≈ πM/L$</span>, where <span>$M$</span> is the grid size and <span>$L$</span> the domain period.</li></ul><p>In practice, this function will try to find the value of <span>$α$</span> which minimises the computation of the velocity of the filaments <code>fs</code>.</p><div class="admonition is-warning" id="Randomness-dbaa183e6c5b7e2e"><header class="admonition-header">Randomness<a class="admonition-anchor" href="#Randomness-dbaa183e6c5b7e2e" title="Permalink"></a></header><div class="admonition-body"><p>The parameters selected by this function can be quite random and change from one run to another for a same set of input parameters.</p></div></div><div class="admonition is-info" id="Default-accuracy-4121c08a3270e19d"><header class="admonition-header">Default accuracy<a class="admonition-anchor" href="#Default-accuracy-4121c08a3270e19d" title="Permalink"></a></header><div class="admonition-body"><p>The default values of <code>β</code> and <code>backend_long</code> correspond to a nominal 6-digit accuracy. See the <strong>Extended help</strong> for more details.</p></div></div><div class="admonition is-warning" id="Periodic-domains-only-34dd1bf4c561a200"><header class="admonition-header">Periodic domains only<a class="admonition-anchor" href="#Periodic-domains-only-34dd1bf4c561a200" title="Permalink"></a></header><div class="admonition-body"><p>This function only supports periodic domains (finite domain period <span>$L$</span>), since the chosen parameters are irrelevant in the non-periodic case.</p></div></div><p>See also <a href="#VortexPasta.BiotSavart.ParamsBiotSavart"><code>ParamsBiotSavart</code></a>.</p><p><strong>Extended help</strong></p><p><strong>Mandatory keyword arguments</strong></p><ul><li><p><code>Γ::Real</code>: vortex circulation (assumed constant);</p></li><li><p><code>a::Real</code>: vortex core size (assumed constant);</p></li><li><p><code>Ls::Union{Real, NTuple{3, Real}}</code>: domain period in each Cartesian direction. If a single value is passed (e.g. <code>Ls = 2π</code>), it is assumed that periods are the same in all directions.</p></li></ul><p><strong>Optional keyword arguments</strong></p><p>This function accepts the same keyword arguments as <a href="#VortexPasta.BiotSavart.ParamsBiotSavart"><code>ParamsBiotSavart</code></a> and with the same default values. In particular, the default short- and long-range backends are:</p><ul><li><p><code>backend_short::ShortRangeBackend = CellListsBackend(2)</code>;</p></li><li><p><code>backend_long::LongRangeBackend = NonuniformFFTsBackend(σ = 1.5, m = HalfSupport(4))</code>.</p></li></ul><p><strong>Autotuning parameters</strong></p><p>The following keyword arguments can be used to control autotuning:</p><ul><li><p><code>nruns = 4</code>: number of Biot–Savart calculations per value of <span>$α$</span>. The <em>minimum</em> elapsed time among all runs will be used in autotuning;</p></li><li><p><code>Cstart</code>: initial guess for non-dimensional factor <span>$C$</span> (see <strong>Autotuning algorithm</strong> below). Default values are 1.5 (pure CPU) and 4.0 (CPU + GPU).</p></li><li><p><code>ΔC = 0.1</code>: increment of non-dimensional factor <span>$C$</span>;</p></li><li><p><code>verbose = false</code>: if <code>true</code>, print autotuning information.</p></li></ul><p><strong>Autotuning algorithm</strong></p><p>The autotuning algorithm basically consists in trying different values of <span>$α$</span>, which we write under the form:</p><p class="math-container">\[α = C \, {( N / V )}^{1/3}\]</p><p>where <span>$N$</span> is the total number of filament nodes and <span>$V$</span> the domain volume. The parameter that is varied is the non-dimensional factor <span>$C$</span>.</p><p>For now the algorithm is quite basic. We try different values around <code>C = Cstart</code> using increments of <code>ΔC</code>. The parameters giving the fastest runtime are returned.</p><p><strong>Typical values of <span>$β$</span> and NUFFT parameters</strong></p><p>The following table roughly relates accuracy (in number of digits) and values of <span>$β$</span>, as detailed in <a href="../../references/#Polanco2025">Polanco (2025)</a>:</p><table><tr><th style="text-align: center">Precision digits</th><th style="text-align: center"><span>$β$</span></th><th style="text-align: center">NUFFT <span>$w$</span></th></tr><tr><td style="text-align: center">3</td><td style="text-align: center">2.0</td><td style="text-align: center">2</td></tr><tr><td style="text-align: center">4</td><td style="text-align: center">2.5</td><td style="text-align: center">3</td></tr><tr><td style="text-align: center">6</td><td style="text-align: center">3.5</td><td style="text-align: center">4</td></tr><tr><td style="text-align: center">8</td><td style="text-align: center">4.0</td><td style="text-align: center">5</td></tr><tr><td style="text-align: center">10</td><td style="text-align: center">4.5</td><td style="text-align: center">6</td></tr><tr><td style="text-align: center">12</td><td style="text-align: center">5.0</td><td style="text-align: center">7</td></tr><tr><td style="text-align: center">14</td><td style="text-align: center">5.5</td><td style="text-align: center">8</td></tr></table><p>The last column is the size of the NUFFT half-support <span>$w$</span> which ensures sufficient NUFFT accuracy. The given values assume a NUFFT oversampling factor <span>$σ = 1.5$</span> and a (backwards) Kaiser–Bessel spreading kernel, which are the default when using the <a href="#VortexPasta.BiotSavart.NonuniformFFTsBackend"><code>NonuniformFFTsBackend</code></a>. Currently, this parameter is not automatically selected by this function. In other words, knowing the required value of <span>$w$</span>, one can pass:</p><pre><code class="nohighlight hljs">backend_long = NonuniformFFTsBackend(m = HalfSupport(w))</code></pre><p>as a keyword argument to this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/autotune.jl#L13-L124">source</a></section></article><h3 id="Accessing-parameters"><a class="docs-heading-anchor" href="#Accessing-parameters">Accessing parameters</a><a id="Accessing-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-parameters" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.circulation" href="#VortexPasta.BiotSavart.circulation"><code>VortexPasta.BiotSavart.circulation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BiotSavart.circulation(p::ParamsBiotSavart) -&gt; Γ</code></pre><p>Return the circulation <code>Γ</code> associated to each vortex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/params.jl#L383-L387">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.periods" href="#VortexPasta.BiotSavart.periods"><code>VortexPasta.BiotSavart.periods</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BiotSavart.periods(p::ParamsBiotSavart) -&gt; (Lx, Ly, Lz)</code></pre><p>Return the domain periods in each direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/params.jl#L390-L394">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.domain_is_periodic" href="#VortexPasta.BiotSavart.domain_is_periodic"><code>VortexPasta.BiotSavart.domain_is_periodic</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BiotSavart.domain_is_periodic(p::ParamsBiotSavart) -&gt; Bool
BiotSavart.domain_is_periodic(Ls::NTuple) -&gt; Bool</code></pre><p>Check whether the domain is periodic.</p><p>Returns <code>true</code> if the domain is periodic in <em>all</em> directions, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/params.jl#L397-L404">source</a></section></article><h2 id="Exported-functions"><a class="docs-heading-anchor" href="#Exported-functions">Exported functions</a><a id="Exported-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.init_cache" href="#VortexPasta.BiotSavart.init_cache"><code>VortexPasta.BiotSavart.init_cache</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_cache(
    p::ParamsBiotSavart, fs::AbstractVector{&lt;:AbstractFilament};
    timer = TimerOutput(&quot;BiotSavart&quot;),
) -&gt; BiotSavartCache</code></pre><p>Initialise caches for computing Biot–Savart integrals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/cache.jl#L35-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.velocity_on_nodes!" href="#VortexPasta.BiotSavart.velocity_on_nodes!"><code>VortexPasta.BiotSavart.velocity_on_nodes!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">velocity_on_nodes!(
    vs::AbstractVector{&lt;:AbstractVector{&lt;:Vec3}},
    cache::BiotSavartCache,
    fs::AbstractVector{&lt;:AbstractFilament};
    kws...,
) -&gt; vs</code></pre><p>Compute velocity induced by vortex filaments on filament nodes.</p><p>Velocities induced by vortex filaments <code>fs</code> are written to <code>vs</code>.</p><p>This is the same as calling <a href="#VortexPasta.BiotSavart.compute_on_nodes!"><code>compute_on_nodes!</code></a> when only the velocity is needed.</p><p>Usually, <code>fs</code> is a vector containing all the vortex filaments in the system. In that case, <code>vs</code> must be a vector of vectors, which will contain the velocities of all filament nodes. The length of <code>vs[i]</code> must be equal to the number of nodes in the filament <code>fs[i]</code>.</p><p>The vector of velocities where the output will be written may be initialised using one of the following lines (all are exactly equivalent):</p><pre><code class="language-julia hljs">vs = map(similar ∘ nodes, fs)
vs = [similar(nodes(f)) for f ∈ fs]
vs = similar.(nodes.(fs))</code></pre><p>which initialise a velocity vector for each node of each filament (see also <a href="../Filaments/#VortexPasta.Filaments.nodes"><code>nodes</code></a>).</p><p>See <a href="#VortexPasta.BiotSavart.compute_on_nodes!"><code>compute_on_nodes!</code></a> for a list of accepted keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/BiotSavart.jl#L68-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.compute_on_nodes!" href="#VortexPasta.BiotSavart.compute_on_nodes!"><code>VortexPasta.BiotSavart.compute_on_nodes!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_on_nodes!(
    fields::NamedTuple{Names, NTuple{N, V}},
    cache::BiotSavartCache,
    fs::AbstractVector{&lt;:AbstractFilament};
    LIA = Val(true),
    shortrange = true,
    longrange = true,
    callback_vorticity = identity,
) where {Names, N, V &lt;: AbstractVector{&lt;:VectorOfVec}}</code></pre><p>Compute velocity and/or streamfunction on filament nodes.</p><p>The first argument contains one or more output fields to compute. It is usually of length 1 or 2, and can contain fields named <code>velocity</code> and <code>streamfunction</code>.</p><p>For example, to compute both velocity and streamfunction on the nodes of filaments <code>fs</code>:</p><pre><code class="language-julia hljs"># Initialise fields to compute (vectors of vectors)
vs = map(similar ∘ nodes, fs)  # one velocity vector per filament node
ψs = map(similar, vs)

# The first argument to `compute_on_nodes!` must have the following form.
# One can also choose to pass just one of the two fields.
fields = (;
    velocity = vs,
    streamfunction = ψs,
)

cache = BiotSavart.init_cache(...)
compute_on_nodes!(fields, cache, fs)</code></pre><p><strong>Extended help</strong></p><p><strong>Disabling local terms / computing <em>only</em> local terms</strong></p><p>One may disable computation of the locally-induced velocity and streamfunction (LIA term) by passing <code>LIA = Val(false)</code>. Conversely, one can pass <code>LIA = Val(:only)</code> to compute <em>only</em> the LIA term. This can be useful for splitting the induced filament velocities/streamfunctions onto local and non-local parts.</p><p><strong>Disabling short-range or long-range interactions</strong></p><p>It is also possible to disable the short-range or long-range component of Ewald splitting, if one only wants to compute one of the two components. To do this, pass either <code>shortrange = false</code> or <code>longrange = false</code>.</p><p>Note that the short-range component includes the local (LIA) term as well as the short-range correction term for long-range interactions. Therefore, setting <code>shortrange = false</code> disables both these terms.</p><p><strong>Accessing vorticity in Fourier space</strong></p><p>The computation of long-range quantities involves estimating the Fourier coefficients of the vorticity field associated to the vortex filaments. These coefficients are truncated to some maximum wavenumber <span>$k_{\text{max}}$</span> in each Cartesian direction. This information can be useful for other things, for instance computing energy spectra.</p><p>One can use the <code>callback_vorticity</code> argument to access the vorticity in Fourier space, before it is replaced by the coefficients of streamfunction and/or velocity. This argument should be a function <code>callback_vorticity(cache)</code> which takes a <a href="#VortexPasta.BiotSavart.LongRangeCache"><code>LongRangeCache</code></a>. The callback should not modify anything inside the cache, or otherwise the streamfunction and velocity computed by this function will likely be wrong. Moreover, one can call <a href="#VortexPasta.BiotSavart.get_longrange_field_fourier"><code>get_longrange_field_fourier</code></a> to get the vorticity field from within the callback. Of course, this callback is never be called if long-range computations are disabled.</p><p>When the callback is called, the available field is simply a Fourier-truncated vorticity, as the coarse-graining due to Ewald&#39;s method has not been applied yet.</p><p>An example of how to compute the (large-scale) kinetic energy associated to the Fourier-truncated vorticity field:</p><pre><code class="language-julia hljs">using Adapt: adapt  # useful in case FFTs are computed on the GPU

E_from_vorticity = Ref(0.0)  # &quot;global&quot; variable updated when calling compute_on_nodes!

function callback_vorticity(cache::LongRangeCache)
    (; field, wavenumbers, state,) = BiotSavart.get_longrange_field_fourier(cache)
    @assert state.quantity == :vorticity
    @assert state.smoothing_scale == 0  # unsmoothed field
    # To make things simple, we copy data to the CPU if it&#39;s on the GPU.
    wavenumbers = adapt(Array, wavenumbers)
    uhat = adapt(Array, field)::NTuple{3}  # (ωx, ωy, ωz) in Fourier space
    with_hermitian_symmetry = BiotSavart.has_real_to_complex(cache)  # this depends on the long-range backend
    @assert with_hermitian_symmetry == wavenumbers[1][end] &gt; 0
    E = 0.0
    for I ∈ CartesianIndices(uhat[1])
        k⃗ = map(getindex, wavenumbers, Tuple(I))
        kx = k⃗[1]
        factor = (!with_hermitian_symmetry || kx == 0) ? 0.5 : 1.0
        k² = sum(abs2, k⃗)
        if !iszero(k²)
            ω⃗ = (uhat[1][I], uhat[2][I], uhat[3][I])  # Fourier coefficient of the vorticity
            E += factor * sum(abs2, ω⃗) / k²
        end
    end
    E_from_vorticity[] = E  # update value of &quot;global&quot; variable
    nothing
end

compute_on_nodes!(...; callback_vorticity)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/BiotSavart.jl#L245-L351">source</a></section></article><h2 id="Other-convenience-functions"><a class="docs-heading-anchor" href="#Other-convenience-functions">Other convenience functions</a><a id="Other-convenience-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-convenience-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.kelvin_wave_period" href="#VortexPasta.BiotSavart.kelvin_wave_period"><code>VortexPasta.BiotSavart.kelvin_wave_period</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BiotSavart.kelvin_wave_period(p::ParamsBiotSavart, λ::Real) -&gt; Real</code></pre><p>Return the period <span>$T(λ)$</span> associated to Kelvin waves of wavelength <span>$λ$</span>.</p><p>This can be convenient for setting the timestep <code>dt</code> associated to a filament discretisation distance <code>δ</code>. The timestep should typically be proportional to the period of the Kelvin waves of wavelength <code>δ</code>.</p><p>The Kelvin wave period is <span>$T(λ) = 2π/ω(k)$</span> where <span>$k = 2π/λ$</span> is the wavenumber associated to <span>$λ$</span> and <span>$ω(k)$</span> is the Kelvin wave dispersion relation:</p><p class="math-container">\[ω(k) = \frac{Γ k^2}{4π} \left[
  \ln\left( \frac{2}{k a} \right) - γ + \frac{1}{2} - Δ
\right]\]</p><p>where <span>$γ ≈ 0.5772$</span> is the Euler–Mascheroni constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/params.jl#L455-L474">source</a></section></article><h2 id="Short-range-interactions"><a class="docs-heading-anchor" href="#Short-range-interactions">Short-range interactions</a><a id="Short-range-interactions-1"></a><a class="docs-heading-anchor-permalink" href="#Short-range-interactions" title="Permalink"></a></h2><h3 id="Backends"><a class="docs-heading-anchor" href="#Backends">Backends</a><a id="Backends-1"></a><a class="docs-heading-anchor-permalink" href="#Backends" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.ShortRangeBackend" href="#VortexPasta.BiotSavart.ShortRangeBackend"><code>VortexPasta.BiotSavart.ShortRangeBackend</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ShortRangeBackend</code></pre><p>Abstract type denoting the backend used for computing short-range interactions.</p><p><strong>Implemented backends</strong></p><ul><li><p><a href="#VortexPasta.BiotSavart.CellListsBackend"><code>CellListsBackend</code></a>: most efficient when the cutoff radius is much smaller than the domain size. Can only be used with periodic boundary conditions.</p></li><li><p><a href="#VortexPasta.BiotSavart.NaiveShortRangeBackend"><code>NaiveShortRangeBackend</code></a>: usually less efficient as it needs to compute distances between all pairs of locations.</p></li></ul><p><strong>Extended help</strong></p><p><strong>Implementation details</strong></p><p>A <code>BACKEND &lt;: ShortRangeBackend</code> must implement the function:</p><pre><code class="nohighlight hljs">init_cache_short(c::ParamsCommon, p::ParamsShortRange{&lt;:BACKEND}, fs::AbstractVector{&lt;:AbstractFilament}, to::TimerOutput)</code></pre><p>which should return a <a href="#VortexPasta.BiotSavart.ShortRangeCache"><code>ShortRangeCache</code></a>.</p><p>It may also implement the function <a href="#VortexPasta.BiotSavart.max_cutoff_distance"><code>max_cutoff_distance</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/types_shortrange.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.NaiveShortRangeBackend" href="#VortexPasta.BiotSavart.NaiveShortRangeBackend"><code>VortexPasta.BiotSavart.NaiveShortRangeBackend</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NaiveShortRangeBackend &lt;: ShortRangeBackend</code></pre><p>Naive computation of short-range interactions.</p><p><strong>Maximum cut-off distance</strong></p><p>In periodic domains, this backend requires a cut-off distance <span>$r_{\text{cut}}$</span> not larger than half the domain period <span>$L$</span> in each direction:</p><p class="math-container">\[r_{\text{cut}} ≤ \frac{L}{2}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/shortrange/naive.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.CellListsBackend" href="#VortexPasta.BiotSavart.CellListsBackend"><code>VortexPasta.BiotSavart.CellListsBackend</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CellListsBackend &lt;: ShortRangeBackend
CellListsBackend(nsubdiv::Int = 1)</code></pre><p>Compute short-range interactions using the cell lists algorithm.</p><p>This backend can be significantly faster than the <a href="#VortexPasta.BiotSavart.NaiveShortRangeBackend"><code>NaiveShortRangeBackend</code></a> when the cut-off distance <code>r_cut</code> is much smaller than the domain period <code>L</code> (roughly when <code>r_cut ≲ L / 10</code>).</p><p>Optionally, one can choose to subdivide each cell (of size <code>≈ r_cut</code>) onto <code>nsubdiv</code> subcells. In practice, a value of <code>2</code> or <code>3</code> can significantly improve performance compared to no subdivision (<code>1</code>).</p><p>Note that, with this backend, the cut-off distance must satisfy <code>r_cut ≤ M / (2M + 1) * L</code> where <code>M = nsubdiv</code>.</p><p>This backend does not support non-periodic domains.</p><p>See <a href="../CellLists/#VortexPasta.CellLists.PeriodicCellList"><code>PeriodicCellList</code></a> and <a href="https://en.wikipedia.org/wiki/Cell_lists">Wikipedia</a> for more details.</p><p><strong>Maximum cut-off distance</strong></p><p>The cut-off distance must safisfy the condition:</p><p class="math-container">\[r_{\text{cut}} ≤ \frac{M}{2M + 1} L\]</p><p>where <span>$M$</span> is equal to the <code>nsubdiv</code> parameter. If this is a limitation, one can use the <a href="#VortexPasta.BiotSavart.NaiveShortRangeBackend"><code>NaiveShortRangeBackend</code></a> which has a slightly larger limit, <span>$r_{\text{cut}} ≤ L/2$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/shortrange/cell_lists.jl#L5-L36">source</a></section></article><h3 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.ShortRangeCache" href="#VortexPasta.BiotSavart.ShortRangeCache"><code>VortexPasta.BiotSavart.ShortRangeCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ShortRangeCache</code></pre><p>Abstract type describing the storage of data required to compute short-range interactions.</p><p>The <a href="#VortexPasta.BiotSavart.init_cache_short"><code>init_cache_short</code></a> function returns a concrete instance of a <code>ShortRangeCache</code>.</p><p><strong>Interface</strong></p><p><strong>Fields</strong></p><p>The following fields must be included in a cache:</p><ul><li><p><code>params :: ParamsShortRange</code> parameters for short-range computations;</p></li><li><p><code>to :: TimerOutput</code> for measuring time spent on different functions.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/types_shortrange.jl#L51-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.max_cutoff_distance" href="#VortexPasta.BiotSavart.max_cutoff_distance"><code>VortexPasta.BiotSavart.max_cutoff_distance</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">max_cutoff_distance(::ShortRangeBackend, L::Real) -&gt; r
max_cutoff_distance(::ShortRangeBackend, Ls::NTuple{3, Real}) -&gt; r</code></pre><p>Return the maximum cut-off distance <code>r_cut</code> allowed by the backend for a given domain period <code>L</code>.</p><p>This is usually close to <code>L/2</code>, but the actual value can depend on implementation details of the backend. For example, the <a href="#VortexPasta.BiotSavart.CellListsBackend"><code>CellListsBackend</code></a> requires a slightly smaller distance, in the range <code>L/3 ≤ r_max &lt; L/2</code> depending on the backend parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/types_shortrange.jl#L28-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.init_cache_short" href="#VortexPasta.BiotSavart.init_cache_short"><code>VortexPasta.BiotSavart.init_cache_short</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_cache_short(
    pc::ParamsCommon, p::ParamsShortRange,
    fs::AbstractVector{&lt;:AbstractFilament},
    to::TimerOutput,
) -&gt; ShortRangeCache</code></pre><p>Initialise the cache for the short-range backend defined in <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/shortrange/shortrange.jl#L9-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.process_point_charges!" href="#VortexPasta.BiotSavart.process_point_charges!"><code>VortexPasta.BiotSavart.process_point_charges!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">process_point_charges!(c::ShortRangeCache, data::PointData)</code></pre><p>Process list of point charges.</p><p>This is useful for short-range backends like <a href="#VortexPasta.BiotSavart.CellListsBackend"><code>CellListsBackend</code></a>, which needs to</p><p>Must be called after <a href="#VortexPasta.BiotSavart.add_point_charges!"><code>add_point_charges!</code></a> and before computing any short-range quantities (using <a href="#VortexPasta.BiotSavart.add_short_range_fields!"><code>add_short_range_fields!</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/shortrange/shortrange.jl#L20-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.add_short_range_fields!" href="#VortexPasta.BiotSavart.add_short_range_fields!"><code>VortexPasta.BiotSavart.add_short_range_fields!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_short_range_fields!(
    fields::NamedTuple{Names, NTuple{N, V}},
    cache::ShortRangeCache,
    f::AbstractFilament;
    LIA = Val(true),
)</code></pre><p>Compute short-range Biot-Savart integrals.</p><p>Adds the results onto <code>fields</code>. See <a href="#VortexPasta.BiotSavart.compute_on_nodes!"><code>compute_on_nodes!</code></a> for more details.</p><p>Setting <code>LIA = Val(false)</code> allows to disable computation of the localised induction approximation (LIA) term. In that case, that term should be computed separately using <a href="#VortexPasta.BiotSavart.local_self_induced"><code>local_self_induced</code></a>.</p><p>Before calling this function, one must first call <a href="#VortexPasta.BiotSavart.add_point_charges!"><code>add_point_charges!</code></a> and then <a href="#VortexPasta.BiotSavart.process_point_charges!"><code>process_point_charges!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/shortrange/shortrange.jl#L201-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.local_self_induced_velocity" href="#VortexPasta.BiotSavart.local_self_induced_velocity"><code>VortexPasta.BiotSavart.local_self_induced_velocity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">local_self_induced_velocity(
    f::AbstractFilament, i::Int, [prefactor::Real];
    a::Real, [Γ::Real],
    Δ = 0.25, quad = nothing, fit_circle = false,
    segment_fraction = nothing,
)</code></pre><p>Compute local self-induced velocity of filament node <code>f[i]</code>.</p><p>This corresponds to the LIA term (localised induction approximation).</p><p>This is the same as <code>local_self_induced(Velocity(), f, i, [prefactor]; kwargs...)</code>. See also <a href="#VortexPasta.BiotSavart.local_self_induced"><code>local_self_induced</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/shortrange/lia.jl#L5-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.local_self_induced" href="#VortexPasta.BiotSavart.local_self_induced"><code>VortexPasta.BiotSavart.local_self_induced</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">local_self_induced(
    q::OutputField, f::AbstractFilament, i::Int, [prefactor::Real];
    a::Real, Δ::Real = 0.25, segment_fraction = nothing, quad = nothing, [Γ],
)</code></pre><p>Compute localised induction approximation (LIA) term at node <code>f[i]</code>.</p><p>Possible output fields to be passed as first argument are <code>Velocity()</code> and <code>Streamfunction()</code>.</p><p>One must pass either the circulation <code>Γ</code> as a keyword argument, or a precomputed <code>prefactor</code> which is usually equal to <code>Γ / 4π</code> (both for velocity and streamfunction).</p><p><strong>Mandatory arguments</strong></p><ul><li><p>the vortex core size <code>a</code> as a keyword argument;</p></li><li><p>either the vortex circulation <code>Γ</code> as a keyword argument, or the precomputed prefactor <code>Γ / 4π</code> as a positional argument.</p></li></ul><p><strong>Optional arguments</strong></p><ul><li><p>the optional parameter <code>Δ</code> sets the effect of the vorticity profile (see <a href="#VortexPasta.BiotSavart.ParamsBiotSavart"><code>ParamsBiotSavart</code></a> for details);</p></li><li><p>the optional parameter <code>segment_fraction</code> can be used to indicate that the LIA term should only be computed over a fraction of the segments neighbouring the node <code>f[i]</code>. In that case, it should be a real number in <span>$(0, 1]$</span> (where 1 corresponds to integrating over the full segments, which the default);</p></li><li><p>a quadrature rule can be passed via <code>quad</code>, which can improve the estimation of the LIA term and the stability of the solver (even a 1-point quadrature rule can importantly improve stability!);</p></li><li><p>if <code>quad = nothing</code>, one may set <code>fit_circle = true</code> to estimate the binormal vector by fitting a circle passing through 3 neighbouring nodes (as done in Schwarz PRB 1985), instead of using local derivatives. For now, this is only implemented for <code>q = Velocity()</code>, and it may be removed in the future.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/shortrange/lia.jl#L27-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.nearby_charges" href="#VortexPasta.BiotSavart.nearby_charges"><code>VortexPasta.BiotSavart.nearby_charges</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nearby_charges(c::ShortRangeCache, x⃗::Vec3)</code></pre><p>Return an iterator over the charges that are &quot;close&quot; to the location <code>x⃗</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/shortrange/shortrange.jl#L32-L36">source</a></section></article><h2 id="Long-range-interactions"><a class="docs-heading-anchor" href="#Long-range-interactions">Long-range interactions</a><a id="Long-range-interactions-1"></a><a class="docs-heading-anchor-permalink" href="#Long-range-interactions" title="Permalink"></a></h2><h3 id="Backends-2"><a class="docs-heading-anchor" href="#Backends-2">Backends</a><a class="docs-heading-anchor-permalink" href="#Backends-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.LongRangeBackend" href="#VortexPasta.BiotSavart.LongRangeBackend"><code>VortexPasta.BiotSavart.LongRangeBackend</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LongRangeBackend</code></pre><p>Abstract type denoting the backend to use for computing long-range interactions.</p><p><strong>Implemented backends</strong></p><ul><li><p><a href="#VortexPasta.BiotSavart.NonuniformFFTsBackend"><code>NonuniformFFTsBackend</code></a>: estimates long-range interactions via the non-uniform fast Fourier transform (NUFFT) using the <a href="https://github.com/jipolanco/NonuniformFFTs.jl">NonuniformFFTs.jl</a> package;</p></li><li><p><a href="#VortexPasta.BiotSavart.ExactSumBackend"><code>ExactSumBackend</code></a>: computes long-range interactions using exact Fourier sums. This is really inefficient and should only be used for testing.</p></li></ul><p><strong>Extended help</strong></p><p><strong>Implementation details</strong></p><p>The following functions must be implemented by a <code>BACKEND &lt;: LongRangeBackend</code>:</p><ul><li><p><code>init_cache_long_ewald(c::ParamsCommon, p::ParamsLongRange{&lt;:BACKEND}, to::TimerOutput) -&gt; LongRangeCache</code>.</p></li><li><p><a href="#VortexPasta.BiotSavart.has_real_to_complex"><code>has_real_to_complex</code></a>,</p></li><li><p><a href="#VortexPasta.BiotSavart.expected_period"><code>expected_period</code></a> (optional),</p></li><li><p><a href="#VortexPasta.BiotSavart.folding_limits"><code>folding_limits</code></a> (optional),</p></li><li><p><a href="#KernelAbstractions.get_backend"><code>KernelAbstractions.get_backend</code></a> (required for GPU-based backends).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/types_longrange.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.NonuniformFFTsBackend" href="#VortexPasta.BiotSavart.NonuniformFFTsBackend"><code>VortexPasta.BiotSavart.NonuniformFFTsBackend</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NonuniformFFTsBackend &lt;: LongRangeBackend</code></pre><p>Compute long-range interactions using the <a href="https://github.com/jipolanco/NonuniformFFTs.jl">NonuniformFFTs.jl</a> package.</p><p>This backend may be faster than other NUFFT-based backends since it allows real valued non-uniform data, meaning that we can use real-to-complex FFTs to accelerate computations.</p><p>Transforms can be performed either on the CPU (parallelised with threads, default) or on a single GPU (in principle any kind of GPU should work, but only CUDA has been tested). This must be set via the <code>device</code> argument (see below).</p><p><strong>Optional arguments</strong></p><p>The signature of <code>NonuniformFFTsBackend</code> is:</p><pre><code class="nohighlight hljs">NonuniformFFTsBackend([device = CPU()]; σ = 1.5, m = HalfSupport(4), kws...)</code></pre><p>where all arguments are passed to NonuniformFFTs.jl.</p><p><strong>Using a GPU</strong></p><p>Transforms are run on all available CPUs by default. To use a GPU, pass the corresponding <a href="https://juliagpu.github.io/KernelAbstractions.jl/stable/#Supported-backends">KernelAbstractions.jl backend</a> as the only positional argument. For example, to use a CUDA device:</p><pre><code class="nohighlight hljs">using CUDA
backend_long = NonuniformFFTsBackend(CUDABackend(); kwargs...)</code></pre><p>On AMD GPUs the following should work:</p><pre><code class="nohighlight hljs">using AMDGPU
backend_long = NonuniformFFTsBackend(ROCBackend(); kwargs...)</code></pre><p><strong>Keyword arguments</strong></p><p>Some relevant keyword arguments are:</p><ul><li><p><code>σ = 1.5</code>: upsampling factor, which must be larger than 1. Usual values are between 1.25 (smaller FFTs, less accurate) and 2.0 (larger FFTs, more accurate). Other values such as 1.5 (default) also work;</p></li><li><p><code>m = HalfSupport(4)</code>: the half-width of the NUFFT kernels. Larger means higher accuracy;</p></li><li><p><code>fftw_flags = FFTW.MEASURE</code>: flags passed to the FFTW planner (ignored on GPU devices).</p></li></ul><p>The default parameters (<code>σ = 1.5</code>, <code>m = HalfSupport(4)</code>) correspond to a relative NUFFT tolerance of <span>$∼10^{-6}$</span>.</p><p>See <a href="https://jipolanco.github.io/NonuniformFFTs.jl/stable/API/#NonuniformFFTs.PlanNUFFT">the NonuniformFFTs.jl docs</a> for a full list of possible keyword arguments.</p><p><strong>Effect of parameters on accuracy</strong></p><p>The following table roughly relates accuracy (in number of digits) and NUFFT parameters, as detailed in <a href="../../references/#Polanco2025">Polanco (2025)</a>:</p><table><tr><th style="text-align: center">Precision digits</th><th style="text-align: center">NUFFT <span>$m$</span></th><th style="text-align: center">NUFFT <span>$σ$</span></th><th style="text-align: center">Ewald <span>$β$</span></th></tr><tr><td style="text-align: center">3</td><td style="text-align: center">2</td><td style="text-align: center">1.5</td><td style="text-align: center">2.0</td></tr><tr><td style="text-align: center">4</td><td style="text-align: center">3</td><td style="text-align: center">1.5</td><td style="text-align: center">2.5</td></tr><tr><td style="text-align: center">6</td><td style="text-align: center">4</td><td style="text-align: center">1.5</td><td style="text-align: center">3.5</td></tr><tr><td style="text-align: center">8</td><td style="text-align: center">5</td><td style="text-align: center">1.5</td><td style="text-align: center">4.0</td></tr><tr><td style="text-align: center">10</td><td style="text-align: center">6</td><td style="text-align: center">1.5</td><td style="text-align: center">4.5</td></tr><tr><td style="text-align: center">12</td><td style="text-align: center">7</td><td style="text-align: center">1.5</td><td style="text-align: center">5.0</td></tr><tr><td style="text-align: center">14</td><td style="text-align: center">8</td><td style="text-align: center">1.5</td><td style="text-align: center">5.5</td></tr></table><p>The last column is the associated value of the accuracy parameter <span>$β$</span> in Ewald&#39;s method as formulated in <a href="../../references/#Polanco2025">Polanco (2025)</a>. Once one has set <span>$β$</span> and Ewald&#39;s splitting parameter <span>$α$</span> (an inverse lengthscale), the cut-offs in physical and Fourier space are <span>$r_{\text{cut}} = β / α$</span> and <span>$k_{\text{max}} = 2βα$</span>. In this formulation, <span>$β$</span> controls the method accuracy while <span>$α$</span> is tuned to maximise performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/longrange/nonuniformffts.jl#L7-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.ExactSumBackend" href="#VortexPasta.BiotSavart.ExactSumBackend"><code>VortexPasta.BiotSavart.ExactSumBackend</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExactSumBackend &lt;: LongRangeBackend</code></pre><p>Compute long-range interactions &quot;exactly&quot; (up to filament discretisation errors) using sums of Fourier series across non-uniform points.</p><p>This should only be used for testing, as it is very slow and scales very badly with the number of non-uniform points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/longrange/exact_sum.jl#L6-L14">source</a></section></article><h3 id="Accessing-long-range-fields"><a class="docs-heading-anchor" href="#Accessing-long-range-fields">Accessing long-range fields</a><a id="Accessing-long-range-fields-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-long-range-fields" title="Permalink"></a></h3><p>It may be useful to access computed fields (vorticity, velocity, ...) in Fourier space. For this, one can use the unexported <a href="#VortexPasta.BiotSavart.get_longrange_field_fourier"><code>get_longrange_field_fourier</code></a> function.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.get_longrange_field_fourier" href="#VortexPasta.BiotSavart.get_longrange_field_fourier"><code>VortexPasta.BiotSavart.get_longrange_field_fourier</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BiotSavart.get_longrange_field_fourier(cache) -&gt; NamedTuple</code></pre><p>Obtain long-range field used to compute long-range interactions.</p><p>The input <code>cache</code> can be a <a href="#VortexPasta.BiotSavart.BiotSavartCache"><code>BiotSavartCache</code></a> or a <a href="#VortexPasta.BiotSavart.LongRangeCache"><code>LongRangeCache</code></a>.</p><p>This function returns a <code>NamedTuple</code> with the fields:</p><ul><li><p><code>field</code>: a <code>Tuple</code> <code>(ux, uy, uz)</code> describing a vector field in Fourier space. Each component is a 3D matrix of complex values.</p></li><li><p><code>wavenumbers</code>: a <code>Tuple</code> <code>(kx, ky, kz)</code> with the wavenumbers associated to the grid in Fourier space.</p></li><li><p><code>state</code>: allows to know what the returned field actually represents (vorticity, velocity, ...). See <a href="#VortexPasta.BiotSavart.LongRangeCacheState"><code>LongRangeCacheState</code></a> for details.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/cache.jl#L55-L72">source</a></section></article><h3 id="Internals-2"><a class="docs-heading-anchor" href="#Internals-2">Internals</a><a class="docs-heading-anchor-permalink" href="#Internals-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.PointData" href="#VortexPasta.BiotSavart.PointData"><code>VortexPasta.BiotSavart.PointData</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PointData</code></pre><p>Stores point data (values on filaments) used to compute short-range and long-range interactions.</p><p>This includes the locations <code>s⃗</code> and charges <code>q * s⃗′</code> used to compute both short-range and long-range interactions, allowing to reuse computations. Note that locations and charges are obtained via interpolation in-between filament nodes.</p><p>This is also reused by long-range interactions to perform interpolations from Fourier to physical space (see <a href="#VortexPasta.BiotSavart.interpolate_to_physical!"><code>interpolate_to_physical!</code></a>). In that case, <code>points</code> contains the interpolation points (usually the filament nodes) and <code>charges</code> the interpolation values (usually velocities or streamfunction values).</p><p><strong>Construction</strong></p><pre><code class="nohighlight hljs">PointData(::Type{T}, ::Type{S}, ::Type{F}) -&gt; PointData</code></pre><p>where:</p><ul><li><p><code>T</code> is a float type (usually <code>Float32</code> or <code>Float64</code>).</p></li><li><p><code>S</code> is either <code>T</code> (for real-valued charges) or <code>Complex{T}</code> (for complex-valued charges). Usually <code>T</code> is fine; <code>Complex{T}</code> may be needed by specific long-range backends (such as <code>FINUFFTBackend</code>, which is no longer available).</p></li><li><p><code>F &lt;: AbstractFilament</code> is the filament type (e.g. <code>ClosedFilament{…}</code>).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/pointdata.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.LongRangeCache" href="#VortexPasta.BiotSavart.LongRangeCache"><code>VortexPasta.BiotSavart.LongRangeCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LongRangeCache</code></pre><p>Abstract type describing the storage of data required to compute long-range interactions.</p><p>The <a href="#VortexPasta.BiotSavart.init_cache_long"><code>init_cache_long</code></a> function returns a concrete instance of a <code>LongRangeCache</code> (or <code>NullLongRangeCache()</code>, if long-range computations were disabled by setting <code>α = Zero()</code>).</p><p><strong>Useful fields</strong></p><p>Most useful fields of a <code>cache::LongRangeCache</code> are in the <code>cache.common</code> field. In particular, <code>cache.common</code> contains the fields:</p><ul><li><p><code>wavenumbers_d::NTuple{3, AbstractVector}</code>: Fourier wavenumbers in each direction;</p></li><li><p><code>uhat_d::StructArray{Vec3{Complex{T}}, 3}</code>: a full vector field in Fourier space;</p></li><li><p><code>pointdata_d::PointData</code>: data associated to vector charges applied on non-uniform points. These are available in <code>pointdata_d.charges</code> and <code>pointdata_d.points</code>;</p></li></ul><p>The <code>_d</code> suffixes means that data is on the computing device associated to the long-range backend (i.e. on the GPU for GPU-based backends).</p><p><strong>Extended help</strong></p><p><strong>Implementation details</strong></p><p><strong>Fields</strong></p><p>All caches must include a <code>common &lt;: LongRangeCacheCommon</code> field which contains common definitions for all backends.</p><p><strong>Functions</strong></p><p>The following functions must be implemented by a cache:</p><ul><li><p><a href="#VortexPasta.BiotSavart.transform_to_fourier!"><code>transform_to_fourier!</code></a>,</p></li><li><p><a href="#VortexPasta.BiotSavart.interpolate_to_physical!"><code>interpolate_to_physical!</code></a>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/types_longrange.jl#L84-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.NullLongRangeCache" href="#VortexPasta.BiotSavart.NullLongRangeCache"><code>VortexPasta.BiotSavart.NullLongRangeCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NullLongRangeCache &lt;: LongRangeCache</code></pre><p>Dummy cache type returned by <a href="#VortexPasta.BiotSavart.init_cache_long"><code>init_cache_long</code></a> when long-range computations are disabled.</p><p>This is the case when the Ewald splitting parameter <span>$α$</span> is set to <code>Zero()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/longrange/longrange.jl#L113-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.LongRangeCacheState" href="#VortexPasta.BiotSavart.LongRangeCacheState"><code>VortexPasta.BiotSavart.LongRangeCacheState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LongRangeCacheState</code></pre><p>Describes the current state of the long-range fields in Fourier space.</p><p>It has two fields, which allow to know which field is currently stored and its smoothing scale (width <span>$σ$</span> of Gaussian filter):</p><ul><li><p><code>quantity::Symbol</code> (can be <code>:undef</code>, <code>:vorticity</code>, <code>:velocity</code>, <code>:streamfunction</code>)</p></li><li><p><code>smoothing_scale::Float64</code>: width <span>$σ$</span> of applied Gaussian filter. This is typically 0 (if the field has not been smoothed), but that can change if one calls <a href="#VortexPasta.BiotSavart.to_coarse_grained_vorticity!"><code>to_coarse_grained_vorticity!</code></a>.</p></li></ul><p>See <a href="#VortexPasta.BiotSavart.get_longrange_field_fourier"><code>BiotSavart.get_longrange_field_fourier</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/longrange/longrange.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.init_cache_long" href="#VortexPasta.BiotSavart.init_cache_long"><code>VortexPasta.BiotSavart.init_cache_long</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_cache_long(p::ParamsBiotSavart, pointdata::PointData, [to::TimerOutput]) -&gt; LongRangeCache</code></pre><p>Initialise the cache for the long-range backend defined in <code>p.longrange</code>.</p><p>Note that, if <code>p.α === Zero()</code>, then long-range computations are disabled and this returns a <a href="#VortexPasta.BiotSavart.NullLongRangeCache"><code>NullLongRangeCache</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/longrange/longrange.jl#L125-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.expected_period" href="#VortexPasta.BiotSavart.expected_period"><code>VortexPasta.BiotSavart.expected_period</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">expected_period(::LongRangeBackend) -&gt; Union{Nothing, Real}</code></pre><p>Domain period expected by the backend.</p><p>This is used for rescaling input coordinates to the requirements of the backend. For instance, NonuniformFFTs.jl assumes a period <span>$2π$</span>, and therefore coordinates are rescaled if the input data has a period different from <span>$2π$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/types_longrange.jl#L60-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.folding_limits" href="#VortexPasta.BiotSavart.folding_limits"><code>VortexPasta.BiotSavart.folding_limits</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">folding_limits(::LongRangeBackend) -&gt; Union{Nothing, NTuple{2, Real}}</code></pre><p>Domain limits required by the backend.</p><p>This is used for folding input coordinates so that they are within the limits expected by the backend.</p><p>Note that, if a backend defines <code>folding_limits</code>, then it must also define <a href="#VortexPasta.BiotSavart.expected_period"><code>expected_period</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/types_longrange.jl#L71-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.set_num_points!" href="#VortexPasta.BiotSavart.set_num_points!"><code>VortexPasta.BiotSavart.set_num_points!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_num_points!(data::PointData, N::Integer)</code></pre><p>Set the total number of non-uniform points that the cache must hold.</p><p>This will reallocate space to make all points fit in the cache. It will also reset the contributions of previously-added charges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/pointdata.jl#L86-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.add_point_charges!" href="#VortexPasta.BiotSavart.add_point_charges!"><code>VortexPasta.BiotSavart.add_point_charges!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_point_charges!(data::PointData, fs::AbstractVector{&lt;:AbstractFilament}, quad::StaticSizeQuadrature)
add_point_charges!(cache::LongRangeCache, fs::AbstractVector{&lt;:AbstractFilament})</code></pre><p>Add vector charges at multiple non-uniform locations.</p><p>This can be used for both short-range and long-range computations.</p><p>In the case of long-range computations, this must be done before type-1 NUFFTs, to transform from non-uniform data in physical space to uniform data in Fourier space. It must be called before <a href="#VortexPasta.BiotSavart.compute_vorticity_fourier!"><code>compute_vorticity_fourier!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/pointdata.jl#L107-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.has_real_to_complex" href="#VortexPasta.BiotSavart.has_real_to_complex"><code>VortexPasta.BiotSavart.has_real_to_complex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_real_to_complex(::LongRangeBackend) -&gt; Bool
has_real_to_complex(::ParamsLongRange) -&gt; Bool
has_real_to_complex(::LongRangeCacheCommon) -&gt; Bool
has_real_to_complex(::LongRangeCache) -&gt; Bool</code></pre><p>Check whether the backend performs real-to-complex (fast) Fourier transforms.</p><p>If <code>true</code>, it means that input non-uniform data in physical space can be real-valued, and that uniform data in Fourier space only contains half the total number of modes along the first dimension to account for Hermitian symmetry.</p><p>This function is useful in particular for:</p><ul><li>knowing which kind of non-uniform data (vorticities) one must give to the backend;</li><li>knowing how to interpret Fourier-space data, e.g. to compute Fourier spectra.</li></ul><p>Currently, this function always returns <code>true</code>. It used to return <code>false</code> for the <code>FINUFFTBackend</code>, which has been removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/types_longrange.jl#L34-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.compute_vorticity_fourier!" href="#VortexPasta.BiotSavart.compute_vorticity_fourier!"><code>VortexPasta.BiotSavart.compute_vorticity_fourier!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_vorticity_fourier!(cache::LongRangeCache)</code></pre><p>Estimate vorticity in Fourier space.</p><p>The vorticity, written to <code>cache.common.uhat_d</code>, is estimated using some kind of non-uniform Fourier transforms (depending on the chosen backend).</p><p>Note that this function doesn&#39;t perform smoothing over the vorticity using the Ewald operator.</p><p>Must be called after <a href="#VortexPasta.BiotSavart.add_point_charges!"><code>add_point_charges!</code></a>.</p><p>After calling this function, one may want to use <a href="#VortexPasta.BiotSavart.compute_streamfunction_fourier!"><code>compute_streamfunction_fourier!</code></a> and/or <a href="#VortexPasta.BiotSavart.compute_velocity_fourier!"><code>compute_velocity_fourier!</code></a> to obtain the respective fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/longrange/longrange.jl#L555-L569">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.compute_streamfunction_fourier!" href="#VortexPasta.BiotSavart.compute_streamfunction_fourier!"><code>VortexPasta.BiotSavart.compute_streamfunction_fourier!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_streamfunction_fourier!(cache::LongRangeCache)</code></pre><p>Convert Fourier-transformed vorticity field to streamfunction field in Fourier space.</p><p>This simply corresponds to inverting a Laplacian (<span>$-∇^2 \bm{ψ} = \bm{ω}$</span>), which in Fourier space is:</p><p class="math-container">\[\hat{\bm{ψ}}_{α}(\bm{k}) = \hat{\bm{ω}}(\bm{k}) / k²\]</p><p>This function should be called after <a href="#VortexPasta.BiotSavart.compute_vorticity_fourier!"><code>compute_vorticity_fourier!</code></a>. If one only needs the velocity and not the streamfunction, one can also directly call <a href="#VortexPasta.BiotSavart.compute_velocity_fourier!"><code>compute_velocity_fourier!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/longrange/longrange.jl#L186-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.compute_velocity_fourier!" href="#VortexPasta.BiotSavart.compute_velocity_fourier!"><code>VortexPasta.BiotSavart.compute_velocity_fourier!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_velocity_fourier!(cache::LongRangeCache)</code></pre><p>Convert Fourier-transformed vorticity field to velocity field in Fourier space.</p><p>If called right after <a href="#VortexPasta.BiotSavart.compute_vorticity_fourier!"><code>compute_vorticity_fourier!</code></a>, this function performs the operation:</p><p class="math-container">\[\hat{\bm{v}}_{α}(\bm{k}) = \frac{i \bm{k} × \, \hat{\bm{ω}}(\bm{k})}{k^2}.\]</p><p>Optionally, if one is also interested in the streamfunction, one can call <a href="#VortexPasta.BiotSavart.compute_streamfunction_fourier!"><code>compute_streamfunction_fourier!</code></a> <em>before</em> this function. In that case, the cache already contains the streamfunction, and only the curl operator (<span>$i \bm{k} ×$</span>) is applied by this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/longrange/longrange.jl#L288-L304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.to_coarse_grained_vorticity!" href="#VortexPasta.BiotSavart.to_coarse_grained_vorticity!"><code>VortexPasta.BiotSavart.to_coarse_grained_vorticity!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_coarse_grained_vorticity!(c::LongRangeCache, ℓ::Real) -&gt; NamedTuple</code></pre><p>Compute coarse-grained vorticity in Fourier space.</p><p>The vorticity is coarse-grained at scale <span>$ℓ$</span> using a Gaussian filter.</p><p>Ideally, for accuracy reasons, the smoothing scale <span>$ℓ$</span> should be larger than the Ewald splitting scale <span>$σ = 1 / α√2$</span>. Also note that applying this function leads to <strong>loss of small-scale information</strong>, so that one should be careful when performing additional calculations (energy spectra, ...) afterwards.</p><p>This can be useful for visualisations or physical analysis. It is <em>not</em> used to compute Biot–Savart velocities, and the scale <span>$ℓ$</span> need not be similar to the splitting lengthscale in Ewald&#39;s method.</p><p>This function also sets the <a href="#VortexPasta.BiotSavart.LongRangeCacheState"><code>LongRangeCacheState</code></a> to <code>quantity = :vorticity</code> and <code>smoothing_scale = ℓ</code>.</p><p>This function returns the same thing as <a href="#VortexPasta.BiotSavart.get_longrange_field_fourier"><code>get_longrange_field_fourier</code></a>, including the resulting coarse-grained vorticity in Fourier space.</p><p><strong>Example</strong></p><p>From a set of vortex filaments, evaluate their self-induced velocity (using <a href="#VortexPasta.BiotSavart.compute_on_nodes!"><code>compute_on_nodes!</code></a>) and then the resulting coarse-grained vorticity at their locations:</p><pre><code class="language-julia hljs"># First compute the velocity on the filament nodes.
# As an intermediate result, the velocity in Fourier space is stored in the cache.
vs = map(similar ∘ nodes, fs)  # one velocity vector per filament node
fields = (; velocity = vs,)
cache = BiotSavart.init_cache(...)
compute_on_nodes!(fields, cache, fs)

# Now compute the coarse-grained vorticity (result is stored in the cache)
ℓ = 0.1  # smoothing scale
BiotSavart.to_coarse_grained_vorticity!(cache.longrange, ℓ)

# Finally, evaluate the resulting vorticity on filament nodes
ωs_ℓ = map(similar, vs)
BiotSavart.interpolate_to_physical!(cache.longrange)       # interpolate to vortex positions (result stored in the cache)
BiotSavart.copy_long_range_output!(ωs_ℓ, cache.longrange)  # copy results from cache to output array</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/longrange/longrange.jl#L326-L370">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.interpolate_to_physical!" href="#VortexPasta.BiotSavart.interpolate_to_physical!"><code>VortexPasta.BiotSavart.interpolate_to_physical!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolate_to_physical!([callback::Function], [output::StructVector{&lt;:Vec3}], cache::LongRangeCache) -&gt; output</code></pre><p>Perform type-2 NUFFT to interpolate values in <code>cache.common.uhat_d</code> to non-uniform points in physical space.</p><p>Results are written to the <code>output</code> vector, which defaults to <code>cache.pointdata_d.charges</code>. This vector is returned by this function.</p><p><strong>Using callbacks</strong></p><p>The optional <code>callback</code> function should be a function <code>f(û, k⃗)</code> which takes:</p><ul><li><code>û::Vec3{&lt;:Complex}</code> a Fourier coefficient;</li><li><code>I::CartesianIndex{3}</code> the index of <code>û</code> on the Fourier grid.</li></ul><p>This can be used to modify the Fourier-space fields to be interpolated, but without really modifying the values in <code>uhat_d</code> (and thus the state of the cache). For example, to apply a Gaussian filter before interpolating:</p><pre><code class="language-julia hljs">σ = 0.1  # width of Gaussian filter (in physical space)
ks = BiotSavart.get_wavenumbers(cache.longrange)

callback(û::Vec3, I::CartesianIndex{3}) = let
    k⃗ = @inbounds getindex.(ks, Tuple(I))
    k² = sum(abs2, k⃗)
    û * exp(-σ^2 * k² / 2)
end

interpolate_to_physical!(callback, cache)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/longrange/longrange.jl#L401-L433">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.transform_to_fourier!" href="#VortexPasta.BiotSavart.transform_to_fourier!"><code>VortexPasta.BiotSavart.transform_to_fourier!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transform_to_fourier!(cache::LongRangeCache, prefactor::Real)</code></pre><p>Transform stored non-uniform data to Fourier space.</p><p>This usually corresponds to a type-1 NUFFT.</p><p>The <code>prefactor</code> is a real value that will be used to multiply each non-uniform value (or equivalently each uniform value in Fourier space).</p><p>Non-uniform data must be first added via <a href="#VortexPasta.BiotSavart.add_point_charges!"><code>add_point_charges!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/longrange/longrange.jl#L172-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.similar-Tuple{LongRangeCache, Tuple{Int64, Int64, Int64}}" href="#Base.similar-Tuple{LongRangeCache, Tuple{Int64, Int64, Int64}}"><code>Base.similar</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.similar(cache::LongRangeCache, Ns::Dims{3}) -&gt; LongRangeCache</code></pre><p>Create a <a href="#VortexPasta.BiotSavart.LongRangeCache"><code>LongRangeCache</code></a> similar to an existent one, but possibly holding a different amount of wavenumbers in Fourier space.</p><p>In principle, the grid resolution <code>Ns</code> can be different from the original one (<code>cache.common.params.Ns</code>). This can be useful for computing high-resolution fields in Fourier space (e.g. for extending the data to higher wavenumbers than allowed by the original cache).</p><p>For convenience, point data already in <code>cache.common.pointdata_d</code> is copied to the new cache. This means that, if one already filled the original cache using <a href="#VortexPasta.BiotSavart.add_point_charges!"><code>add_point_charges!</code></a>, then one can directly call <a href="#VortexPasta.BiotSavart.transform_to_fourier!"><code>transform_to_fourier!</code></a> with the new cache to get the vorticity field in Fourier space at the wanted resolution <code>Ns</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/longrange/longrange.jl#L145-L160">source</a></section></article><h2 id="KernelAbstractions-utils"><a class="docs-heading-anchor" href="#KernelAbstractions-utils">KernelAbstractions utils</a><a id="KernelAbstractions-utils-1"></a><a class="docs-heading-anchor-permalink" href="#KernelAbstractions-utils" title="Permalink"></a></h2><p><a href="https://github.com/JuliaGPU/KernelAbstractions.jl">KernelAbstractions.jl</a> is used to write generic code which works on CPUs and different kinds of GPUs.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.ka_generate_kernel" href="#VortexPasta.BiotSavart.ka_generate_kernel"><code>VortexPasta.BiotSavart.ka_generate_kernel</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ka_generate_kernel(kernel, backend::KA.Backend, x::AbstractArray; [workgroupsize])
ka_generate_kernel(kernel, backend::KA.Backend, ndrange::Dims; [workgroupsize])</code></pre><p>Generate statically sized KA kernel.</p><p>In this context, &quot;statically sized&quot; means that the kernel will be specifically compiled for the dimensions of the array <code>x</code>, and will be recompiled if an array of a different size is used later.</p><p>Here <code>kernel</code> is a KA kernel (a Julia function) annotated with the <code>@kernel</code> macro.</p><p>By default, the workgroupsize is determined automatically and may depend on the actual backend (CPU, GPU) and on the array dimensions <code>ndrange = size(x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/longrange/ka_utils.jl#L35-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KernelAbstractions.get_backend" href="#KernelAbstractions.get_backend"><code>KernelAbstractions.get_backend</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KernelAbstractions.get_backend(backend::LongRangeBackend) -&gt; KernelAbstractions.Backend
KernelAbstractions.get_backend(cache::LongRangeCache) -&gt; KernelAbstractions.Backend</code></pre><p>Get KernelAbstractions (KA) backend associated to a given long-range backend.</p><div class="admonition is-info" id="Note-6f3c0a37a73a0916"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-6f3c0a37a73a0916" title="Permalink"></a></header><div class="admonition-body"><p>The word &quot;backend&quot; means two different things here! For KA, it refers to the device where kernels are executed (e.g. <code>CPU</code>, <code>CUDABackend</code>, ...).</p></div></div><p>By default this returns <code>KA.CPU()</code>, meaning that things are run on the CPU using threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/longrange/ka_utils.jl#L3-L15">source</a></section></article><h2 id="Internals-3"><a class="docs-heading-anchor" href="#Internals-3">Internals</a><a class="docs-heading-anchor-permalink" href="#Internals-3" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.BiotSavartCache" href="#VortexPasta.BiotSavart.BiotSavartCache"><code>VortexPasta.BiotSavart.BiotSavartCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BiotSavartCache</code></pre><p>Includes arrays and data required for computation of Biot–Savart integrals.</p><p><strong>Fields</strong></p><ul><li><p><code>pointdata</code>: contains vector values at points in space. This is used for both short-range and long-range computations;</p></li><li><p><code>shortrange</code>: cache associated to short-range computations;</p></li><li><p><code>longrange</code>: cache associated to long-range computations. It can be <code>NullLongRangeCache()</code> in case the Ewald parameter <code>α</code> was set to <code>Zero()</code>;</p></li><li><p><code>to</code>: a <code>TimerOutput</code> instance for measuring the time spent on different functions.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/cache.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.background_vorticity_correction!" href="#VortexPasta.BiotSavart.background_vorticity_correction!"><code>VortexPasta.BiotSavart.background_vorticity_correction!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">background_vorticity_correction!(
    fields::NamedTuple, fs::AbstractVector{&lt;:AbstractFilament}, params::ParamsBiotSavart,
)</code></pre><p>Correct computed fields in case the mean filament vorticity is non-zero.</p><p>This ensures that results do not depend on the Ewald splitting parameter <span>$α$</span> when the filament &quot;charge&quot; is non-zero in a periodic domain.</p><p>In practice, as detailed below, this function only corrects the short-range streamfunction, as the velocity is not affected by the background vorticity, and long-range corrections are done implicitly in Fourier space.</p><div class="admonition is-info" id="Note-5c982417585c9ce0"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-5c982417585c9ce0" title="Permalink"></a></header><div class="admonition-body"><p>This function is automatically called by <a href="#VortexPasta.BiotSavart.compute_on_nodes!"><code>compute_on_nodes!</code></a> and should never be called manually. This documentation is only included for information purposes.</p></div></div><p><strong>Extended help</strong></p><p>The mean vorticity associated to the filaments is given by</p><p class="math-container">\[⟨ \bm{ω} ⟩ = \frac{Γ}{V} ∮_{\mathcal{C}} \mathrm{d}\bm{s},\]</p><p>where <span>$V = L^3$</span> is the periodic domain volume.</p><p>This quantity is always zero when all filaments are closed. It can be non-zero if there are infinite unclosed filaments which are not compensated by oppositely-oriented infinite filaments.</p><p>When the mean filament vorticity is non-zero, one must compensate it by adding a uniform background vorticity <span>$\bm{ω}_{0} = -⟨ \bm{ω} ⟩$</span>, so that the total circulation around the volume is zero. This should be interpreted by considering that computations are performed in a <strong>rotating reference frame</strong> with rotation rate <span>$\bm{Ω} = 2 ⟨ \bm{ω} ⟩ = -2 \bm{ω}_{0}$</span>.</p><p>In practice, in the long-range component of Ewald summation, this compensation is done implicitly by setting the zero mode <span>$\hat{\bm{\omega}}(\bm{k} = \bm{0}) = \bm{0}$</span>. As for the short-range component, only the streamfunction needs to be corrected, while the velocity is not affected by the background vorticity.</p><p>The correction to the short-range streamfunction is given by</p><p class="math-container">\[\bm{ψ}^{&lt;}_{0}
= \frac{\bm{ω}_{0}}{4π} ∫_{\mathbb{R}^3} \frac{\operatorname{erfc}(α|\bm{r}|)}{|\bm{r}|} \, \mathrm{d}^3\bm{r}
= \frac{\bm{ω}_{0}}{4 α^2}\]</p><p>Therefore, this function simply adds this short-range correction to the streamfunction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/c572f98727adde7c1f599cd4cabc534ba21284ac/src/BiotSavart/BiotSavart.jl#L157-L211">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Constants/">« Constants</a><a class="docs-footer-nextpage" href="../SyntheticFields/">SyntheticFields »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 23 July 2025 09:04">Wednesday 23 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
