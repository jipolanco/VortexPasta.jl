var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Arms, R. J. and Hama, F. R. (1965). Localized-induction concept on a curved vortex and motion of an elliptic vortex ring. Phys. Fluids 8, 553–559.\n\n\n\nArnold, A. and Holm, C. (2005). Efficient Methods to Compute Long-Range Interactions for Soft Matter Systems. In: Advanced Computer Simulation Approaches for Soft Matter Sciences II, Advances in Polymer Science, edited by Holm, C. and Kremer, K. (Springer, Berlin, Heidelberg); pp. 59–109.\n\n\n\nBaggaley, A. W. and Barenghi, C. F. (2011). Spectrum of turbulent Kelvin-waves cascade in superfluid helium. Physical Review B 83, 134509.\n\n\n\nGamet, L.; Ducros, F.; Nicoud, F. and Poinsot, T. (1999). Compact finite difference schemes on non-uniform meshes. Application to direct numerical simulations of compressible flows. International Journal for Numerical Methods in Fluids 29, 159–191.\n\n\n\nHänninen, R. and Baggaley, A. W. (2014). Vortex filament method as a tool for computational visualization of quantum turbulence. Proceedings of the National Academy of Sciences 111, 4667–4674.\n\n\n\nPolanco, J. I. (2024). Fast and Accurate Evaluation of Biot–Savart Integrals over Spatial Curves, arXiv:2406.07366 [physics].\n\n\n\nRoberts, P. H. and Donnelly, R. J. (1970). Dynamics of Vortex Rings. Physics Letters A 31, 137–138.\n\n\n\nSaffman, P. G. (1993). Vortex Dynamics (Cambridge University Press).\n\n\n\nSandu, A. (2019). A Class of Multirate Infinitesimal GARK Methods. SIAM J. Numer. Anal. 57, 2300–2327.\n\n\n\nSchwarz, K. W. (1985). Three-dimensional vortex dynamics in superfluid ^4He: Line-line and line-boundary interactions. Physical Review B 31, 5782–5804.\n\n\n\n","category":"page"},{"location":"modules/Filaments/#Filaments","page":"Filaments","title":"Filaments","text":"","category":"section"},{"location":"modules/Filaments/","page":"Filaments","title":"Filaments","text":"CurrentModule = VortexPasta.Filaments\nCollapsedDocStrings = true","category":"page"},{"location":"modules/Filaments/","page":"Filaments","title":"Filaments","text":"Filaments","category":"page"},{"location":"modules/Filaments/#VortexPasta.Filaments","page":"Filaments","title":"VortexPasta.Filaments","text":"Filaments\n\nModule for dealing with the discretisation of curves in 3D space.\n\n\n\n\n\n","category":"module"},{"location":"modules/Filaments/#Types","page":"Filaments","title":"Types","text":"","category":"section"},{"location":"modules/Filaments/","page":"Filaments","title":"Filaments","text":"AbstractFilament\nClosedFilament","category":"page"},{"location":"modules/Filaments/#VortexPasta.Filaments.AbstractFilament","page":"Filaments","title":"VortexPasta.Filaments.AbstractFilament","text":"AbstractFilament{T} <: AbstractVector{Vec3{T}}\n\nAbstract type representing a curve in 3D space.\n\nThe curve coordinates are parametrised as bms(t) with t  ℝ.\n\nThe curve is discretised by a set of nodes (or discretisation points) bms(t_i) = bms_i for i  1 2  N.\n\nSee ClosedFilament for a concrete implementation of AbstractFilament.\n\nAn AbstractFilament is treated as an AbstractVector of length N, in which each element is a discretisation point bms_i. Therefore, one can use the usual indexing notation to retrieve and to modify discretisation points. See ClosedFilament for some examples.\n\nExtended help\n\nEvaluating coordinates and derivatives\n\nDifferent ways are proposed of evaluating filament coordinates and derivatives along a filament f, depending on whether one wants values on discretisation points or in-between them.\n\nIn short, square brackets f[...] should be used to evaluate on filament nodes, while round brackets f(...) to evaluate in-between nodes.\n\nValues on discretisation points\n\nCoordinates bms_i of discretisation points can be simply obtained by indexing the filament object:\n\ns⃗ = f[i]\n\nDerivatives at discretisation points can be similarly obtained by doing:\n\ns⃗′ = f[i, Derivative(1)]\ns⃗″ = f[i, Derivative(2)]\n\n(Note that this also works with Derivative(0), in which case it's the same as f[i].)\n\nFor convenience, other geometric quantities can be evaluated in a similar way:\n\nρ⃗ = f[i, CurvatureVector()]\n\n(See GeometricQuantity for available quantities.)\n\nValues in-between discretisation points\n\nIn this case, one wants to evaluate a value in-between two discretisation points, i.e. for t  t_i t_i + 1 for some index i. Two options are proposed:\n\nif one knows the parametrisation of the filament (see knots to obtain the parametrisation knots), then one can evaluate using a value of t:\ns⃗  = f(t)\ns⃗′ = f(t, Derivative(1))\ns⃗″ = f(t, Derivative(2))\nalternatively, if one knows the index i associated to the segment of interest, then one can do\ns⃗  = f(i, ζ)\ns⃗′ = f(i, ζ, Derivative(1))\ns⃗″ = f(i, ζ, Derivative(2))\nwhere ζ must be in 0 1, and the two limits correspond to knots t_i and t_i + 1. This is convenient if one wants to evaluate, say, right in the middle between two discretisation points, in which case one would choose ζ = 0.5.\n\nFor convenience, other geometric quantities can be evaluated in a similar way:\n\nρ⃗ = f(t, CurvatureVector())\nρ⃗ = f(i, ζ, CurvatureVector())\n\nnote: Derivatives\nIn all cases, derivatives are computed with respect to the parametrisation t. In particular, in f(i, ζ, Derivative(1)), the derivative is not with respect to ζ.\n\nnote: Derivative normalisation\nSince t is a rough approximation for the arc length ξ, first derivatives almost represent the unit tangent vector to the filament, and second derivatives are a rough approximation of the local curvature vector.One should use for example UnitTangent or CurvatureVector if one wants the derivatives with respect to the arc length ξ (which are more geometrically meaningful, and guaranteed to be orthogonal to each other). There is also normalise_derivatives which can be more efficient when one already has the derivatives with respect to t.\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.ClosedFilament","page":"Filaments","title":"VortexPasta.Filaments.ClosedFilament","text":"ClosedFilament{T, D <: DiscretisationMethod} <: AbstractFilament{T}\n\nDescribes a closed curve (a loop) in 3D space.\n\nIt can also be used to represent infinite but unclosed curves described by a periodic function (such as an infinite straight line or a sinusoidal curve).\n\nClosedFilaments should be generally constructed using Filaments.init.\n\nExtended help\n\nExamples\n\nThe following examples use the CubicSplineMethod for representing filament curves, but other methods are also available.\n\nInitialise filament from a set of discretisation points:\n\njulia> f = Filaments.init(ClosedFilament, 16, CubicSplineMethod());\n\njulia> θs = range(-1, 1; length = 17)[1:16]\n-1.0:0.125:0.875\n\njulia> @. f = Vec3(cospi(θs), sinpi(θs), 0);\n\njulia> f[4]\n3-element SVector{3, Float64} with indices SOneTo(3):\n -0.3826834323650898\n -0.9238795325112867\n  0.0\n\njulia> f[5] = (f[4] + 2 * f[6]) ./ 2\n3-element SVector{3, Float64} with indices SOneTo(3):\n  0.1913417161825449\n -1.38581929876693\n  0.0\n\njulia> update_coefficients!(f);\n\nNote that update_coefficients! should be called whenever filament coordinates are changed, before doing other operations such as estimating derivatives.\n\nEstimate derivatives at discretisation points:\n\njulia> f[4, Derivative(1)]\n3-element SVector{3, Float64} with indices SOneTo(3):\n  0.9090457394297018\n -0.7273334611006509\n  0.0\n\njulia> f[4, Derivative(2)]\n3-element SVector{3, Float64} with indices SOneTo(3):\n  0.20911715113294102\n -2.09047051482799\n  0.0\n\nEstimate coordinates and derivatives in-between discretisation points:\n\njulia> f(4, 0.32)\n3-element SVector{3, Float64} with indices SOneTo(3):\n -0.16753415613203387\n -1.1324592487590195\n  0.0\n\njulia> Ẋ, Ẍ = f(4, 0.32, Derivative(1)), f(4, 0.32, Derivative(2))\n([0.8947546127964856, -0.9527970723463657, 0.0], [-0.3303413370703831, 0.17798009799460934, 0.0])\n\njulia> X′, X″ = f(4, 0.32, UnitTangent()), f(4, 0.32, CurvatureVector())\n([0.6845546705034081, -0.7289615237390588, 0.0], [-0.050762951240829336, -0.047670575508846375, 0.0])\n\nCurve parametrisation\n\nThe parametrisation knots t_i are directly obtained from the interpolation point positions. A standard choice, which is used here by default, is for the knot increments to approximate the arc length between two interpolation points:\n\nℓ_i  t_i + 1 - t_i = bms_i + 1 - bms_i\n\nwhich is a zero-th order approximation (and a lower bound) for the actual arc length between points bms_i and bms_i + 1.\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#Initialisation","page":"Filaments","title":"Initialisation","text":"","category":"section"},{"location":"modules/Filaments/","page":"Filaments","title":"Filaments","text":"Filaments.init\nFilaments.from_vector_field","category":"page"},{"location":"modules/Filaments/#VortexPasta.Filaments.init","page":"Filaments","title":"VortexPasta.Filaments.init","text":"Filaments.init(\n    ClosedFilament{T}, N::Integer, method::DiscretisationMethod;\n    offset = zero(Vec3{T}),\n    parametrisation = Filaments.default_parametrisation(method),\n    nderivs = Val(2),\n) -> ClosedFilament{T}\n\nAllocate data for a closed filament with N discretisation points.\n\nThe element type T can be omitted, in which case the default T = Float64 is used.\n\nThe optional offset keyword argument allows to define a filament with a spatial offset between points f[i] and f[i + N]. By default the offset is zero, meaning that the filament is a closed loop. This can be used for defining infinite (so not really closed) filaments living in periodic domains.\n\nPossible discretisation methods include CubicSplineMethod, QuinticSplineMethod and FiniteDiffMethod.\n\n\n\nFilaments.init(\n    ClosedFilament, points::AbstractVector{<:Vec3}, method::DiscretisationMethod;\n    kwargs...,\n)\n\nInitialise new filament with the chosen discretisation points.\n\nNote that update_coefficients! does not need to be called after using this variant (until node locations change, of course!).\n\n\n\nFilaments.init(S::Function, ClosedFilament{T}, τs::AbstractVector, method::DiscretisationMethod)\nFilaments.init(S::Function, ClosedFilament{T}, N::Integer, method::DiscretisationMethod)\n\nConstruct new filament from parametric function S(τ) 0 1  ℝ³.\n\nThe parametric function S(τ) must generate a 3D coordinate (for example as an SVector{3} or an NTuple{3}) for any τ  0 1. The curve described by S is closed if and only if S(0) = S(1). More generally, for infinite but unclosed curves, the end-to-end offset is obtained as Δ = S(1) - S(0).\n\nIn particular, one can pass functions generated by PredefinedCurves.define_curve.\n\nTwo variants of this method are provided:\n\nin the first variant, the function S is evaluated at user-provided values of τ, which should be in 0 1);\nin the second variant, one simply passes the desired number N of nodes of the resulting filament, and the function chooses an equispaced list of τ values.\n\nThe element type T can be omitted, in which case the default T = Float64 is used.\n\nSome examples are given further below (\"Initialising filament from parametric function\"). See also from_vector_field to initialise a filament from an analytical vector field.\n\n\n\nExtended help\n\nEvaluating high-order derivatives\n\nBy default the filament discretisation allows to evaluate up to the second derivative of the curve with respect to its parametrisation. This means in particular than one has access to the tangent, curvature and binormal vectors.\n\nOne may want to evaluate higher order derivatives, for example to also have access to the curve torsion (which depends on the 3rd derivative). This is only possible for some high-order discretisation methods (QuinticSplineMethod, as well as FourierMethod with the limitation that one has to evaluate on discretisation points). Moreover, one needs to explicitly pass nderivs = Val(3) (or higher) to the init function.\n\nCustomising the filament parametrisation\n\nBy default the filament is parametrised as bms(t) such that the parameter t roughly corresponds to the arc length ξ.[1] More precisely, the discrete values t_i at the discretisation points are defined from the distances between discretisation points:\n\nt_i + 1 = t_i + bms_i + 1 - bms_i quad t_1 = 0\n\nOne can use the parametrisation keyword argument to change this. This may be a function parametrisation(Xs, i) which takes the vector Xs of discretisation points and the index i associated to the start of the current segment.\n\nFor instance, to parametrise filaments according to the z increments between discretisation points, one can pass:\n\nparametrisation = (Xs, i) -> abs(Xs[i + 1].z - Xs[i].z)\n\nOne can also pass a predefined parametrisation. See AbstractParametrisation for a list of options.\n\nExamples\n\nInitialising filament from parametric function\n\nInitialise circular filament with N = 16 nodes:\n\njulia> S(t) = (cos(2π * t), sin(2π * t), 0)  # define a circular ring with period T = 1\nS (generic function with 1 method)\n\njulia> N = 16;\n\njulia> f = Filaments.init(S, ClosedFilament, N, CubicSplineMethod())\n16-element ClosedFilament{SVector{3, Float64}, CubicSplineMethod}:\n [0.9807852804032304, 0.19509032201612825, 0.0]\n [0.8314696123025452, 0.5555702330196022, 0.0]\n [0.5555702330196023, 0.8314696123025452, 0.0]\n [0.19509032201612833, 0.9807852804032304, 0.0]\n [-0.1950903220161282, 0.9807852804032304, 0.0]\n [-0.555570233019602, 0.8314696123025453, 0.0]\n [-0.8314696123025453, 0.5555702330196022, 0.0]\n [-0.9807852804032304, 0.1950903220161286, 0.0]\n [-0.9807852804032304, -0.19509032201612836, 0.0]\n [-0.8314696123025455, -0.555570233019602, 0.0]\n [-0.5555702330196022, -0.8314696123025452, 0.0]\n [-0.19509032201612866, -0.9807852804032303, 0.0]\n [0.1950903220161283, -0.9807852804032304, 0.0]\n [0.5555702330196018, -0.8314696123025455, 0.0]\n [0.8314696123025452, -0.5555702330196022, 0.0]\n [0.9807852804032303, -0.19509032201612872, 0.0]\n\nSame but choosing the locations τ:\n\njulia> τs = range(0, 1; length = N + 1)[1:N]  # make sure the location τ = 1 is *not* included!\n0.0:0.0625:0.9375\n\njulia> f = Filaments.init(S, ClosedFilament, τs, CubicSplineMethod())\n16-element ClosedFilament{SVector{3, Float64}, CubicSplineMethod}:\n [1.0, 0.0, 0.0]\n [0.9238795325112867, 0.3826834323650898, 0.0]\n [0.7071067811865476, 0.7071067811865475, 0.0]\n [0.38268343236508984, 0.9238795325112867, 0.0]\n [6.123233995736766e-17, 1.0, 0.0]\n [-0.3826834323650897, 0.9238795325112867, 0.0]\n [-0.7071067811865475, 0.7071067811865476, 0.0]\n [-0.9238795325112867, 0.3826834323650899, 0.0]\n [-1.0, 1.2246467991473532e-16, 0.0]\n [-0.9238795325112868, -0.38268343236508967, 0.0]\n [-0.7071067811865477, -0.7071067811865475, 0.0]\n [-0.38268343236509034, -0.9238795325112865, 0.0]\n [-1.8369701987210297e-16, -1.0, 0.0]\n [0.38268343236509, -0.9238795325112866, 0.0]\n [0.7071067811865474, -0.7071067811865477, 0.0]\n [0.9238795325112865, -0.3826834323650904, 0.0]\n\nUsing VortexPasta.PredefinedCurves:\n\njulia> using VortexPasta.PredefinedCurves\n\njulia> trefoil = define_curve(TrefoilKnot());\n\njulia> f = Filaments.init(trefoil, ClosedFilament, N, CubicSplineMethod())\n16-element ClosedFilament{SVector{3, Float64}, CubicSplineMethod}:\n [0.9604571867463079, -0.866973784619343, -0.5555702330196022]\n [2.4033292980421757, 0.06610274757236567, -0.9807852804032304]\n [2.679228677325119, 1.3209370977497819, -0.19509032201612828]\n [1.74615214513341, 2.042849387038702, 0.8314696123025452]\n [0.21541841567305087, 1.6526687430064453, 0.8314696123025452]\n [-1.0162894527200281, 0.20979663171057739, -0.19509032201612828]\n [-1.2921888320029713, -1.5968364770327248, -0.9807852804032304]\n [-0.5702765427140513, -2.828544345425804, -0.5555702330196022]\n [0.5702765427140513, -2.828544345425804, 0.5555702330196022]\n [1.2921888320029713, -1.5968364770327248, 0.9807852804032304]\n [1.0162894527200281, 0.20979663171057739, 0.19509032201612828]\n [-0.21541841567305087, 1.6526687430064453, -0.8314696123025452]\n [-1.74615214513341, 2.042849387038702, -0.8314696123025452]\n [-2.679228677325119, 1.3209370977497819, 0.19509032201612828]\n [-2.4033292980421757, 0.06610274757236567, 0.9807852804032304]\n [-0.9604571867463079, -0.866973784619343, 0.5555702330196022]\n\n[1]: Except for FourierMethod, which requires the parametrisation to have a   constant increment.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.from_vector_field","page":"Filaments","title":"VortexPasta.Filaments.from_vector_field","text":"Filaments.from_vector_field(\n    ClosedFilament, ωf::Function, s⃗₀, dτ, method::DiscretisationMethod;\n    max_steps = 1000, nsubsteps = 1, redistribute = true,\n) -> ClosedFilament\n\nInitialise closed filament from vector field.\n\nHere ωf is a function bmω(bmx) which takes a 3D vector x⃗ and returns a vector value ω⃗. A filament will be created such that, for each point bms on the filament, the tangent vector bms is parallel to the vector field at that point, bmω(bms). The field should be such that lines constructed this way are closed.\n\nA possible application of this function is for constructing a filament which approximates vortex lines from a vorticity field bmω(bmx), which are precisely defined in this way. In that case, if one actually knows the velocity field bmv(bmx) – such that bmω = bmnabla  bmv – and one is too lazy to analytically derive the corresponding vorticity field, one can pass ωf = Filaments.curl(vf) (see curl) where vf is a function defining the velocity field.\n\nOne may use Filaments.distance_to_field to verify the result of this function.\n\nPositional arguments\n\nωf::Function: function taking a 3D coordinate x⃗ and returning a vector value ω⃗;\ns⃗₀::Vec3: location where to start iterating.  This point is guaranteed to be in the generated filament;\ndτ::Real: approximately distance between filament nodes. Determines the number of nodes in the resulting filament. The value of dτ/nsubsteps should be small enough to converge and so that the discretised lines are properly closed (see below for details);\nmethod::DiscretisationMethod: discretisation method to use (e.g. QuinticSplineMethod()).\n\nOptional keyword arguments\n\nmax_steps::Int = 1000: maximum number of steps before we stop iterating. This is also the maximum possible length of the returned filament;\nnsubsteps::Int = 1: number of solver substeps to perform for each spatial increment dτ. Larger values may be used to improve accuracy;\nredistribute = true: if true (default), redistribute_nodes! is called at the end to make sure that nodes are approximately distributed in a uniform way along the filament.\n\nExtended help\n\nExample\n\nGenerate a single filament aligned with the Taylor–Green vorticity field.\n\nFor convenience, we work with the Taylor–Green velocity field, and the vorticity is obtained via automatic differentiation (but we could directly work with the analytical vorticity instead).\n\njulia> function taylor_green_velocity(x⃗::Vec3)\n           x, y, z = x⃗\n           Vec3(\n               cos(x) * sin(y) * cos(z),\n               -sin(x) * cos(y) * cos(z),\n               0,\n           )\n       end\ntaylor_green_velocity (generic function with 1 method)\n\njulia> ωf = Filaments.curl(taylor_green_velocity)  # vorticity field (via automatic differentiation)\n#60 (generic function with 1 method)\n\njulia> s⃗₀ = Vec3(0.1, 1.8, 0.42);  # starting point for creating the filament\n\njulia> dτ = 0.1;  # pseudo time-step (has units of length; determines line resolution)\n\njulia> nsubsteps = 4;  # this is just to ensure convergence (should be larger for larger dτ)\n\njulia> f = Filaments.from_vector_field(ClosedFilament, ωf, s⃗₀, dτ, QuinticSplineMethod(); nsubsteps);\n\njulia> summary(f)\n\"29-element ClosedFilament{SVector{3, Float64}, QuinticSplineMethod}\"\n\njulia> Filaments.distance_to_field(ωf, f)  # check that we're close to the actual vortex line\n3.9561046185765664e-5\n\nImplementation details\n\nThe filament is generated by numerically solving the ODE:\n\nfracmathrmdbms(τ)mathrmdτ = hatbmω(bms) quad bms(0) = bms_0\n\nwhere τ denotes a \"pseudo-time\" (which actually has units of a length) and hatbmω = bmω  bmω is a unitary vector aligned with the vector field. The ODE is solved numerically using a standard 4th order Runge–Kutta scheme.\n\nIn this context, the dτ argument is actually the \"timestep\" used when solving this ODE. It must be small enough so that the curve is accurately tracked.\n\nNote that the curve will be automatically closed (and the ODE stopped) if we reach an bms(τ) which is sufficiently close (closer than dτ2) to the starting point bms_0. If that never happens, we stop after we have performed max_steps solver iterations.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#Curve-representation","page":"Filaments","title":"Curve representation","text":"","category":"section"},{"location":"modules/Filaments/#Discretisation-methods","page":"Filaments","title":"Discretisation methods","text":"","category":"section"},{"location":"modules/Filaments/","page":"Filaments","title":"Filaments","text":"DiscretisationMethod\nSplineMethod\nCubicSplineMethod\nQuinticSplineMethod\nFiniteDiffMethod\nFourierMethod\ndiscretisation_method","category":"page"},{"location":"modules/Filaments/#VortexPasta.Filaments.DiscretisationMethod","page":"Filaments","title":"VortexPasta.Filaments.DiscretisationMethod","text":"DiscretisationMethod\n\nAbstract type defining a filament discretisation method.\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.SplineMethod","page":"Filaments","title":"VortexPasta.Filaments.SplineMethod","text":"SplineMethod{k} <: DiscretisationMethod\n\nRepresents parametric curves using splines of order k.\n\nA spline of order k is a piecewise polynomial with polynomial degree k - 1 in-between interpolation nodes. For instance, cubic splines correspond to k = 4. On an interpolation node, the function has continuity C^k - 2.\n\nSee also CubicSplineMethod and QuinticSplineMethod.\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.CubicSplineMethod","page":"Filaments","title":"VortexPasta.Filaments.CubicSplineMethod","text":"CubicSplineMethod <: DiscretisationMethod\n\nRepresents curves using cubic splines.\n\nThis is an alias for SplineMethod{4} (see SplineMethod).\n\nIn the case of closed curves, periodic cubic splines are used.\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.QuinticSplineMethod","page":"Filaments","title":"VortexPasta.Filaments.QuinticSplineMethod","text":"QuinticSplineMethod <: DiscretisationMethod\n\nRepresents curves using quintic splines.\n\nThis is an alias for SplineMethod{6} (see SplineMethod).\n\nA quintic spline is made of polynomials of degree 5 and has global continuity C^4.\n\nIn the case of closed curves, periodic quintic splines are used.\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.FiniteDiffMethod","page":"Filaments","title":"VortexPasta.Filaments.FiniteDiffMethod","text":"FiniteDiffMethod{M} <: DiscretisationMethod{M}\nFiniteDiffMethod([M = 2], [interpolation = HermiteInterpolation(M)])\n\nEstimation of curve derivatives at filament nodes using finite differences.\n\nFor now, only the case M = 2 (default) is implemented (4th order / 5-point finite differences), following the method used by Baggaley and Barenghi (2011) based on a paper by Gamet et al. (1999).\n\nFiniteDiffMethod also requires specifying an interpolation scheme for evaluating coordinates and derivatives in-between discretisation points. By default, Hermite interpolations of continuity C^M are used. For the case M = 2, that means quintic Hermite interpolations, which match the first two derivatives estimated by finite differences at the discretisation points.\n\nReferences\n\n(Baggaley and Barenghi, 2011) Baggaley & Barenghi, Phys. Rev. B 83, 134509 (2011)\n(Gamet et al., 1999) Gamet et al., Int. J. Numer. Meth. Fluids 29, 2 (1999)\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.FourierMethod","page":"Filaments","title":"VortexPasta.Filaments.FourierMethod","text":"FourierMethod <: DiscretisationMethod\nFourierMethod(interpolation = HermiteInterpolation(2))\n\nRepresents closed curves using Fourier series.\n\nDerivatives at nodes are estimated using FFTs. To interpolate in-between nodes, a local interpolation method (typically HermiteInterpolation) is used, which is much faster (but less accurate) than evaluating Fourier series.\n\nNote that using FFTs require the knot locations t_i to be equidistant. The default parametrisation used by this method ensures this. However, this usually works best when the distance between discretisation points is more or less constant.\n\nThis method should only be used for simple settings and for verification of filament derivatives in other methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.discretisation_method","page":"Filaments","title":"VortexPasta.Filaments.discretisation_method","text":"discretisation_method(f::AbstractFilament) -> DiscretisationMethod\n\nReturn the method used to discretise the filament based on its node locations.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#Interpolation","page":"Filaments","title":"Interpolation","text":"","category":"section"},{"location":"modules/Filaments/","page":"Filaments","title":"Filaments","text":"interpolation_method\nFilaments.required_derivatives\nFilaments.init_coefficients\nFilaments.compute_coefficients!\nFilaments.evaluate\nLocalInterpolationMethod\nHermiteInterpolation\ninterpolate","category":"page"},{"location":"modules/Filaments/#VortexPasta.Filaments.interpolation_method","page":"Filaments","title":"VortexPasta.Filaments.interpolation_method","text":"interpolation_method(m::DiscretisationMethod)\n\nReturn the interpolation method associated to a DiscretisationMethod.\n\nFor FiniteDiffMethod and FourierMethod, this is usually a HermiteInterpolation (which requires derivatives at the interpolation nodes). For SplineMethods, since splines don't rely on a separate interpolation scheme, this simply returns m (i.e. the passed SplineMethod).\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.required_derivatives","page":"Filaments","title":"VortexPasta.Filaments.required_derivatives","text":"required_derivatives(m::DiscretisationMethod) -> Int\n\nReturn the number of derivatives on interpolation nodes required by the discretisation method.\n\nThis is generally larger than 0 for methods relying on Hermite interpolations (which require derivatives on interpolation nodes). This is 0 for other methods such as SplineMethod.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.init_coefficients","page":"Filaments","title":"VortexPasta.Filaments.init_coefficients","text":"init_coefficients(method::DiscretisationMethod, ys::AbstractVector, [nderivs::Val]) -> DiscretisationCoefs\ninit_coefficients(method::DiscretisationMethod, cs::PaddedVector, cderivs::NTuple)  -> DiscretisationCoefs\n\nInitialise interpolation coefficients.\n\nIn the first case, the ys vector is interpreted as a vector of values at interpolation nodes, and it will not be modified by the function. Note that this requires the allocation of a coefficient vector. Moreover, the nderivs argument indicates the number of derivatives that one wants to be able to compute. By default, nderiv is chosen as the minimum number of derivatives required by the method (see required_derivatives).\n\nIn the second case, cs is interpreted as a vector of interpolation coefficients, and is thus stored in the returned structure. Moreover, to compute one or more derivatives, one can pass cderivs vectors which should have the same type and length as cs.\n\nnote: Hermite interpolations\nSome discretisation methods (FiniteDiffMethod, FourierMethod) require one or more derivatives to evaluate Hermite interpolations, as determined by required_derivatives.In the first variant, if one passes e.g. nderivs = Val(0), then this argument will be silently replaced by the required number of derivatives to make things work.In the second variant, things will fail if length(cderivs) < required_derivatives(method).\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.compute_coefficients!","page":"Filaments","title":"VortexPasta.Filaments.compute_coefficients!","text":"compute_coefficients!(coefs::DiscretisationCoefs, [ys::AbstractVector], ts::PaddedVector)\n\nCompute interpolation coefficients of parametric function f(t).\n\nHere ys contains values at interpolation nodes, and ts contains the values of the curve parameter t at the nodes.\n\nIf ys is not passed, then the coefs.cs vector is expected to have the values at interpolation points (which will be overwritten with the interpolation coefficients).\n\nThis should be called before evaluating an interpolation using evaluate.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.evaluate","page":"Filaments","title":"VortexPasta.Filaments.evaluate","text":"evaluate(coefs::DiscretisationCoefs, ts::PaddedVector, t::Real, [Derivative(0)]; [ileft = nothing])\nevaluate(coefs::DiscretisationCoefs, ts::PaddedVector, i::Int, ζ::Real, [Derivative(0)])\n\nEvaluate interpolation at a given location t or ζ.\n\nIn the first case, t corresponds to the global curve parametrisation. One can optionally indicate the segment index i (such that ts[i] ≤ t < ts[i + 1]) using the ileft keyword argument.\n\nIn the second case, ζ  0 1 corresponds to the local curve parametrisation, within the segment i.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.LocalInterpolationMethod","page":"Filaments","title":"VortexPasta.Filaments.LocalInterpolationMethod","text":"LocalInterpolationMethod\n\nAbstract type defining a local interpolation method for estimating curve properties (coordinates, derivatives) in-between interpolation points using local information.\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.HermiteInterpolation","page":"Filaments","title":"VortexPasta.Filaments.HermiteInterpolation","text":"HermiteInterpolation{M} <: LocalInterpolationMethod\n\nHermite interpolation of continuity C^M at interpolation points.\n\nHermite interpolations are obtained using curve derivatives up to order M.\n\nAllowed cases\n\nfor M = 0 this is simply linear interpolation (note that curvatures cannot be estimated from linear interpolations);\nfor M = 1 this is the standard Hermite interpolation (piecewise cubic polynomials, requires first derivatives at interpolation points);\nfor M = 2 this is a quintic Hermite interpolation requiring first and second derivatives at interpolation points.\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.interpolate","page":"Filaments","title":"VortexPasta.Filaments.interpolate","text":"interpolate(\n    method::LocalInterpolationMethod, derivative::Derivative, t::Number,\n    values_at_interpolation_points...,\n)\n\nInterpolate coordinates bmX(t) or their derivatives at a given location t.\n\nUnder this form, the location t must be normalised such that the interval of interest is in t  0 1. Note that input and output derivatives must also be normalised accordingly.\n\nThe values_at_interpolation_points depend on the interpolation method:\n\nfor HermiteInterpolation, one should pass the coordinates bmX and the first M derivatives at the two endpoints of the interval (t = 0 and 1).\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#Obtaining-information","page":"Filaments","title":"Obtaining information","text":"","category":"section"},{"location":"modules/Filaments/","page":"Filaments","title":"Filaments","text":"knots\nknotlims\nend_to_end_offset\nminimum\nmaximum\nminimum_node_distance\nminimum_knot_increment\nmaximum_knot_increment\nnodes\nfilament_length\nFilaments.distance_to_field","category":"page"},{"location":"modules/Filaments/#VortexPasta.Filaments.knots","page":"Filaments","title":"VortexPasta.Filaments.knots","text":"knots(f::AbstractFilament{T}) -> AbstractVector{T}\n\nReturn parametrisation knots t_i of the filament.\n\nFilaments are parametrised by bms(t) for t  0 T.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.knotlims","page":"Filaments","title":"VortexPasta.Filaments.knotlims","text":"knotlims(f::AbstractFilament) -> (t_begin, t_end)\n\nReturn limits within which the filament can be evaluated.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.end_to_end_offset","page":"Filaments","title":"VortexPasta.Filaments.end_to_end_offset","text":"end_to_end_offset(f::ClosedFilament{T}) -> Vec3{T}\n\nReturn the end-to-end offset Δ⃗ = f[end + 1] - f[begin] of a \"closed\" filament.\n\nFor actually closed filaments, the end-to-end offset is zero. However, ClosedFilament also supports the case of infinite (but unclosed) filaments, which infinitely extend along one or more Cartesian directions. The restriction imposed by ClosedFilament is that infinite filaments repeat themselves periodically, such that f[i + m * N] == f[i] + m * Δ⃗ where N is the length of the filament (i.e. the number of degrees of freedom, or the total number of independent filament nodes).\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#Base.minimum","page":"Filaments","title":"Base.minimum","text":"Base.minimum(node_distance, f::AbstractFilament) -> Real\nBase.minimum(node_distance, fs::AbstractVector{<:AbstractFilament}) -> Real\n\nReturn the minimum distance δ between neighbouring discretisation points of a filament.\n\nIf a vector of filaments is passed (variant 2), then the minimum among all filaments is returned.\n\n\n\n\n\nBase.minimum(knot_increment, f::AbstractFilament) -> Real\nBase.minimum(knot_increment, fs::AbstractVector{<:AbstractFilament}) -> Real\n\nReturn the minimum increment Δt = t_i + 1 - t_i between filament knots.\n\nThis is generally a good approximation for the minimum segment length, at least when the default ChordalParametrisation is used. If this is not the case, it is better to pass node_distance instead of knot_increment, which always returns the distance between two neighbouring nodes.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#Base.maximum","page":"Filaments","title":"Base.maximum","text":"Base.maximum(node_distance, f::AbstractFilament) -> Real\nBase.maximum(node_distance, fs::AbstractVector{<:AbstractFilament}) -> Real\n\nReturn the maximum distance δ between neighbouring discretisation points of a filament.\n\nIf a vector of filaments is passed (variant 2), then the maximum among all filaments is returned.\n\n\n\n\n\nBase.maximum(knot_increment, f::AbstractFilament) -> Real\nBase.maximum(knot_increment, fs::AbstractVector{<:AbstractFilament}) -> Real\n\nReturn the maximum increment Δt = t_i + 1 - t_i between filament knots.\n\nThis is generally a good approximation for the maximum segment length, at least when the default ChordalParametrisation is used. If this is not the case, it is better to pass node_distance instead of knot_increment, which always returns the distance between two neighbouring nodes.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.minimum_node_distance","page":"Filaments","title":"VortexPasta.Filaments.minimum_node_distance","text":"minimum_node_distance(f::AbstractFilament) -> Real\nminimum_node_distance(fs::AbstractVector{<:AbstractFilament}) -> Real\n\nReturn the minimum distance δ between neighbouring discretisation points of a filament.\n\nThis is equivalent to calling minimum(node_distance, f).\n\nSee also minimum and minimum_knot_increment.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.minimum_knot_increment","page":"Filaments","title":"VortexPasta.Filaments.minimum_knot_increment","text":"minimum_knot_increment(f::AbstractFilament) -> Real\nminimum_knot_increment(fs::AbstractVector{<:AbstractFilament}) -> Real\n\nReturn the minimum increment Δt = t_i + 1 - t_i between filament knots.\n\nThis is equivalent to calling minimum(knot_increment, f).\n\nThis is generally a good and fast approximation for the minimum segment length. However, this approximation is generally incorrect if one is using the FourierMethod discretisation method.\n\nSee also minimum, minimum_node_distance and maximum_knot_increment.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.maximum_knot_increment","page":"Filaments","title":"VortexPasta.Filaments.maximum_knot_increment","text":"maximum_knot_increment(f::AbstractFilament) -> Real\nmaximum_knot_increment(fs::AbstractVector{<:AbstractFilament}) -> Real\n\nReturn the maximum increment Δt = t_i + 1 - t_i between filament knots.\n\nThis is equivalent to calling maximum(knot_increment, f).\n\nThis is generally a good approximation for the maximum segment length. See also maximum and minimum_knot_increment.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.nodes","page":"Filaments","title":"VortexPasta.Filaments.nodes","text":"nodes(f::AbstractFilament{T}) -> AbstractVector{T}\n\nReturn the nodes (or discretisation points) bms_i of the filament.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.filament_length","page":"Filaments","title":"VortexPasta.Filaments.filament_length","text":"filament_length(f::AbstractFilament; quad = nothing) -> Real\nfilament_length(fs::AbstractVector{<:AbstractFilament}; quad = nothing) -> Real\n\nEstimate the length of one or more filaments.\n\nBy default, the filament length is estimated using a straight segment approximation, which is fast but doesn't account for the actual curve geometry in-between discretisation points, underestimating the actual length. A quadrature rule may be optionally passed using quad (e.g. quad = GaussLegendre(4)) to obtain a more accurate result.\n\nSee also segment_length, which is used by this function.\n\nRequirements\n\nIn the straight-segment implementation (quad = nothing), one needs the filaments to be closed, i.e. f[end + 1] should be set to the right value. This can be achieved either by update_coefficients! or close_filament!.\n\nIn the quadrature-based implementation (quad <: AbstractQuadrature), the interpolation coefficients must already have been computed via update_coefficients!.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.distance_to_field","page":"Filaments","title":"VortexPasta.Filaments.distance_to_field","text":"Filaments.distance_to_field(ωf::Function, f::AbstractFilament) -> Real\n\nReturn an estimate of the normalised \"distance\" between a filament and a target vector field.\n\nThis function is meant to be used to verify the result of Filaments.from_vector_field, more specifically to verify that the filament is everywhere tangent to the objective vector field.\n\nReturns 0 if the filament is perfectly tangent to the vector field at all discretisation points.\n\nSee Filaments.from_vector_field for more details.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#Modifying-filaments","page":"Filaments","title":"Modifying filaments","text":"","category":"section"},{"location":"modules/Filaments/","page":"Filaments","title":"Filaments","text":"update_coefficients!\nclose_filament!\nchange_offset\nfold_periodic!\nredistribute_nodes!\nsplit!\nmerge!","category":"page"},{"location":"modules/Filaments/#VortexPasta.Filaments.update_coefficients!","page":"Filaments","title":"VortexPasta.Filaments.update_coefficients!","text":"update_coefficients!(f::AbstractFilament; knots = nothing)\n\nCompute coefficients needed to perform inter-node interpolations and estimate derivatives.\n\nUses the current locations of the filament nodes. If nodes change, this function should be called to update the coefficients.\n\nBy default, this function also updates the parametrisation knots t_i according to the current node positions. One can override this by passing a knots vector as a keyword argument. In particular, one can pass knots = knots(f) to keep the parametrisation knots unchanged.\n\nThis function will fail if the number of filament nodes is smaller than that required by the discretisation method. For instance, closed filaments discretised using cubic splines must have at least 3 nodes.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.close_filament!","page":"Filaments","title":"VortexPasta.Filaments.close_filament!","text":"close_filament!(f::ClosedFilament) -> f\n\nSet the filamend endpoint based on its starting point and its end-to-end offset.\n\nThis sets f[end + 1] = f[begin] + Δ⃗ where Δ⃗ is the end-to-end offset of the filament (see end_to_end_offset).\n\nCalling this function is not needed if one has recently used update_coefficients!, which already closes the filaments. This function should be used as a cheaper alternative to update_coefficients!, when one only wants to close a filament (for instance to compute its length via filament_length). This function can also be used when the filament is no longer considered as \"valid\" by the chosen discretisation method, which happens when the number of nodes falls below some threshold (see check_nodes).\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.change_offset","page":"Filaments","title":"VortexPasta.Filaments.change_offset","text":"change_offset(f::ClosedFilament, offset::Vec3{<:Real}) -> f′\n\nChange spatial offset between a filament start and endpoints.\n\nSee init for more details on optional spatial offsets.\n\nThis function is allocation-free. It returns a new filament which shares the same arrays as f, and only differs in the offset. Modifying nodes of the returned filament also modifies nodes of f.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.fold_periodic!","page":"Filaments","title":"VortexPasta.Filaments.fold_periodic!","text":"fold_periodic!(Xs::AbstractVector{<:Vec3}, Ls::NTuple{3, Real}) -> Bool\n\nFold a set of coordinates onto the main unit cell.\n\nThe idea is that the filament coordinates are (mainly) in the main unit cell, given by 0 L₁  0 L₂  0 L₃, where Lᵢ is the period in each direction.\n\nThis is nice for visualisations, and might also improve performance of the folding required by long-range computations.\n\nTo avoid creating discontinuities in the filament, what this function actually does is to make sure that the average among all filament nodes is in the main unit cell.\n\nReturns true if coordinates were modified, false otherwise. In the first case, one may want to call update_coefficients! to update the curve representation.\n\n\n\n\n\nfold_periodic!(f::AbstractFilament, Ls) -> Bool\n\nFold filament nodes onto the main unit cell.\n\nReturns true if coordinates were modified, false otherwise.\n\nIf true, coefficients may need to be updated afterwards using update_coefficients!.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.redistribute_nodes!","page":"Filaments","title":"VortexPasta.Filaments.redistribute_nodes!","text":"redistribute_nodes!(f::AbstractFilament) -> f\n\nRedistribute nodes of the filament so that they are (approximately) equally spaced.\n\nMore precisely, this function repositions the filament nodes such that the knot spacing t_i + 1 - t_i is constant. In other words, the new locations satisfy f[i] = f((i - 1) * Δt) where Δt = t_N + 1  N is the knot spacing, N is the number of nodes, and the index N + 1 refers to the filament endpoint (which is equal to the starting point for a closed filament).\n\nOne does not need to call update_coefficients! after calling this function.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.split!","page":"Filaments","title":"VortexPasta.Filaments.split!","text":"split!(f::ClosedFilament, i::Int, j::Int; p⃗ = Vec3(0, 0, 0)) -> (f₁, f₂)\n\nSplit closed filament into two filaments.\n\nAssuming j > i, the resulting filaments are respectively composed of nodes f[i + 1:j] and f[(j + 1:end) ∪ (begin:i)].\n\nIn practice, a split makes sense when the nodes f[i] and f[j] - p⃗ are spatially \"close\". Here p⃗ is an optional offset which usually takes into account domain periodicity (see also find_min_distance).\n\nNote that this function modifies the filament f, which should then be discarded.\n\nOne should generally call update_coefficients! on both filaments after a split.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.merge!","page":"Filaments","title":"VortexPasta.Filaments.merge!","text":"merge!(f::ClosedFilament, g::ClosedFilament, i::Int, j::Int; p⃗ = Vec3(0, 0, 0)) -> ClosedFilament\n\nMerge two closed filaments into one.\n\nThe resulting filament is composed of nodes:\n\nf[begin:i] ∪ {g[(j + 1:end) ∪ (begin:j)] - p⃗} ∪ f[i + 1:end]\n\nHere p⃗ is an optional offset which usually takes into account domain periodicity (see also find_min_distance).\n\nThis function returns a new filament h which may share memory with f. The filament g is not modified.\n\nOne should generally call update_coefficients! on the returned filament after merging.\n\nMerging a filament with its shifted image\n\nThis function supports merging a filament f with a shifted version of itself, g = f + p⃗. For this, one should simply pass g = f and a non-zero offset p⃗.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#Curve-parametrisations","page":"Filaments","title":"Curve parametrisations","text":"","category":"section"},{"location":"modules/Filaments/","page":"Filaments","title":"Filaments","text":"AbstractParametrisation\nChordalParametrisation\nCentripetalParametrisation\nFourierParametrisation\nCustomParametrisation","category":"page"},{"location":"modules/Filaments/#VortexPasta.Filaments.AbstractParametrisation","page":"Filaments","title":"VortexPasta.Filaments.AbstractParametrisation","text":"AbstractParametrisation\n\nAbstract type representing a curve parametrisation.\n\nFor a parametric curve bms(t), the choice of the discrete knots t_i at given discrete nodes bms_i is not unique. The parametrisation determines the way the knots t_i are chosen.\n\nSome predefined parametrisations include:\n\nChordalParametrisation,\nCentripetalParametrisation,\nFourierParametrisation.\n\nMoreover, CustomParametrisation allows to define custom parametrisation functions.\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.ChordalParametrisation","page":"Filaments","title":"VortexPasta.Filaments.ChordalParametrisation","text":"ChordalParametrisation <: AbstractParametrisation\nChordalParametrisation()\n\nRepresents the chordal parametrisation.\n\nIn this case, the increment between two knots is roughly equal to the length of the segment between the knots:\n\nt_i + 1 = t_i + bms_i + 1 - bms_i\n\nThis is known as the chordal parametrisation in the context of Catmull–Rom splines.\n\nThis is the recommended (and default) parametrisation for general cases.\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.CentripetalParametrisation","page":"Filaments","title":"VortexPasta.Filaments.CentripetalParametrisation","text":"CentripetalParametrisation <: AbstractParametrisation\nCentripetalParametrisation()\n\nRepresents the centripetal parametrisation.\n\nIn this case, the increment between two knots is given by:\n\nt_i + 1 = t_i + bms_i + 1 - bms_i^12\n\nThis is known as the centripetal parametrisation in the context of Catmull–Rom splines.\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.FourierParametrisation","page":"Filaments","title":"VortexPasta.Filaments.FourierParametrisation","text":"FourierParametrisation <: AbstractParametrisation\nFourierParametrisation()\n\nCurve parametrisation adapted for Fourier series representation of curves.\n\nIn this case, the increment between two knots is constant and given by:\n\nt_i + 1 = t_i + frac2πN\n\nwhere N is the number of nodes.\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.CustomParametrisation","page":"Filaments","title":"VortexPasta.Filaments.CustomParametrisation","text":"CustomParametrisation{F <: Function} <: AbstractParametrisation\nCustomParametrisation(f::Function)\n\nAllows to define a custom curve parametrisation.\n\nHere the function f should have the signature f(Xs, i) → Δt where Xs is the vector of discretisation nodes. It must return the knot increment Δt = t_{i + 1} - t_{i}.\n\nFor instance, the ChordalParametrisation corresponds to defining\n\nf(Xs, i) = norm(Xs[i + 1] - Xs[i])\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#Other-functions","page":"Filaments","title":"Other functions","text":"","category":"section"},{"location":"modules/Filaments/","page":"Filaments","title":"Filaments","text":"Base.getindex(f::AbstractFilament, i::Int)\nBase.setindex!(f::AbstractFilament, v, i::Int)\nnormalise_derivatives\nnormalise_derivatives!\nintegrate\nfind_min_distance\ncheck_nodes\nnumber_type\nFilaments.curl","category":"page"},{"location":"modules/Filaments/#Base.getindex-Tuple{AbstractFilament, Int64}","page":"Filaments","title":"Base.getindex","text":"Base.getindex(f::AbstractFilament{T}, i::Int) -> Vec3{T}\nBase.getindex(f::AbstractFilament{T}, i::Int, ::Derivative{n}) -> Vec3{T}\nBase.getindex(f::AbstractFilament{T}, i::Int, ::GeometricQuantity)\n\nReturn coordinates of discretisation point bms_i.\n\nOne may also obtain derivatives and other geometric quantities at point bms_i by passing an optional Derivative or GeometricQuantity.\n\n\n\n\n\n","category":"method"},{"location":"modules/Filaments/#Base.setindex!-Tuple{AbstractFilament, Any, Int64}","page":"Filaments","title":"Base.setindex!","text":"Base.setindex!(f::AbstractFilament{T}, v, i::Int) -> Vec3{T}\n\nSet coordinates of discretisation point bms_i.\n\n\n\n\n\n","category":"method"},{"location":"modules/Filaments/#VortexPasta.Filaments.normalise_derivatives","page":"Filaments","title":"VortexPasta.Filaments.normalise_derivatives","text":"normalise_derivatives(ṡ::Vec3, s̈::Vec3) -> (s⃗′, s⃗″)\nnormalise_derivatives((ṡ, s̈)::NTuple)   -> (s⃗′, s⃗″)\n\nReturn derivatives with respect to the arc length ξ, from derivatives with respect to the parameter t.\n\nThe returned derivatives satisfy:\n\nbms  t is the unit tangent vector;\nbms  ρ n is the curvature vector, where n is the normal unit vector (with t  n = 0) and ρ = R^-1 is the curvature (and R the curvature radius).\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.normalise_derivatives!","page":"Filaments","title":"VortexPasta.Filaments.normalise_derivatives!","text":"normalise_derivatives!(Ẋ::AbstractVector, Ẍ::AbstractVector)\n\nNormalise vectors containing derivatives at filament locations.\n\nIf possible, prefer using normalise_derivatives, which works on a single filament location at a time.\n\nSee normalise_derivatives for more details.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.integrate","page":"Filaments","title":"VortexPasta.Filaments.integrate","text":"integrate(integrand::Function, f::AbstractFilament, i::Int, quad::AbstractQuadrature; limits = nothing)\nintegrate(integrand::Function, s::Segment, quad::AbstractQuadrature; limits = nothing)\n\nEstimate integral along a filament segment using the chosen quadrature.\n\nIntegration is performed in the segment (f[i], f[i + 1]).\n\nThe function integrand(ζ) takes the arguments f, i and ζ  0 1. The first two are a bit redundant since they're the same filament and node index passed to this function, while ζ corresponds to the position of a point within the segment. See further below for some examples.\n\nBy default, the integration is performed along the whole segment, that is, for the range ζ  0 1. It is possible to integrate over a subset of the segment, i.e. for ζ  a b with 0  a  b  1. For this, one should pass the keyword argument limits = (a, b).\n\nExamples\n\nEstimate arc length of segment i i + 1, given by ℓ = _t_i^t_i + 1 _t bmX(t)  mathrmdt:\n\nquad = GaussLegendre(4)  # quadrature rule\nℓ = integrate(f, i, quad) do f, i, ζ\n    norm(f(i, ζ, Derivative(1)))  # = |∂ₜ𝐗|\nend\n\nAlternatively:\n\nquad = GaussLegendre(4)  # quadrature rule\ns = Segment(f, i)\nℓ = integrate(s, quad) do s, ζ\n    norm(s(ζ, Derivative(1)))  # = |∂ₜ𝐗|\nend\n\n\n\n\n\nintegrate(integrand::Function, f::AbstractFilament, quad::AbstractQuadrature; limits = nothing)\n\nEstimate integral over a whole filament.\n\nThe integral is computed as the sum of the integrals over each filament segment. The given quadrature rule is applied over each segment, meaning that the total number of evaluations is given by the number of segments multiplied by the length of the quadrature rule.\n\nThe signature of the integrated function must be integrand(f::AbstractFilament, i::Int, ζ::Real), where i is the index of the segment of interest. See below for some examples.\n\nExamples\n\nEstimate the total length of a closed filament, L =  _t bmX(t)  mathrmdt:\n\nquad = GaussLegendre(4)  # quadrature rule\n\nintegrand(f, i, ζ) = norm(f(i, ζ, Derivative(1)))  # = |∂ₜ𝐗|\n\n# Here `f` is an existent filament.\nL = integrate(integrand, f, quad)\n\n# Or, more conveniently, using a `do` block to define an anonymous function.\nL = integrate(f, quad) do ff, i, ζ\n    norm(ff(i, ζ, Derivative(1)))  # = |∂ₜ𝐗|\nend\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.find_min_distance","page":"Filaments","title":"VortexPasta.Filaments.find_min_distance","text":"find_min_distance(\n    fx::AbstractFilament, fy::AbstractFilament, i::Int, j::Int;\n    periods::NTuple{3, Real} = (Infinity(), Infinity(), Infinity()),\n    maxiter = 4, rtol = 1e-2,\n)\n\nDetermine the minimum distance between filament segments.\n\nThis function estimates the minimum distance between filament segments fx[i:i+1] and fy[j:j+1] via an iterative (Newton–Raphson) method.\n\nThe filaments fx and fy may be the same filament.\n\nReturns\n\nReturns a NamedTuple with the following fields:\n\nζx, ζy: optimal locations in 0 1 within each segment;\nx⃗, y⃗: optimal locations within each segment;\np⃗: periodic offset (each component is a multiple of the domain period along that direction);\nd⃗: minimum distance vector, d⃗ = x⃗ - y⃗ + p⃗.\n\nOptional keyword arguments\n\nperiods: the period of the spatial domain. This should be given if one wants to take into account periodic images of the filaments;\nmaxiter = 4: maximum number of iterations of the Newton method;\nrtol = 1e-2: relative tolerance for stopping the iterations. By default it's not very small since in general we don't need to be very precise.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.check_nodes","page":"Filaments","title":"VortexPasta.Filaments.check_nodes","text":"check_nodes(Bool, f::AbstractFilament) -> Bool\ncheck_nodes(f::AbstractFilament)\n\nCheck whether current filament nodes are compatible with the filament discretisation method.\n\nIn its first form, this function returns false in case of incompatibility, while it throws an error in its second form.\n\nFor now, the only requirement is that the number of nodes must be larger than some small value. In particular, one can't have a closed filament with less than 3 nodes (but the specific discretisation method might impose some other small value).\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.number_type","page":"Filaments","title":"VortexPasta.Filaments.number_type","text":"number_type(x) -> Type{<:Number}\n\nObtain the number type associated to a container x.\n\nThis is expected to return a concrete type T <: Number.\n\nThis function can be useful when the actual number type is hidden behind many nested array types.\n\nSome examples:\n\nif x is a single AbstractFilament{T}, this returns T;\nif x is a vector or tuple of AbstractFilament{T}, this also returns T; \nif x is a vector of vectors of SVector{3, T}, this returns T.\n\nNote that, in the last two cases, this corresponds to eltype(eltype(eltype(x))), which is less readable and prone to errors.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.curl","page":"Filaments","title":"VortexPasta.Filaments.curl","text":"Filaments.curl(vf::Function) -> Function\nFilaments.curl(vf::Function, x⃗::Vec3) -> Vec3\n\nReturn curl of a vector-valued field, bmω(bmx) = bm  bmv(bmx).\n\nHere vf is a function bmv(bmx) which takes a 3D vector x⃗ and returns a vector value v⃗.\n\nThe curl of vf is obtained via automatic differentiation using ForwardDiff.jl.\n\nThe first variant returns a function which can be then evaluated at any x⃗. The second variant directly evaluates the curl at some x⃗.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#Refinement","page":"Filaments","title":"Refinement","text":"","category":"section"},{"location":"modules/Filaments/","page":"Filaments","title":"Filaments","text":"RefinementCriterion\nNoRefinement\nRefineBasedOnSegmentLength\nRefineBasedOnCurvature\nrefine!\ninsert_node!\nremove_node!\nupdate_after_changing_nodes!","category":"page"},{"location":"modules/Filaments/#VortexPasta.Filaments.RefinementCriterion","page":"Filaments","title":"VortexPasta.Filaments.RefinementCriterion","text":"RefinementCriterion\n\nAbstract type describing a curve refinement criterion.\n\nImplemented refinement criteria are:\n\nNoRefinement: disables refinement;\nRefineBasedOnSegmentLength: enforces a minimum and maximum distance between neighbouring filament nodes;\nRefineBasedOnCurvature: inserts more nodes on highly-curved filament segments.\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.NoRefinement","page":"Filaments","title":"VortexPasta.Filaments.NoRefinement","text":"NoRefinement <: RefinementCriterion\nNoRefinement()\n\nUsed to disable filament refinement.\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.RefineBasedOnSegmentLength","page":"Filaments","title":"VortexPasta.Filaments.RefineBasedOnSegmentLength","text":"RefineBasedOnSegmentLength <: RefinementCriterion\nRefineBasedOnSegmentLength(ℓ_min, ℓ_max = 2 * ℓ_min)\n\nRefinement criterion imposing a minimum segment length.\n\nThis refinement criterion imposes neighbouring filament nodes to be at a distance ℓ  ℓ_min ℓ_max. This means that:\n\nnodes are inserted if the distance between two nodes is ℓ  ℓ_max. The insertion is done at an intermediate position using the functional representation of the filament (e.g. splines or Hermite interpolation);\nnodes are removed if the distance between two nodes is ℓ  ℓ_min. For a filament which is strongly curved at that point, this means that local information is lost and that the filament is smoothed.\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.RefineBasedOnCurvature","page":"Filaments","title":"VortexPasta.Filaments.RefineBasedOnCurvature","text":"RefineBasedOnCurvature <: RefinementCriterion\nRefineBasedOnCurvature(ρℓ_max::Real, ρℓ_min = ρℓ_max / 2.5; ℓ_min = 0.0, ℓ_max = Inf)\n\nCurvature-based refinement criterion.\n\nNode insertion\n\nAccording to this criterion, a filament is locally refined if:\n\nρ leftbmX_i + 1 - bmX_iright  (ρℓ)_max\n\nwhere ρ is some estimation of the curvature of segment i i + 1.\n\nFor splines, this uses a classical knot insertion algorithm which preserves the shape of the curve.\n\nNode removal\n\nSimilarly, filaments nodes are removed based on the value of ρℓ_min. This value should be less than ρℓ_max / 2 to avoid alternatively adding and removing nodes when repeatedly calling refine!.\n\nFor safety, two adjacent nodes will never be removed in a single call to refine!.\n\nNote that, when filaments are nearly straight, this may lead to the removal of most nodes. To limit this, set the keyword argument ℓ_max to some finite value determining the maximum length of a segment. Similarly, the keyword argument ℓ_min sets a lower limit for the distance between neighbouring nodes.\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.refine!","page":"Filaments","title":"VortexPasta.Filaments.refine!","text":"refine!(f::AbstractFilament, crit::RefinementCriterion) -> (Int, Int)\n\nRefine the filament according to a given criterion.\n\nMore precisely, this function can add and remove discretisation points according to the chosen refinement criterion.\n\nReturns the number of added and removed nodes.\n\nExample usage:\n\ncrit = RefineBasedOnCurvature(0.5)\nrefine!(f, crit)\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.insert_node!","page":"Filaments","title":"VortexPasta.Filaments.insert_node!","text":"insert_node!(f::AbstractFilament, i::Integer, [ζ = 0.5]) -> Vec3\n\nInsert node in-between locations f[i] and f[i + 1].\n\nThe optional argument ζ ∈ [0, 1] corresponds to the relative location of the new node within the segment. By default it is set to ζ = 0.5, which corresponds to an estimation of the middle of the segment.\n\nNote that update_after_changing_nodes! must be called after inserting one or more nodes.\n\nSee also remove_node!.\n\nReturns the inserted node.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.remove_node!","page":"Filaments","title":"VortexPasta.Filaments.remove_node!","text":"remove_node!(f::AbstractFilament, i::Integer) -> Vec3\n\nRemove node at location f[i].\n\nNote that update_after_changing_nodes! must be called after removing one or more nodes.\n\nSee also insert_node!.\n\nReturns the removed node.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.update_after_changing_nodes!","page":"Filaments","title":"VortexPasta.Filaments.update_after_changing_nodes!","text":"update_after_changing_nodes!(f::AbstractFilament)\n\nUpdate filament fields after changing nodes.\n\nDepending on the filament discretisation method, this can recompute derivatives, knots or discretisation coefficients.\n\nShould be called after inserting or removing filament nodes. See insert_node! and remove_node!.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#Geometric-quantities","page":"Filaments","title":"Geometric quantities","text":"","category":"section"},{"location":"modules/Filaments/","page":"Filaments","title":"Filaments","text":"The following types are provided as a convenient way of evaluating scalar and vector quantities of interest along filaments.","category":"page"},{"location":"modules/Filaments/","page":"Filaments","title":"Filaments","text":"GeometricQuantity\nUnitTangent\nCurvatureVector\nCurvatureScalar\nCurvatureBinormal\nTorsionScalar","category":"page"},{"location":"modules/Filaments/#VortexPasta.Filaments.GeometricQuantity","page":"Filaments","title":"VortexPasta.Filaments.GeometricQuantity","text":"GeometricQuantity\n\nAbstract type defining a geometric quantity defined for a filament.\n\nSome available geometric quantities include:\n\nUnitTangent,\nCurvatureVector,\nCurvatureScalar,\nCurvatureBinormal,\nTorsionScalar.\n\nEvaluating geometric quantities works in the same way as evaluating derivatives.\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.UnitTangent","page":"Filaments","title":"VortexPasta.Filaments.UnitTangent","text":"UnitTangent <: GeometricQuantity\n\nRepresents the unit tangent vector bmT at a filament location.\n\nIn terms of an arbitrary parametrisation bms(t) (where t is in general different from the arc length ξ), the unit tangent vector is\n\nbmT = fracbmsbms\n\nwhere derivatives are with respect to the parameter t.\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.CurvatureVector","page":"Filaments","title":"VortexPasta.Filaments.CurvatureVector","text":"CurvatureVector <: GeometricQuantity\n\nRepresents the curvature vector associated to a filament.\n\nIn terms of an arbitrary parametrisation bms(t) (where t is in general different from the arc length ξ), the curvature vector is\n\nbmρ\n= fracbms^2 bms - (bms  bms)  bmsbms^4\n= fracbms  (bms  bms)bms^4\n\nwhere derivatives are with respect to the parameter t.\n\nThe curvature vector can be written as bmρ = ρ bmN where bmN is the unit normal vector and ρ the scalar curvature (the inverse of the curvature radius).\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.CurvatureScalar","page":"Filaments","title":"VortexPasta.Filaments.CurvatureScalar","text":"CurvatureScalar <: GeometricQuantity\n\nRepresents the scalar curvature associated to a filament.\n\nThis is simply the norm of CurvatureVector. It is explicitly given by\n\nρ = fracbms  bmsbms^3\n\nwhere derivatives are with respect to the arbitrary parametrisation bms(t).\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.CurvatureBinormal","page":"Filaments","title":"VortexPasta.Filaments.CurvatureBinormal","text":"CurvatureBinormal <: GeometricQuantity\n\nRepresents the scaled binormal vector associated to a filament.\n\nThe scaled binormal vector is defined as bmb = bmT  ρ = ρ  (bmT  bmN) = ρ bmB, where bmB is the (unit) binormal vector and ρ is the scalar curvature.\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.TorsionScalar","page":"Filaments","title":"VortexPasta.Filaments.TorsionScalar","text":"TorsionScalar <: GeometricQuantity\n\nTorsion of a filament.\n\nThe torsion τ describes the variation of the binormal vector along the curve.\n\nIt can be obtained as\n\nτ = frac(bms  bms)  bmsbms  bms^2\n\nwhere derivatives are with respect to an arbitrary curve parametrisation.\n\nnote: Note\nBecause it is obtained from third derivatives, estimating the torsion requires a high-order filament discretisation scheme such as QuinticSplineMethod.\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#Segments","page":"Filaments","title":"Segments","text":"","category":"section"},{"location":"modules/Filaments/#Segment-iterators","page":"Filaments","title":"Segment iterators","text":"","category":"section"},{"location":"modules/Filaments/","page":"Filaments","title":"Filaments","text":"SegmentIterator\nsegments\nlength(::SegmentIterator)\neachindex(::SegmentIterator)","category":"page"},{"location":"modules/Filaments/#VortexPasta.Filaments.SegmentIterator","page":"Filaments","title":"VortexPasta.Filaments.SegmentIterator","text":"SegmentIterator{Filament <: AbstractFilament}\n\nConvenience type allowing to iterate over the segments of a filament.\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.segments","page":"Filaments","title":"VortexPasta.Filaments.segments","text":"segments(f::AbstractFilament) -> SegmentIterator(f)\n\nCreate a SegmentIterator object for iterating over the segments of a filament.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#Base.length-Tuple{VortexPasta.Filaments.SegmentIterator}","page":"Filaments","title":"Base.length","text":"Base.length(s::SegmentIterator{<:AbstractFilament}) -> Int\n\nReturn the number of segments in a filament.\n\n\n\n\n\n","category":"method"},{"location":"modules/Filaments/#Base.eachindex-Tuple{VortexPasta.Filaments.SegmentIterator}","page":"Filaments","title":"Base.eachindex","text":"Base.eachindex(s::SegmentIterator{<:AbstractFilament}) -> AbstractRange\n\nReturn the indices associated to the segments of a filament.\n\n\n\n\n\n","category":"method"},{"location":"modules/Filaments/#Single-segments","page":"Filaments","title":"Single segments","text":"","category":"section"},{"location":"modules/Filaments/","page":"Filaments","title":"Filaments","text":"Segment\nmidpoint\nFilaments.segment_length","category":"page"},{"location":"modules/Filaments/#VortexPasta.Filaments.Segment","page":"Filaments","title":"VortexPasta.Filaments.Segment","text":"Segment{<:Filament}\nSegment(f::AbstractFilament, i::Integer)\n\nRepresents a single filament segment.\n\nThe segment goes from nodes f[i] to f[i + 1].\n\n\n\n\n\n","category":"type"},{"location":"modules/Filaments/#VortexPasta.Filaments.midpoint","page":"Filaments","title":"VortexPasta.Filaments.midpoint","text":"midpoint(s::Segment) -> Vec3\n\nReturn an estimation of the segment midpoint (prioritising performance over accuracy).\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.segment_length","page":"Filaments","title":"VortexPasta.Filaments.segment_length","text":"Filaments.segment_length(s::Segment; quad = nothing)\n\nEstimate length of a filament segment.\n\nOne may pass a quadrature rule as quad for better accuracy. Otherwise, if quad = nothing, this simply returns the straight distance between the two segment extremities.\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#Plotting","page":"Filaments","title":"Plotting","text":"","category":"section"},{"location":"modules/Filaments/","page":"Filaments","title":"Filaments","text":"filamentplot!\nfilamentplot","category":"page"},{"location":"modules/Filaments/#VortexPasta.Filaments.filamentplot!","page":"Filaments","title":"VortexPasta.Filaments.filamentplot!","text":"filamentplot!([ax,] f::AbstractFilament, [velocities]; kws...)\nMakieCore.plot!(ax, f::AbstractFilament, [velocities]; kws...)\n\nPlot filament onto existent 3D axis.\n\nThe first argument should typically be an Axis3 or an LScene.\n\nExample usage:\n\nusing GLMakie\nfig = Figure()\nax = Axis3(fig[1, 1])\nplot!(ax, f)  # f is a filament\n\nOptional arguments and their defaults\n\nrefinement::Int = 1: level of refinement of the curves (must be ≥ 1)\nperiods = (nothing, nothing, nothing). This can be a tuple of values representing the domain period, for instance (2π, 2π, 2π). In that case, filaments will be \"broken\" when they exit the main unit cell, so that all vortex elements are within the cell.\ncolor = :black\nlinewidth = 1.5f0\nlinestyle = :solid\nmarkercolor = nothing (nothing → same as color)\nmarker = :circle\nmarkersize = 10.0f0\ncolormap = :viridis\ncolorrange = MakieCore.Automatic()\n\nArrow arguments\n\nThe following are used when plotting arrows (tangents, curvatures, velocities, …):\n\narrowscale = 1.0f0 allows to scale vectors (controls their length). Corresponds to lengthscale in Makie.arrows;\narrowsize = MakieCore.Automatic() controls the head size. It has the same name in Makie.arrows. It should be a tuple (sx, sy, sz), where the first 2 set the width of the cone, and sz its height;\narrowwidth = MakieCore.Automatic() sets the linewidth of the arrow. Corresponds to linewidth in Makie.arrows.\n\nSee also the Makie docs on arrows.\n\nPlotting tangent and curvature vectors\n\nTangent and curvature vectors can be optionally plotted via the tangents and curvatures arguments. A single vector will be plotted for each filament segments. By default, vectors are evaluated at filament nodes, but one can also evaluate them in-between nodes using the vectorpos argument.\n\ntangents::Bool = false: plot unit tangent vectors.\ncurvatures::Bool = false: plot curvature vectors. Note that the magnitude is the local curvature ρ = 1  R, where R is the curvature radius.\ntangentcolor = nothing\ncurvaturecolor = nothing\nvectorpos = 0.0: relative vector positions within each segment. Must be in 0 1.\n\nPlotting velocities of filament nodes\n\nSimilarly, it is possible to plot vector quantities attached to filament nodes, such as filament velocities. For this pass a vector of velocities as a positional argument after the filament f.\n\nAssociated keyword arguments:\n\nvelocitycolor = nothing colour of velocity vectors\n\n\n\n\n\n","category":"function"},{"location":"modules/Filaments/#VortexPasta.Filaments.filamentplot","page":"Filaments","title":"VortexPasta.Filaments.filamentplot","text":"filamentplot(f::AbstractFilament, [velocities]; kws...)\nMakieCore.plot(f::AbstractFilament, [velocities]; kws...)\n\nPlot a filament using Makie.jl.\n\nExample usage:\n\nusing GLMakie\nplot(f; refinement = 4)  # f is a filament\n\nSee filamentplot! for details and for optional keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"modules/FindNearbySegments/#FindNearbySegments","page":"FindNearbySegments","title":"FindNearbySegments","text":"","category":"section"},{"location":"modules/FindNearbySegments/","page":"FindNearbySegments","title":"FindNearbySegments","text":"CurrentModule = VortexPasta.FindNearbySegments\nCollapsedDocStrings = true","category":"page"},{"location":"modules/FindNearbySegments/","page":"FindNearbySegments","title":"FindNearbySegments","text":"FindNearbySegments","category":"page"},{"location":"modules/FindNearbySegments/#VortexPasta.FindNearbySegments","page":"FindNearbySegments","title":"VortexPasta.FindNearbySegments","text":"FindNearbySegments\n\nA module for finding pairs of nearby filament segments.\n\nThis is a common operation, used for instance for:\n\ncomputing short-range Biot-Savart interactions between filament segments;\ndetecting vortex reconnection candidates.\n\n\n\n\n\n","category":"module"},{"location":"modules/FindNearbySegments/#Backends","page":"FindNearbySegments","title":"Backends","text":"","category":"section"},{"location":"modules/FindNearbySegments/","page":"FindNearbySegments","title":"FindNearbySegments","text":"NaiveSegmentFinder\nCellListSegmentFinder","category":"page"},{"location":"modules/FindNearbySegments/#VortexPasta.FindNearbySegments.NaiveSegmentFinder","page":"FindNearbySegments","title":"VortexPasta.FindNearbySegments.NaiveSegmentFinder","text":"NaiveSegmentFinder <: NearbySegmentFinder\nNaiveSegmentFinder(fs::AbstractVector{<:AbstractFilament})\n\nInitialise nearby segment finder based on a naive searching method.\n\nWhen using this segment finder, nearby_segments iterates through all segments in all filaments fs, performing no filtering at all. One should manually use segment_is_close to filter the returned segments while iterating.\n\n\n\n\n\n","category":"type"},{"location":"modules/FindNearbySegments/#VortexPasta.FindNearbySegments.CellListSegmentFinder","page":"FindNearbySegments","title":"VortexPasta.FindNearbySegments.CellListSegmentFinder","text":"CellListSegmentFinder <: NearbySegmentFinder\nCellListSegmentFinder(\n    fs::AbstractVector{<:AbstractFilament},\n    r_cut::Real,\n    Ls::NTuple{3, Real};\n    nsubdiv = Val(1),\n)\n\nInitialise nearby segment finder based on cell lists algorithm.\n\nOnly supports fully periodic domains.\n\nSee the CellLists module for more details.\n\nMandatory arguments\n\nfs: vector of filaments;\nr_cut::Real: cut-off distance;\nLs::NTuple{3, Real}: domain period in each direction. Note that this backend doesn't support non-periodic (Infinity) directions.\n\nOptional keyword arguments\n\nnsubdiv = Val(M): number of cell lists subdivisions. Here M must be a positive integer (M = 1 means no subdivisions). See PeriodicCellList for details.\n\n\n\n\n\n","category":"type"},{"location":"modules/FindNearbySegments/#Functions","page":"FindNearbySegments","title":"Functions","text":"","category":"section"},{"location":"modules/FindNearbySegments/","page":"FindNearbySegments","title":"FindNearbySegments","text":"set_filaments!\nnearby_segments\nFindNearbySegments.segment_is_close","category":"page"},{"location":"modules/FindNearbySegments/#VortexPasta.FindNearbySegments.set_filaments!","page":"FindNearbySegments","title":"VortexPasta.FindNearbySegments.set_filaments!","text":"set_filaments!(c::NearbySegmentFinder, fs::AbstractVector{<:AbstractFilament})\n\nStore (and optionally process) the list of filaments.\n\nThis must be called to set the filament list before using nearby_segments.\n\n\n\n\n\n","category":"function"},{"location":"modules/FindNearbySegments/#VortexPasta.FindNearbySegments.nearby_segments","page":"FindNearbySegments","title":"VortexPasta.FindNearbySegments.nearby_segments","text":"nearby_segments(c::NearbySegmentFinder, x⃗::Vec3)\n\nReturn an iterator over the segments that are \"close\" to the location x⃗.\n\nA segment is considered to be close to x⃗ if the minimum[mindist] distance between x⃗ and the segment midpoint is smaller than the cutoff distance r_textcut.\n\nTypical usage:\n\nx⃗ = Vec3(0.1, 0.3, 0.2)\nfor segment ∈ nearby_segments(c, x⃗)\n    # Get the filament `f` and the index `i` of the segment within the filament.\n    # The segment is between the filament nodes `f[i]` and `f[i + 1]`.\n    (; f, i,) = segment\n    # Do something with the segment...\nend\n\n[mindist]: When periodicity is enabled, the relevant distance is the minimum distance         between the two points, after considering all their periodic images.\n\n\n\n\n\n","category":"function"},{"location":"modules/FindNearbySegments/#VortexPasta.FindNearbySegments.segment_is_close","page":"FindNearbySegments","title":"VortexPasta.FindNearbySegments.segment_is_close","text":"segment_is_close(s::Segment, x⃗, r_cut::Real, r²_cut::Real, Ls, Lhs) -> Bool\n\nDetermine whether segment s is close to the point x⃗.\n\nHere r_cut is the critical distance below which s and x⃗ will be considered to be \"close\", and r²_cut = r_cut^2 is its squared value.\n\nMoreover, Ls = (Lx, Ly, Lz) contains the domain period along each dimension (components can be Infinity() for infinite non-periodic domains), and Lhs = (Lx/2, Ly/2, Lz/2) contains half the domain periods.\n\n\n\n\n\n","category":"function"},{"location":"modules/PredefinedCurves/#PredefinedCurves","page":"PredefinedCurves","title":"PredefinedCurves","text":"","category":"section"},{"location":"modules/PredefinedCurves/","page":"PredefinedCurves","title":"PredefinedCurves","text":"CurrentModule = VortexPasta.PredefinedCurves\nCollapsedDocStrings = true","category":"page"},{"location":"modules/PredefinedCurves/","page":"PredefinedCurves","title":"PredefinedCurves","text":"PredefinedCurves","category":"page"},{"location":"modules/PredefinedCurves/#VortexPasta.PredefinedCurves","page":"PredefinedCurves","title":"VortexPasta.PredefinedCurves","text":"PredefinedCurves\n\nModule defining some commonly used parametric curves.\n\n\n\n\n\n","category":"module"},{"location":"modules/PredefinedCurves/#Exported-curves","page":"PredefinedCurves","title":"Exported curves","text":"","category":"section"},{"location":"modules/PredefinedCurves/","page":"PredefinedCurves","title":"PredefinedCurves","text":"Ring\nTrefoilKnot\nLemniscate\nPeriodicLine","category":"page"},{"location":"modules/PredefinedCurves/#VortexPasta.PredefinedCurves.Ring","page":"PredefinedCurves","title":"VortexPasta.PredefinedCurves.Ring","text":"Ring(; r = Returns(0), z = Returns(0))\n\nDescribes a circular ring in 3D space.\n\nBy default, the ring has radius R = 1, it is defined on the XY plane, and its centre is located at (0, 0, 0).\n\nThe circular ring can be optionally perturbed in the radial and orthogonal (Z) directions using user-defined functions r(t) and z(t) respectively. These functions must be periodic with period 1. For example, one can pass r(t) = 0.1 * cos(2πmt) for a mode m sinusoidal perturbation (associated to a wavelength λ = 2πRm) whose amplitude is 10% of the ring radius.\n\nMoreover, the geometry can be modified via the optional transform and translate arguments of the define_curve function.\n\nDefinition\n\nbeginaligned\n    x(t) = (1 + r(t))  cos(2πt) \n    y(t) = (1 + r(t))  sin(2πt) \n    z(t) = z(t)\nendaligned\n\nfor t  0 1.\n\nExamples\n\nDefine a circular ring of radius 2:\n\njulia> p = Ring();\n\njulia> S = define_curve(p; scale = 2);  # scale the curve by 2 (to get radius = 2)\n\njulia> ts = range(0, 1; length = 16 + 1);\n\njulia> S.(ts)\n17-element Vector{SVector{3, Float64}}:\n [2.0, 0.0, 0.0]\n [1.8477590650225735, 0.7653668647301796, 0.0]\n [1.4142135623730951, 1.414213562373095, 0.0]\n [0.7653668647301796, 1.8477590650225735, 0.0]\n [0.0, 2.0, 0.0]\n [-0.7653668647301796, 1.8477590650225735, 0.0]\n [-1.4142135623730951, 1.414213562373095, 0.0]\n [-1.8477590650225735, 0.7653668647301796, 0.0]\n [-2.0, 0.0, 0.0]\n [-1.8477590650225735, -0.7653668647301796, 0.0]\n [-1.4142135623730951, -1.414213562373095, 0.0]\n [-0.7653668647301796, -1.8477590650225735, 0.0]\n [0.0, -2.0, 0.0]\n [0.7653668647301796, -1.8477590650225735, 0.0]\n [1.4142135623730951, -1.414213562373095, 0.0]\n [1.8477590650225735, -0.7653668647301796, 0.0]\n [2.0, 0.0, 0.0]\n\nDefine a circular ring of radius 4 with a radial perturbation of 10%:\n\njulia> rfun(t) = 0.1 * cospi(4t);  # this is a mode m = 2 perturbation with 10% amplitude\n\njulia> p = Ring(r = rfun);\n\njulia> S = define_curve(p; scale = 4);\n\njulia> S.(ts)\n17-element Vector{SVector{3, Float64}}:\n [4.4, 0.0, 0.0]\n [3.9568307230204227, 1.6389729494895986, 0.0]\n [2.8284271247461903, 2.82842712474619, 0.0]\n [1.4224945094311199, 3.4342055370698716, 0.0]\n [0.0, 3.6, 0.0]\n [-1.4224945094311199, 3.4342055370698716, 0.0]\n [-2.8284271247461903, 2.82842712474619, 0.0]\n [-3.9568307230204227, 1.6389729494895986, 0.0]\n [-4.4, 0.0, 0.0]\n [-3.9568307230204227, -1.6389729494895986, 0.0]\n [-2.8284271247461903, -2.82842712474619, 0.0]\n [-1.4224945094311199, -3.4342055370698716, 0.0]\n [0.0, -3.6, 0.0]\n [1.4224945094311199, -3.4342055370698716, 0.0]\n [2.8284271247461903, -2.82842712474619, 0.0]\n [3.9568307230204227, -1.6389729494895986, 0.0]\n [4.4, 0.0, 0.0]\n\n\n\n\n\n","category":"type"},{"location":"modules/PredefinedCurves/#VortexPasta.PredefinedCurves.TrefoilKnot","page":"PredefinedCurves","title":"VortexPasta.PredefinedCurves.TrefoilKnot","text":"TrefoilKnot()\n\nDescribes a trefoil knot in 3D space.\n\nDefinition\n\nBefore transformations, the trefoil knot is defined by:\n\nbeginaligned\n    x(u) = sin u + 2 sin 2u \n    y(u) = cos u - 2 cos 2u \n    z(u) = -sin 3u\nendaligned\n\nfor u = 2πt  0 2π.\n\n\n\n\n\n","category":"type"},{"location":"modules/PredefinedCurves/#VortexPasta.PredefinedCurves.Lemniscate","page":"PredefinedCurves","title":"VortexPasta.PredefinedCurves.Lemniscate","text":"Lemniscate(; Az = 0,)\n\nDescribes a lemniscate (or figure-eight curve) in 3D space.\n\nThe specific definition used here corresponds to the lemniscate of Bernoulli on the XY plane. Under the normalised parametrisation x(t) with t  0 1, the curve crosses the origin at t = 14 and t = 34, intersecting itself at that point.\n\nOne can perturb the curve in the third direction by passing a non-zero value of Az so that the curve doesn't exactly intersect itself.\n\nDefinition\n\nbeginaligned\n    x(u) = fraccos u1 + sin^2 u \n    y(u) = fracsin u  cos u1 + sin^2 u \n    z(u) = A_z sin u\nendaligned\n\nfor u = 2πt  0 2π.\n\n\n\n\n\n","category":"type"},{"location":"modules/PredefinedCurves/#VortexPasta.PredefinedCurves.PeriodicLine","page":"PredefinedCurves","title":"VortexPasta.PredefinedCurves.PeriodicLine","text":"PeriodicLine(; x = Returns(0), y = Returns(0), r = Returns(0))\n\nDescribes an infinite (but unclosed) line which repeats itself periodically.\n\nDefinition\n\nBy default, this defines a straight infinite line passing through the origin and oriented in the Z direction.\n\nThe line can be perturbed along the X and/or Y directions using user-defined functions x(t) and y(t) which must be periodic with period T = 1. Alternative, one can pass a complex function r(t) = x(t) + im * y(t), which may be more convenient in some cases.\n\nThe line is defined by:\n\nbeginaligned\n    x(t) = x(t) + ℜr(t) \n    y(t) = y(t) + ℑr(t) \n    z(t) = t - 12\nendaligned\n\nfor t  0 1. Note that the line is \"centred\" at z = 0, in the sense that z(12) = 0.\n\nNote that one can change the default period T = 1 of the curve using the scale argument of define_curve. See below for some examples.\n\nExamples\n\nDefine a 2π-periodic curve with a sinusoidal perturbation along X:\n\njulia> xfun(t) = 0.1 * sinpi(2t)  # this function satisfies having period T = 1\nxfun (generic function with 1 method)\n\njulia> p = PeriodicLine(x = xfun);\n\njulia> S = define_curve(p; scale = 2π);  # we scale the curve by 2π (this also scales the perturbation amplitude!)\n\njulia> ts = range(0, 1; length = 16 + 1);\n\njulia> S.(ts)\n17-element Vector{SVector{3, Float64}}:\n [0.0, 0.0, -3.141592653589793]\n [0.24044709195373853, 0.0, -2.748893571891069]\n [0.4442882938158367, 0.0, -2.356194490192345]\n [0.5804906304278862, 0.0, -1.9634954084936207]\n [0.6283185307179586, 0.0, -1.5707963267948966]\n [0.5804906304278862, 0.0, -1.1780972450961724]\n [0.4442882938158367, 0.0, -0.7853981633974483]\n [0.24044709195373853, 0.0, -0.39269908169872414]\n [0.0, 0.0, 0.0]\n [-0.24044709195373853, 0.0, 0.39269908169872414]\n [-0.4442882938158367, 0.0, 0.7853981633974483]\n [-0.5804906304278862, 0.0, 1.1780972450961724]\n [-0.6283185307179586, 0.0, 1.5707963267948966]\n [-0.5804906304278862, 0.0, 1.9634954084936207]\n [-0.4442882938158367, 0.0, 2.356194490192345]\n [-0.24044709195373853, 0.0, 2.748893571891069]\n [0.0, 0.0, 3.141592653589793]\n\nNote that the amplitude of the resulting curve is not the original 01 but instead 01  2π = 06823. This is because passing scale = 2π scales the curve in all directions, including the direction of the perturbation.\n\nInstead, if one wanted to keep the original perturbation while extending the curve period from 1 to 2π, one would need to apply scaling only along the Z direction:\n\njulia> using StaticArrays: SDiagonal\n\njulia> S = define_curve(p; scale = SDiagonal(1, 1, 2π));\n\njulia> S.(ts)\n17-element Vector{SVector{3, Float64}}:\n [0.0, 0.0, -3.141592653589793]\n [0.03826834323650898, 0.0, -2.748893571891069]\n [0.07071067811865477, 0.0, -2.356194490192345]\n [0.09238795325112868, 0.0, -1.9634954084936207]\n [0.1, 0.0, -1.5707963267948966]\n [0.09238795325112868, 0.0, -1.1780972450961724]\n [0.07071067811865477, 0.0, -0.7853981633974483]\n [0.03826834323650898, 0.0, -0.39269908169872414]\n [0.0, 0.0, 0.0]\n [-0.03826834323650898, 0.0, 0.39269908169872414]\n [-0.07071067811865477, 0.0, 0.7853981633974483]\n [-0.09238795325112868, 0.0, 1.1780972450961724]\n [-0.1, 0.0, 1.5707963267948966]\n [-0.09238795325112868, 0.0, 1.9634954084936207]\n [-0.07071067811865477, 0.0, 2.356194490192345]\n [-0.03826834323650898, 0.0, 2.748893571891069]\n [0.0, 0.0, 3.141592653589793]\n\nNow the perturbation amplitude is 01 as we wanted.\n\n\n\n\n\n","category":"type"},{"location":"modules/PredefinedCurves/#Functions","page":"PredefinedCurves","title":"Functions","text":"","category":"section"},{"location":"modules/PredefinedCurves/","page":"PredefinedCurves","title":"PredefinedCurves","text":"define_curve","category":"page"},{"location":"modules/PredefinedCurves/#VortexPasta.PredefinedCurves.define_curve","page":"PredefinedCurves","title":"VortexPasta.PredefinedCurves.define_curve","text":"define_curve(\n    p::ParametricCurve;\n    scale = 1, rotate = LinearAlgebra.I, translate = 0,\n    orientation::Int = 1,\n) -> Function\n\nReturn the definition of the parametric curve p as a function.\n\nThe returned function S(t) returns a coordinate x for any given value of the scalar parameter t  0 1. In particular, closed curves satisfy S(0) == S(1).\n\nOptional arguments\n\nCoordinate transformations\n\nThe original curve can be transformed by (1) scaling, (2) rotation and (3) translation operations. Note that transformations are applied in that order.\n\nscale: scales the curve by a given factor. The argument can be a scalar value for isotropic scaling (same scaling in all directions) or a Tuple of values for anisotropic scaling (see below for some examples).\nrotate: in 3D, this should be a 3×3 orthogonal matrix describing pure rotation. For convenience, one can use the Rotations.jl package for defining such rotations using different parametrisations (see below for some examples).\ntranslate: a scalar or a vector describing a translation operation. Note that translations are performed after scaling and rotation.\n\nCurve orientation\n\norientation: allows to set the curve orientation. In particular, this determines the orientation of the tangent vector along the curve. Should be either 1 or -1.\n\nExtended help\n\nExamples\n\nTranslated and scaled circular ring\n\nDefine a circular ring of radius R = 2 centred at x₀ = (0 0 1) and evaluate its coordinates over equispaced points.\n\njulia> S = define_curve(Ring(); translate = (0, 0, 1), scale = 2);\n\njulia> ts = range(0, 1; length = 16 + 1)\n0.0:0.0625:1.0\n\njulia> S.(ts)\n17-element Vector{SVector{3, Float64}}:\n [2.0, 0.0, 1.0]\n [1.8477590650225735, 0.7653668647301796, 1.0]\n [1.4142135623730951, 1.4142135623730951, 1.0]\n [0.7653668647301796, 1.8477590650225735, 1.0]\n [0.0, 2.0, 1.0]\n [-0.7653668647301796, 1.8477590650225735, 1.0]\n [-1.4142135623730951, 1.4142135623730951, 1.0]\n [-1.8477590650225735, 0.7653668647301796, 1.0]\n [-2.0, 0.0, 1.0]\n [-1.8477590650225735, -0.7653668647301796, 1.0]\n [-1.4142135623730951, -1.4142135623730951, 1.0]\n [-0.7653668647301796, -1.8477590650225735, 1.0]\n [0.0, -2.0, 1.0]\n [0.7653668647301796, -1.8477590650225735, 1.0]\n [1.4142135623730951, -1.4142135623730951, 1.0]\n [1.8477590650225735, -0.7653668647301796, 1.0]\n [2.0, 0.0, 1.0]\n\nAnisotropic scaling: ellipse from circular ring\n\nIf one wants an ellipse instead of a circle, one can simply apply an anisotropic scaling transformation:\n\njulia> using LinearAlgebra\n\njulia> S = define_curve(Ring(); scale = (2, 1, 1));\n\njulia> S.(ts)\n17-element Vector{SVector{3, Float64}}:\n [2.0, 0.0, 0.0]\n [1.8477590650225735, 0.3826834323650898, 0.0]\n [1.4142135623730951, 0.7071067811865476, 0.0]\n [0.7653668647301796, 0.9238795325112867, 0.0]\n [0.0, 1.0, 0.0]\n [-0.7653668647301796, 0.9238795325112867, 0.0]\n [-1.4142135623730951, 0.7071067811865476, 0.0]\n [-1.8477590650225735, 0.3826834323650898, 0.0]\n [-2.0, 0.0, 0.0]\n [-1.8477590650225735, -0.3826834323650898, 0.0]\n [-1.4142135623730951, -0.7071067811865476, 0.0]\n [-0.7653668647301796, -0.9238795325112867, 0.0]\n [0.0, -1.0, 0.0]\n [0.7653668647301796, -0.9238795325112867, 0.0]\n [1.4142135623730951, -0.7071067811865476, 0.0]\n [1.8477590650225735, -0.3826834323650898, 0.0]\n [2.0, 0.0, 0.0]\n\nRotated circular ring\n\nIf we wanted a circular ring defined on the YZ plane instead of the default XZ plane, we can achieve this by rotating the original curve by 90° about the Y axis.\n\njulia> using Rotations: RotY  # there's also RotX and RotZ\n\njulia> rot = RotY(π / 2)  # rotation of 90° about the Y axis\n3×3 RotY{Float64} with indices SOneTo(3)×SOneTo(3)(1.5708):\n  6.12323e-17  0.0  1.0\n  0.0          1.0  0.0\n -1.0          0.0  6.12323e-17\n\njulia> rot = SMatrix(replace(x -> abs(x) < 1e-16 ? zero(x) : x, rot))  # remove spurious near-zero values\n3×3 SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.0  0.0  1.0\n  0.0  1.0  0.0\n -1.0  0.0  0.0\n\njulia> S = define_curve(Ring(); scale = 2, rotate = rot);\n\njulia> S.(ts)\n17-element Vector{SVector{3, Float64}}:\n [0.0, 0.0, -2.0]\n [0.0, 0.7653668647301796, -1.8477590650225735]\n [0.0, 1.4142135623730951, -1.4142135623730951]\n [0.0, 1.8477590650225735, -0.7653668647301796]\n [0.0, 2.0, 0.0]\n [0.0, 1.8477590650225735, 0.7653668647301796]\n [0.0, 1.4142135623730951, 1.4142135623730951]\n [0.0, 0.7653668647301796, 1.8477590650225735]\n [0.0, 0.0, 2.0]\n [0.0, -0.7653668647301796, 1.8477590650225735]\n [0.0, -1.4142135623730951, 1.4142135623730951]\n [0.0, -1.8477590650225735, 0.7653668647301796]\n [0.0, -2.0, 0.0]\n [0.0, -1.8477590650225735, -0.7653668647301796]\n [0.0, -1.4142135623730951, -1.4142135623730951]\n [0.0, -0.7653668647301796, -1.8477590650225735]\n [0.0, 0.0, -2.0]\n\nMore generally, to rotate about an arbitrary axis ê = [ex, ey, ez] by an angle θ (in radians), one can use rot = AngleAxis(θ, ex, ey, ez) from the Rotations.jl package.\n\nRandom rotations\n\nIn addition, the Rotations.jl package allows to easily generate random and uniformly distributed rotations:\n\njulia> using Rotations: QuatRotation  # parametrise rotations using quaternions\n\njulia> using Random: MersenneTwister\n\njulia> rng = MersenneTwister(42);\n\njulia> rot = rand(rng, QuatRotation)  # uniformly distributed random rotation\n3×3 QuatRotation{Float64} with indices SOneTo(3)×SOneTo(3)(QuaternionF64(0.923391, -0.0602724, 0.307861, 0.22122)):\n  0.712566  -0.445655   0.541886\n  0.371433   0.894858   0.24752\n -0.59522    0.0249001  0.803177\n\njulia> S = define_curve(Ring(); scale = 2, rotate = rot);\n\njulia> S.(ts)\n17-element Vector{SVector{3, Float64}}:\n [1.4251329706813418, 0.7428666122301657, -1.190439083830269]\n [0.9755612628402096, 1.3712140745918031, -1.0807646293652284]\n [0.37746919621652514, 1.790806624183378, -0.806553557235094]\n [-0.27808913376434097, 1.9377650989455064, -0.4095520174421194]\n [-0.8913109140138611, 1.7897164032775457, 0.04980010440813476]\n [-1.3688386873583265, 1.3691996090301746, 0.501570611801321]\n [-1.637973179106087, 0.7402345861333226, 0.8769815402966743]\n [-1.6577411025987892, -0.00142444225909442, 1.1188799791393182]\n [-1.4251329706813418, -0.7428666122301657, 1.190439083830269]\n [-0.9755612628402096, -1.3712140745918031, 1.0807646293652284]\n [-0.37746919621652514, -1.790806624183378, 0.806553557235094]\n [0.27808913376434097, -1.9377650989455064, 0.4095520174421194]\n [0.8913109140138611, -1.7897164032775457, -0.04980010440813476]\n [1.3688386873583265, -1.3691996090301746, -0.501570611801321]\n [1.637973179106087, -0.7402345861333226, -0.8769815402966743]\n [1.6577411025987892, 0.00142444225909442, -1.1188799791393182]\n [1.4251329706813418, 0.7428666122301657, -1.190439083830269]\n\n\n\n\n\n","category":"function"},{"location":"modules/FilamentIO/#FilamentIO","page":"FilamentIO","title":"FilamentIO","text":"","category":"section"},{"location":"modules/FilamentIO/","page":"FilamentIO","title":"FilamentIO","text":"CurrentModule = VortexPasta.FilamentIO\nCollapsedDocStrings = true","category":"page"},{"location":"modules/FilamentIO/","page":"FilamentIO","title":"FilamentIO","text":"FilamentIO","category":"page"},{"location":"modules/FilamentIO/#VortexPasta.FilamentIO","page":"FilamentIO","title":"VortexPasta.FilamentIO","text":"FilamentIO\n\nModule defining tools for reading and writing filament data.\n\n\n\n\n\n","category":"module"},{"location":"modules/FilamentIO/#Writing-data","page":"FilamentIO","title":"Writing data","text":"","category":"section"},{"location":"modules/FilamentIO/","page":"FilamentIO","title":"FilamentIO","text":"write_vtkhdf\nBase.setindex!(io::FilamentIO.VTKHDFFile, vs::AbstractVector{<:AbstractVector}, name::AbstractString)\nBase.setindex!(io::FilamentIO.VTKHDFFile, data, name::AbstractString)","category":"page"},{"location":"modules/FilamentIO/#VortexPasta.FilamentIO.write_vtkhdf","page":"FilamentIO","title":"VortexPasta.FilamentIO.write_vtkhdf","text":"write_vtkhdf(\n    [func::Function],\n    filename::AbstractString,\n    fs::AbstractVector{<:AbstractFilament};\n    refinement = 1,\n    dataset_type = :PolyData,\n    parametrisation = true,\n    periods = (nothing, nothing, nothing),\n)\n\nWrite new VTK HDF file containing a list of filaments.\n\nA VTK HDF file is an HDF5 file organised in such a way that it can be readily visualised in tools such as ParaView. Data in the file can be readily accessed using HDF5 tools and libraries.\n\nFollowing the VTK HDF specification, this function creates a \"VTKHDF\" group on top of the HDF5 file. Then, it creates the datasets allowing to describe the filaments as an unstructured grid.\n\nSee also the VTK documentation for details on the VTK HDF format.\n\nExtended help\n\nRelevant datasets\n\nSome relevant datasets which are written are:\n\n/VTKHDF/Points: contains the coordinates of all filament nodes. Points are represented as an array of dimensions (3, Np) where Np is the total number of nodes. Note that the points include the endpoint, meaning that for a closed filament the initial coordinate appears twice in the file. This is done to disambiguate between closed and infinite but unclosed filaments (see end_to_end_offset).\n/VTKHDF/CellData/FilamentIds: contains the filament id associated to each VTK cell. It is a dataset of length Nc, where Nc is the number of cells. In our case a cell is a spatial curve made of discrete points. The ids are Int32 values from 1 to Nf, where Nf is the number of filaments. The values are always sorted increasingly (FilamentIds[i + 1] ≥ FilamentIds[i] for all i). Note that, in general, one cell corresponds to one filament (so that Nc == Nf), but this may not be the case when the periods argument is used and a filament is broken onto multiple curves (see Periodic wrapping of filaments below for details).\n\nAttaching extra data\n\nThe optional func argument can be used to attach other data (such as velocity vectors or the current time) to the generated file. This is most conveniently done using the do block syntax. See further below for some examples.\n\nOptional keyword arguments\n\nrefinement::Int = 1: allows to output more than 1 point for each filament segment. This is mostly useful for producing nice visualisations. The level of refinement is written to the /VTKHDF/RefinementLevel dataset, which allows to read back the data skipping intra-segment nodes.\nparametrisation::Bool = true: if true (default), write curve parametrisation values. This allows read_vtkhdf to reconstruct the exact same curve that was written (assuming the same discretisation method is used, e.g. cubic splines), even if the curve used some non-default curve parametrisation. Values are written to the /VTKHDF/PointData/Parametrisation dataset.\ndataset_type::Symbol: can be either :PolyData (default) or :UnstructuredGrid. There's usually no reason to change this.\n\nPeriodic wrapping of filaments\n\nWhen using periodic boundary conditions, one can use the optional periods argument to periodically wrap the filaments. In this case, one should pass a tuple periods = (Lx, Ly, Lz) with the period in each direction (one can pass nothing if there are non-periodic directions).\n\nIn this case, filaments outside the main periodic box will be translated to fit in the periodic box. Moreover, if a filament locally goes out of the periodic box, it will be broken onto multiple curves so that they all fit within the domain. One can then look at the /VTKHDF/CellData/FilamentIds dataset to determine which curves belong to the same filament.\n\nTypical usage\n\n# Note: the file extension is arbitrary, but ParaView prefers \".vtkhdf\" (or \".hdf\") if one\n# wants to use the files for visualisation.\nwrite_vtkhdf(\"filaments.vtkhdf\", fs; refinement = 2, periods = (2π, 2π, 2π)) do io\n    io[\"Velocity\"] = vs  # adds velocity as VTK point data, assuming vs is a VectorOfVectors\n    io[\"Curvatures\"] = CurvatureVector()  # convenient syntax for writing geometric quantities along filaments\n    io[\"Time\"] = 0.3     # adds time as VTK field data, since it's a scalar\n    # one can add other fields here...\nend\n\n\n\n\n\n","category":"function"},{"location":"modules/FilamentIO/#Base.setindex!-Tuple{VortexPasta.FilamentIO.VTKHDFFile, AbstractVector{<:AbstractVector}, AbstractString}","page":"FilamentIO","title":"Base.setindex!","text":"Base.setindex!(io::VTKHDFFile, vs::AbstractVector{<:AbstractVector}, name::AbstractString)\n\nAttach data to filament nodes.\n\nOne generally wants to use the syntax io[name] = vs which calls this function.\n\nThis can be used to write fields defined at filament nodes (for instance, the velocity of each node).\n\nThe data is written to the dataset /VTKHDF/PointData/$name.\n\nFor vector fields (such as velocity), the written dataset has dimensions (3, Np) where Np is the total number of filament nodes (including endpoints). The format is exactly the same as for the Points dataset as detailed in write_vtkhdf. As also explained there, the Offsets dataset can be used to recover the values associated to each filament.\n\nWriting geometric quantities\n\nIt is also possible to write geometric quantities such as unit tangents or curvature vectors along filaments (see GeometricQuantity for a list). For this, one can pass the wanted quantity as the vs argument.\n\nFor example, one can simply do\n\nio[\"Curvatures\"] = CurvatureVector()\n\nto write curvature vectors along each filament.\n\n\n\n\n\n","category":"method"},{"location":"modules/FilamentIO/#Base.setindex!-Tuple{VortexPasta.FilamentIO.VTKHDFFile, Any, AbstractString}","page":"FilamentIO","title":"Base.setindex!","text":"Base.setindex!(io::VTKHDFFile, data, name::AbstractString)\n\nWrite data as VTK field data to VTK HDF file.\n\nIn VTK, field data refers to data which is not directly attached to the geometry. This is typically small datasets or simple values, such as the current time or simulation parameters.\n\nNote that scalar data (such as time) is always written as a single-element vector, since otherwise it cannot be parsed by VTK.\n\nThis function interprets everything that is not a vector of vectors as field data.\n\n\n\n\n\n","category":"method"},{"location":"modules/FilamentIO/#Reading-data","page":"FilamentIO","title":"Reading data","text":"","category":"section"},{"location":"modules/FilamentIO/","page":"FilamentIO","title":"FilamentIO","text":"read_vtkhdf","category":"page"},{"location":"modules/FilamentIO/#VortexPasta.FilamentIO.read_vtkhdf","page":"FilamentIO","title":"VortexPasta.FilamentIO.read_vtkhdf","text":"read_vtkhdf(\n    [func::Function],\n    filename::AbstractString,\n    ::Type{T},\n    method::DiscretisationMethod,\n) where {T}\n\nRead filament locations from VTK HDF file.\n\nThis function loads filaments based on the datasets /VTKHDF/Points and /VTKHDF/Offsets as written by the write_vtkhdf function.\n\nReturns a vector of filaments, where each filament is discretised according to the chosen method. See Filaments.init for possible options.\n\nOne can also read other datasets using read and read!, as shown and explained below.\n\nExtended help\n\nTypical usage\n\nlocal vs, t  # make sure these variables still exist after the `do` block\n\n# The returned `fs` is a list of filaments.\nfs = read_vtkhdf(\"filaments.vtkhdf\", Float64, CubicSplineMethod()) do io\n    vs = read(io, \"Velocity\", PointData())            # here `vs` contains one velocity vector per filament node\n    t = only(read(io, \"Time\", FieldData(), Float64))  # note: field data is always written as an array\n    # one can read other fields here...\nend\n\nThe available reading functions are:\n\nread(io, name::AbstractString, ::PointData) for reading point data (e.g. a velocity field);\nread(io, name::AbstractString, ::FieldData, ::Type{T}) for reading field data (i.e. data not attached to filament nodes, such as the current time);\nread!(io, vs::AbstractVector{<:AbstractVector}, name::AbstractString) for reading point data onto a preallocated vector of vectors.\n\nAccessing filament data in do block\n\nWhen using the do block syntax as in the above example, one may want to have access to the filament locations fs from within the do block. For instance, this can be useful if one has a preallocated vector of velocities vs which needs to be resized to match the number of filaments and filament nodes, before reading values using read!.\n\nIn fact, fs can be easily obtained from the io object:\n\nread_vtkhdf(\"filaments.vtkhdf\", Float64, CubicSplineMethod()) do io\n    fs = io.fs  # this is the vector of filaments\n    # Say we want to resize an existent vector of velocities (must have the right type...):\n    resize!(vs, length(fs))\n    for (v, f) ∈ zip(vs, fs)\n        resize!(v, length(nodes(f)))  # resize velocities of a single filament\n    end\n    # Now we can read the velocities\n    read!(io, vs, \"Velocity\")\nend\n\n\n\n\n\n","category":"function"},{"location":"modules/FilamentIO/#Time-series-files","page":"FilamentIO","title":"Time series files","text":"","category":"section"},{"location":"modules/FilamentIO/","page":"FilamentIO","title":"FilamentIO","text":"TimeSeriesFile\nBase.setindex!(tsf::TimeSeriesFile, filename::AbstractString, time::Real)\nBase.empty!(tsf::TimeSeriesFile)\nsave(filename::AbstractString, tsf::TimeSeriesFile)","category":"page"},{"location":"modules/FilamentIO/#VortexPasta.FilamentIO.TimeSeriesFile","page":"FilamentIO","title":"VortexPasta.FilamentIO.TimeSeriesFile","text":"TimeSeriesFile() -> TimeSeriesFile\n\nInitialise a time series file compatible with ParaView.\n\nA ParaView time series file is a JSON which points to a series of VTK files representing a time series. To each VTK file one can associate a (simulation) time.\n\nOne can use this to describe a series of VTKHDF files generated by write_vtkhdf. Note that, in this case, the extension of the time series file must be .vtkhdf.series.\n\nTypical usage\n\n# Initialise TimeSeriesFile before starting a simulation\ntsf = TimeSeriesFile()\n\n# Write a VTKHDF file associated to a single time\ntimestep = 4200\ntime = 24.0\nfilename = \"rings_$(timestep).vtkhdf\"\nwrite_vtkhdf(filename, filaments, etc...)  # write VTKHDF file\ntsf[time] = filename                       # add VTKHDF file to time series file\n\n# Save the file at the end of the simulation (or at an intermediate time, that's OK too)\nsave(\"rings.vtkhdf.series\", tsf)  # note: the extension must be .vtkhdf.series to make ParaView happy\n\n\n\n\n\n","category":"type"},{"location":"modules/FilamentIO/#Base.setindex!-Tuple{TimeSeriesFile, AbstractString, Real}","page":"FilamentIO","title":"Base.setindex!","text":"Base.setindex!(tsf::TimeSeriesFile, filename::AbstractString, time::Real)\n\nAdd file to time series file.\n\nTypical usage\n\ntimestep = 4200\ntime = 24.0\nfilename = \"rings_$(timestep).vtkhdf\"\ntsf[time] = filename\n\n\n\n\n\n","category":"method"},{"location":"modules/FilamentIO/#Base.empty!-Tuple{TimeSeriesFile}","page":"FilamentIO","title":"Base.empty!","text":"Base.empty!(tsf::TimeSeriesFile)\n\nReset TimeSeriesFile, removing all entries.\n\n\n\n\n\n","category":"method"},{"location":"modules/FilamentIO/#FileIO.save-Tuple{AbstractString, TimeSeriesFile}","page":"FilamentIO","title":"FileIO.save","text":"save(filename::AbstractString, tsf::TimeSeriesFile)\nsave(io::IO, tsf::TimeSeriesFile)\n\nWrite TimeSeriesFile to a file.\n\nThe filename must have extension .VTKFORMAT.series. In particular, if writing VTKHDF files, the format must be .vtkhdf.series.\n\n\n\n\n\n","category":"method"},{"location":"modules/Timestepping/#Timestepping","page":"Timestepping","title":"Timestepping","text":"","category":"section"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"CurrentModule = VortexPasta.Timestepping\nCollapsedDocStrings = true","category":"page"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"Timestepping","category":"page"},{"location":"modules/Timestepping/#VortexPasta.Timestepping","page":"Timestepping","title":"VortexPasta.Timestepping","text":"Timestepping\n\nModule defining timestepping solvers for vortex filament simulations.\n\n\n\n\n\n","category":"module"},{"location":"modules/Timestepping/#Setting-up-a-simulation","page":"Timestepping","title":"Setting-up a simulation","text":"","category":"section"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"The usual way of setting-up a simulation is to first create a VortexFilamentProblem and then to call init to initialise a VortexFilamentSolver:","category":"page"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"using VortexPasta.Filaments\nusing VortexPasta.BiotSavart\nusing VortexPasta.Timestepping\n\nfs = [Filaments.init(...) for n ∈ 1:10]          # initialise a set of filaments\nparams = ParamsBiotSavart(...)                   # set Biot-Savart parameters\ntspan = (tmin, tmax)                             # set start and end time of simulation\nprob = VortexFilamentProblem(fs, tspan, params)  # create problem\niter = init(prob, RK4(); dt = 0.01, ...)         # initialise VortexFilamentSolver","category":"page"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"","category":"page"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"VortexFilamentProblem\ninit\nVortexFilamentSolver","category":"page"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.VortexFilamentProblem","page":"Timestepping","title":"VortexPasta.Timestepping.VortexFilamentProblem","text":"VortexFilamentProblem(fs::AbstractVector{<:AbstractFilament}, tspan::NTuple{2}, p::ParamsBiotSavart)\n\nDefine a vortex filament problem.\n\nArguments:\n\nfs: initial vortex positions;\ntspan = (t_begin, t_end): time span;\np: Biot–Savart parameters (see ParamsBiotSavart).\n\nSee init for initialising a solver from a VortexFilamentProblem.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#CommonSolve.init","page":"Timestepping","title":"CommonSolve.init","text":"init(prob::VortexFilamentProblem, scheme::TemporalScheme; dt::Real, kws...) -> VortexFilamentSolver\n\nInitialise vortex filament problem.\n\nReturns a VortexFilamentSolver which can be advanced in time using either step! or solve!.\n\nMandatory positional arguments\n\nprob: a VortexFilamentProblem containing the problem definition.\nscheme: a timestepping scheme (see TemporalScheme).\n\nMandatory keyword arguments\n\ndt::Real: the simulation timestep.\n\nOptional keyword arguments\n\nalias_u0 = false: if true, the solver is allowed to modify the initial vortex filaments.\nrefinement = NoRefinement(): criterion used for adaptive refinement of vortex filaments. See RefinementCriterion for a list of possible criteria.\nreconnect = NoReconnections(): criterion used to perform vortex reconnections. See ReconnectionCriterion for a list of possible criteria.\nadaptivity = NoAdaptivity(): criterion used for adaptively setting the timestep dt. See AdaptivityCriterion for a list of possible criteria.\ndtmin = 0.0: minimum dt for adaptive timestepping. If dt < dtmin, the solver is stopped with an error.\nfast_term = LocalTerm(): for IMEX and multirate schemes, this determines what is meant by \"fast\" and \"slow\" dynamics. This can either be LocalTerm or ShortRangeTerm.\nLIA = false: if true, only use the local induction approximation (LIA) to advance vortex filaments, ignoring all non-local interactions. Note that reconnections may still be enabled.\nfold_periodic = true: if true (default), vortices will be recentred onto the main unit cell when using periodic boundary conditions. It may be convenient to disable this for visualisation purposes. This setting doesn't affect the results (velocity of each filament, reconnections, …), besides possible spatial translations of the filaments proportional to the domain period.\ncallback: a function to be called at the end of each timestep. The function must accept a single argument iter::VortexFilamentSolver. Filaments should not be modified by this function. In that case use affect! instead. See notes below for more details.\naffect!: similar to callback, but allows to modify filament definitions. See notes below for more details.\ntimer = TimerOutput(\"VortexFilament\"): an optional TimerOutput for recording the time spent on different functions.\nexternal_velocity / external_streamfunction: allows to add an external velocity field to \"force\" the filaments. See \"Adding an external velocity\" below for more details.\nstretching_velocity: allows to add an external \"stretching\" velocity to the filaments. This can be considered as an external energy (or length) injection mechanism. However, it can also lead to spurious Kelvin waves. See \"Adding a stretching velocity\" below for more details.\n\nExtended help\n\nDifference between callback and affect!\n\nThe difference between the callback(iter) and affect!(iter) functions is the time at which they are called:\n\nthe affect! function is called before performing Biot-Savart computations from the latest filament positions. In other words, the fields iter.vs and iter.ψs are not synchronised with iter.fs, and it generally makes no sense to access them. Things like energy estimates will be incorrect if done in affect!. On the other hand, the affect! function allows to modify iter.fs before Biot–Savart computations are performed.\nthe callback function is called after performing Biot-Savart computations. This means that iter.vs and iter.ψs correspond to the latest filament positions. However, one must not modify iter.fs, or otherwise the velocity iter.vs (which will be used at the next timestep) will no longer correspond to the filament positions.\n\nAdding an external velocity\n\nOne can set the external_velocity keyword argument to impose an external velocity field bmv_textf(bmx t). In this case, the total velocity at a point bmx (which can be on a vortex filament) will be\n\nbmv(bmx) = bmv_textBS(bmx) + bmv_textf(bmx)\n\nwhere bmv_textBS is the velocity obtained from the Biot–Savart law.\n\nThis can be a way of applying an external forcing (and injecting energy) to the vortex system.\n\nThe external velocity should be given as a function, which should have the signature v_ext(x⃗::Vec3, t::Real) -> Vec3. The function should return a Vec3 with the velocity at the location x⃗ and time t. For example, to impose a constant sinusoidal forcing in the x direction which varies along z, the external_velocity keyword argument could look like:\n\nexternal_velocity = (x⃗, t) -> Vec3(0.1 * sin(2 * x⃗.z), 0, 0)\n\nOne usually wants the external velocity to be divergence-free, to preserve the incompressibility of the flow.\n\nNotes on energy estimation\n\nWhen setting an external velocity bmv_textf(bmx t), one may also want to impose an external streamfunction field bmψ_textf(bmx t) via the external_streamfunction keyword argument. Such a field plays no role in the dynamics, but it allows to include the kinetic energy associated to the external velocity field when calling Diagnostics.kinetic_energy_from_streamfunction. If provided, the external streamfunction should satisfy bmv_textf = bm  bmψ_textf.\n\nMore precisely, when applying an external velocity field, the total kinetic energy is\n\nbeginalign*\n    E = frac12V  bmv_textBS + bmv_textf^2  mathrmd^3bmx\n    \n    = frac12V left\n    Γ _mathcalC left( bmψ_textBS + 2 bmψ_textf right)  mathrmdbms\n    +\n     bmv_textf^2  mathrmd^3bmx\n    right\nendalign*\n\nwhere bmψ_textBS is the streamfunction obtained from the Biot-Savart law. Accordingly, when passing external_streamfunction, the streamfunction values attached to vortex filaments (in iter.ψs) will actually contain bmψ_textBS + 2 bmψ_textf (note the factor 2) to enable the computation of the full kinetic energy. Moreover, calling Diagnostics.kinetic_energy_from_streamfunction with a VortexFilamentSolver will automatically include an estimation of the kinetic energy of the external velocity field (the volume integral above).\n\nnote: Note\nWhether this total kinetic energy is of any physical interest is a different question, so it can be reasonable to ignore the external_streamfunction parameter in order to obtain the energy associated to bmv_textBS only.\n\nAdding a stretching velocity\n\nOne can set the stretching_velocity keyword argument to impose a stretching velocity bmv_textL(ξ t) on filament locations bms(ξ t). This velocity will be parallel (and generally opposite) to the curvature vector bms = ρ bmN, where ρ is the curvature and bmN the unit normal.\n\nMore precisely, the stretching_velocity parameter allows to set a filament velocity of the form\n\nbmv_textL(ξ) = -v_textLρ(ξ)  bmN(ξ)\n\nwhere v_textL is a velocity magnitude which can optionally depend on the local curvature value ρ. The stretching_velocity parameter should therefore be a function v(ρ::Real) -> Real.\n\nNote that bmv  bms can be roughly interpreted as a local stretching rate (this is actually true for the integrated quantity, see Diagnostics.stretching_rate). Therefore, one may want v_textL to be inversely proportional to the local curvature ρ, so that the local stretching rate is approximately independent of the filament location ξ. To achieve this, one may set\n\nstretching_velocity = ρ -> min(γ / ρ, v_max)\n\nwhere γ is a constant (units T^-1) setting the stretching magnitude, and v_max is a maximum stretching velocity used to avoid very large velocities in low-curvature regions. One could do something fancier and replace the min with a smooth regularisation such as\n\nstretching_velocity = ρ -> -expm1(-ρ / ρ₀) * (γ / ρ)  # note: expm1(x) = exp(x) - 1\n\nfor some small curvature ρ₀. The maximum allowed velocity will then be vmax = γ / ρ₀.\n\n\n\n\n\n","category":"function"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.VortexFilamentSolver","page":"Timestepping","title":"VortexPasta.Timestepping.VortexFilamentSolver","text":"VortexFilamentSolver\n\nContains the instantaneous state of a vortex filament simulation.\n\nMust be constructed using init.\n\nSome useful fields are:\n\nprob: associated VortexFilamentProblem (including Biot–Savart parameters);\nfs: current state of vortex filaments in the system;\nvs: current velocity of vortex filament nodes;\nψs: current streamfunction at vortex filament nodes;\ntime: a TimeInfo object containing information such as the current time and timestep;\nstats: a SimulationStats object containing information such as the total number of reconnections since the beginning of the simulation;\nto: a TimerOutput, which records the time spent on different functions;\ncache_bs: the Biot–Savart cache, which contains data from short- and long-range computations.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#Running-a-simulation","page":"Timestepping","title":"Running a simulation","text":"","category":"section"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"There are basically two ways of running a simulation:","category":"page"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"either by calling solve!(iter), which will run the full simulation up to the final time tmax;\nor by repeatedly calling step!(iter) (for example inside a for loop) to advance the simulation one timestep at a time.","category":"page"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"The second option can seem to be more convenient as it allows to do things like running analyses or saving snapshots at intermediate stages of the simulation. However, those things are also easy to do with the first option, by passing a callback to the init function. See this section of the vortex ring tutorial for examples.","category":"page"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"solve!\nstep!","category":"page"},{"location":"modules/Timestepping/#CommonSolve.solve!","page":"Timestepping","title":"CommonSolve.solve!","text":"solve!(iter::VortexFilamentSolver)\n\nAdvance vortex filament solver to the ending time.\n\nSee also step! for advancing one step at a time.\n\n\n\n\n\n","category":"function"},{"location":"modules/Timestepping/#CommonSolve.step!","page":"Timestepping","title":"CommonSolve.step!","text":"step!(iter::VortexFilamentSolver)\n\nAdvance solver by a single timestep.\n\n\n\n\n\n","category":"function"},{"location":"modules/Timestepping/#Temporal-schemes","page":"Timestepping","title":"Temporal schemes","text":"","category":"section"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"The following timesteppers are available. When possible, names are the same as those used by DifferentialEquations.jl solvers.","category":"page"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"TemporalScheme","category":"page"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.TemporalScheme","page":"Timestepping","title":"VortexPasta.Timestepping.TemporalScheme","text":"TemporalScheme\n\nAbstract type representing a timestepping scheme.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#Explicit-Runge–Kutta-schemes","page":"Timestepping","title":"Explicit Runge–Kutta schemes","text":"","category":"section"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"ExplicitScheme\nEuler\nMidpoint\nRK4\nSSPRK33\nDP5","category":"page"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.ExplicitScheme","page":"Timestepping","title":"VortexPasta.Timestepping.ExplicitScheme","text":"ExplicitScheme <: TemporalScheme\n\nAbstract type defining an explicit temporal scheme.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.Euler","page":"Timestepping","title":"VortexPasta.Timestepping.Euler","text":"Euler <: ExplicitScheme\n\nStandard first-order Euler scheme.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.Midpoint","page":"Timestepping","title":"VortexPasta.Timestepping.Midpoint","text":"Midpoint <: ExplicitScheme\n\nSecond-order, two-stage explicit midpoint method.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.RK4","page":"Timestepping","title":"VortexPasta.Timestepping.RK4","text":"RK4 <: ExplicitScheme\n\nClassic 4-stage Runge–Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.SSPRK33","page":"Timestepping","title":"VortexPasta.Timestepping.SSPRK33","text":"SSPRK33 <: ExplicitScheme\n\nThree-stage, third-order strong stability preserving (SSP) method.\n\nSee Wikipedia for details.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.DP5","page":"Timestepping","title":"VortexPasta.Timestepping.DP5","text":"DP5 <: ExplicitScheme\n\nDormand–Prince embedded 4/5 Runge–Kutta method.\n\nFor now, the implementation is experimental and can be further optimised.\n\nSee Wikipedia for details.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#Implicit-explicit-Runge–Kutta-(IMEX-RK)-schemes","page":"Timestepping","title":"Implicit-explicit Runge–Kutta (IMEX-RK) schemes","text":"","category":"section"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"The following schemes treat local interactions implicitly and non-local interactions explicitly. This should hopefully allow for larger timesteps than fully explicit schemes.","category":"page"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"ImplicitExplicitScheme\nIMEXEuler\nAscher343\nKenCarp3\nKenCarp4","category":"page"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.ImplicitExplicitScheme","page":"Timestepping","title":"VortexPasta.Timestepping.ImplicitExplicitScheme","text":"ImplicitExplicitScheme <: TemporalScheme\n\nAbstract type defining an implicit-explicit (a.k.a. IMEX) temporal scheme.\n\nThe defined IMEX schemes treat the localised induction approximation (LIA) term as implicit. This may allow to increase the timestep, as it is the LIA term which imposes a small timestep in VFM simulations. Moreover, since this term is quite cheap to compute (compared to non-local interactions), treating it implicitly is not very expensive.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.IMEXEuler","page":"Timestepping","title":"VortexPasta.Timestepping.IMEXEuler","text":"IMEXEuler <: ImplicitExplicitScheme\n\nForward-backward Euler scheme.\n\nThis is the (1,2,1) scheme in the notation of Ascher et al. (1997).\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.Ascher343","page":"Timestepping","title":"VortexPasta.Timestepping.Ascher343","text":"Ascher343 <: ImplicitExplicitScheme\n\n3rd order, 4 stage IMEX Runge–Kutta scheme by Ascher et al. (Appl. Numer. Math., 1997).\n\n⚠ This scheme may be removed in the future as it behaves very similarly to KenCarp3.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.KenCarp3","page":"Timestepping","title":"VortexPasta.Timestepping.KenCarp3","text":"KenCarp3 <: ImplicitExplicitScheme\n\n3rd order, 4 stage IMEX Runge–Kutta scheme by Kennedy & Carpenter (Appl. Numer. Math., 2003).\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.KenCarp4","page":"Timestepping","title":"VortexPasta.Timestepping.KenCarp4","text":"KenCarp4 <: ImplicitExplicitScheme\n\n4th order, 6 stage IMEX Runge–Kutta scheme by Kennedy & Carpenter (Appl. Numer. Math., 2003).\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#Splitting-schemes","page":"Timestepping","title":"Splitting schemes","text":"","category":"section"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"SplittingScheme\nStrang","category":"page"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.SplittingScheme","page":"Timestepping","title":"VortexPasta.Timestepping.SplittingScheme","text":"SplittingScheme <: TemporalScheme\n\nAbstract type defining a splitting scheme (such as Strang splitting).\n\nLike IMEX (ImplicitExplicitScheme) and multirate (MultirateScheme) schemes, the idea is to split the Biot–Savart integral into two terms, respectively governing the \"fast\" dynamics (usually the local term) and the \"slow\" dynamics (non-local interactions).\n\nThe evolution due to both terms is approximated using some kind of Runge–Kutta scheme.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.Strang","page":"Timestepping","title":"VortexPasta.Timestepping.Strang","text":"Strang([fast = RK4()], [slow = Midpoint()]; nsubsteps::Int = 1) <: SplittingScheme\n\n2nd order Strang splitting scheme.\n\nUses one scheme for advancing the \"fast\" terms (assumed to be cheap to compute as well), and possibly a different scheme for the \"slow\" (and expensive) terms. By default these schemes are respectively taken to be RK4 and the 2nd order Midpoint method.\n\nBy default, according to Strang splitting, the fast term is advanced with a timestep of dt/2 (twice in a full timestep). One can pass nsubsteps to use even smaller timesteps for the fast term.\n\nSee SplittingScheme for more details.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#Multirate-Runge–Kutta-schemes","page":"Timestepping","title":"Multirate Runge–Kutta schemes","text":"","category":"section"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"These schemes are completely explicit, but use different timesteps (and different RK schemes) for the slow and fast dynamics. They are represented by an outer scheme of order n with a \"large\" timestep Δt for the slowly evolving terms (which are also expensive to compute), coupled to an inner scheme (typically of order n - 1) with a \"small\" timestep ΔtM. The implemented schemes are those described in Sandu, SIAM J. Numer. Anal. 57 (2019).","category":"page"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"MultirateScheme\nMultirateMidpoint\nSanduMRI33a\nSanduMRI45a","category":"page"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.MultirateScheme","page":"Timestepping","title":"VortexPasta.Timestepping.MultirateScheme","text":"MultirateScheme <: TemporalScheme\n\nAbstract type defining a multirate scheme.\n\nThe idea is to treat different terms of the evolution equations with different timesteps (and possibly different integration schemes). Concretely, the fast dynamics is integrated with a smaller timestep (and a different inner scheme) than the slowly-evolving motions.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.MultirateMidpoint","page":"Timestepping","title":"VortexPasta.Timestepping.MultirateMidpoint","text":"MultirateMidpoint([inner = Euler()], M::Int) <: MultirateScheme\n\n2nd order, two-stage multirate infinitesimal, generalised additive Runge–Kutta (MRI-GARK) scheme.\n\nUses the explicit RK scheme inner for the fast component (by default a 1st order Euler scheme), with M inner steps for each outer RK stage.\n\nThis is the MRI-GARK-ERK22a method from Sandu, SIAM J. Numer. Anal. 57 (2019).\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.SanduMRI33a","page":"Timestepping","title":"VortexPasta.Timestepping.SanduMRI33a","text":"SanduMRI33a([inner = Midpoint()], M::Int) <: MultirateScheme\n\n3rd order, 3-stage multirate infinitesimal, generalised additive Runge–Kutta (MRI-GARK) scheme.\n\nUses the explicit RK scheme inner for the fast component (by default a 2nd order midpoint scheme), with M inner steps for each outer RK stage.\n\nThis is the MRI-GARK-ERK33a method from Sandu, SIAM J. Numer. Anal. 57 (2019).\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.SanduMRI45a","page":"Timestepping","title":"VortexPasta.Timestepping.SanduMRI45a","text":"SanduMRI45a([inner = SSPRK33()], M::Int) <: MultirateScheme\n\n4th order, 5-stage multirate infinitesimal, generalised additive Runge–Kutta (MRI-GARK) scheme.\n\nUses the explicit RK scheme inner for the fast component, with M inner steps for each outer RK stage.\n\nThis is the MRI-GARK-ERK45 method from Sandu, SIAM J. Numer. Anal. 57 (2019).\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#Implicit-schemes","page":"Timestepping","title":"Implicit schemes","text":"","category":"section"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"These implicit schemes are mainly meant to be used as inner schemes when using multirate methods.","category":"page"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"ImplicitScheme\nCrankNicolson","category":"page"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.ImplicitScheme","page":"Timestepping","title":"VortexPasta.Timestepping.ImplicitScheme","text":"ImplicitScheme <: TemporalScheme\n\nAbstract type representing an implicit (possibly multi-stage) scheme.\n\nThese kinds of schemes are mainly meant to be used as inner schemes (for resolving fast-evolving dynamics which are also cheap to compute) when using MultirateScheme.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.CrankNicolson","page":"Timestepping","title":"VortexPasta.Timestepping.CrankNicolson","text":"CrankNicolson() <: ImplicitScheme\n\n2nd order Crank–Nicolson implicit scheme.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#Determining-the-fast-term","page":"Timestepping","title":"Determining the fast term","text":"","category":"section"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"The splitting between fast and slow terms in IMEX and multirate schemes can be done in two different ways. One may either choose to identify the fast term with the local (LIA) term in Biot–Savart, or with the short-range component of Ewald summation.","category":"page"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"LocalTerm\nShortRangeTerm","category":"page"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.LocalTerm","page":"Timestepping","title":"VortexPasta.Timestepping.LocalTerm","text":"LocalTerm <: FastBiotSavartTerm\n\nIdentifies fast dynamics with the local (LIA) term associated to the desingularisation of the Biot–Savart integral.\n\nThis is useful for split timestepping schemes like IMEX or multirate methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.ShortRangeTerm","page":"Timestepping","title":"VortexPasta.Timestepping.ShortRangeTerm","text":"ShortRangeTerm <: FastBiotSavartTerm\n\nIdentifies fast dynamics with the short-range component of Ewald splitting.\n\nThis is only useful for split timestepping schemes like IMEX or multirate methods.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#Adaptivity","page":"Timestepping","title":"Adaptivity criteria","text":"","category":"section"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"A detailed below, a few temporal adaptivity criteria are available which can be used as the adaptivity argument of init.","category":"page"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"AdaptivityCriterion\nNoAdaptivity\nAdaptBasedOnSegmentLength\nAdaptBasedOnVelocity\nMaximumTimestep","category":"page"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.AdaptivityCriterion","page":"Timestepping","title":"VortexPasta.Timestepping.AdaptivityCriterion","text":"AdaptivityCriterion\n\nAbstract type representing a temporal adaptivity criterion.\n\nImplemented adaptivity criteria are:\n\nNoAdaptivity: disables time adaptivity;\nAdaptBasedOnSegmentLength: determines the timestep Δt based on the minimum distance ℓ_min between two filament nodes (Δt  ℓ_min^-2);\nAdaptBasedOnVelocity: determines the timestep Δt based on the maximum velocity v_max of filament nodes and on a predefined distance δ (Δt = δ  v_max).\n\nCombining multiple criteria\n\nAdaptivity criteria can be combined using |. Example:\n\nadaptivity = AdaptBasedOnSegmentLength(1.4) | AdaptBasedOnVelocity(0.01)\n\nAs expected, the timestep Δt will be chosen so that it satisfies both criteria.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.NoAdaptivity","page":"Timestepping","title":"VortexPasta.Timestepping.NoAdaptivity","text":"NoAdaptivity <: AdaptivityCriterion\nNoAdaptivity()\n\nDisable temporal adaptivity, leaving the timestep Δt constant.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.AdaptBasedOnSegmentLength","page":"Timestepping","title":"VortexPasta.Timestepping.AdaptBasedOnSegmentLength","text":"AdaptBasedOnSegmentLength <: AdaptivityCriterion\nAdaptBasedOnSegmentLength(γ::Float64)\n\nAdapt timestep Δt based on the minimum distance δ between two filament nodes.\n\nMore precisely, the timestep is set to Δt = γ  T_textKW(δ), where γ is a dimensionless factor to be chosen, and:\n\nT_textKW(λ) = frac2 λ^2Γ left\n    lnleft( fracλπa right) + frac12 - (Δ + γ)\nright^-1\n\nis the period of a Kelvin wave of wavelength λ. See ParamsBiotSavart for the definitions of the vortex parameters Γ, a and Δ.\n\nThis criterion is somewhat analogous to the CFL condition in grid-based computations, and γ is the analogous of the maximum CFL number to be allowed. As such, the right value of γ will depend on the chosen temporal scheme.\n\nFor example, the RK4 scheme seems to require γ  1 to remain stable.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.AdaptBasedOnVelocity","page":"Timestepping","title":"VortexPasta.Timestepping.AdaptBasedOnVelocity","text":"AdaptBasedOnVelocity <: AdaptivityCriterion\nAdaptBasedOnVelocity(δ_crit::Float64; safety_factor = 0.8)\n\nAdapt timestep Δt based on the maximum velocity v_max of filament nodes.\n\nThe objective is that the resulting maximum displacement δ_max = v_max Δt stays below the given critical displacement δ_crit.\n\nOne application of this criterion is to ensure that reconnections happen in-between two solver iterations (that is, to avoid that two filaments cross each other without reconnecting). In this case, δ should be proportional to the chosen distance below which reconnections are performed.\n\nImplementation details\n\nThis criterion is used in two ways:\n\nA priori, to decide the Δt to be used in the next iteration given the velocities of filament nodes at the start of the iteration (at time t). This ensures Δt  δ_textcrit  v_max where v_max is computed at the start of the iteration.\nA posteriori, after the actual node displacements δ from time t to time t + Δt have been computed (e.g. using some Runge–Kutta scheme). If some δ is larger than δ_textcrit, then the iteration is recomputed after halving the timestep (Δt  Δt2). In this case, the original displacements are thrown away (rejected). This process can be eventually repeated until the criterion is satisfied.\n\nOptional safety factor\n\nThe optional safety_factor should be ≤1, which will further reduce the timestep chosen a priori in step 1. This is to try to avoid too many rejected timesteps in step 2, e.g. in case the actual advection velocity is larger than the velocity at the beginning of the timestep.\n\nIn combination with other criteria\n\nIn principle, using this criterion can lead to an infinite timestep when the velocities are zero. For this reason, it's a good idea to combine this criterion with the AdaptBasedOnSegmentLength or the MaximumTimestep criterion. For example:\n\nadaptivity = AdaptBasedOnVelocity(2.0) | AdaptBasedOnSegmentLength(0.9)\nadaptivity = AdaptBasedOnVelocity(2.0) | MaximumTimestep(0.01)\n\nIn fact, the second option is done automatically in init if only an AdaptBasedOnVelocity is passed. In that case, the maximum timestep is taken to be the dt passed to init.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.MaximumTimestep","page":"Timestepping","title":"VortexPasta.Timestepping.MaximumTimestep","text":"MaximumTimestep <: AdaptivityCriterion\nMaximumTimestep(Δt_max::Float64)\n\nCriterion ensuring that the timestep will be kept below a maximal value Δt_max.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#Diagnostics","page":"Timestepping","title":"Diagnostics","text":"","category":"section"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"All diagnostics documented in the Diagnostics page can be conveniently computed using an instantaneous simulation state iter (of type VortexFilamentSolver). See that page for more details.","category":"page"},{"location":"modules/Timestepping/#Internals","page":"Timestepping","title":"Internals","text":"","category":"section"},{"location":"modules/Timestepping/","page":"Timestepping","title":"Timestepping","text":"TemporalSchemeCache\nTimeInfo\nSimulationStats\nmaximum_displacement","category":"page"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.TemporalSchemeCache","page":"Timestepping","title":"VortexPasta.Timestepping.TemporalSchemeCache","text":"TemporalSchemeCache{Scheme <: TemporalScheme}\n\nContains buffers needed by a temporal scheme.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.TimeInfo","page":"Timestepping","title":"VortexPasta.Timestepping.TimeInfo","text":"TimeInfo\n\nContains information on the current time and timestep of a solver.\n\nSome useful fields are:\n\nt::Float64: current time;\ndt::Float64: timestep to be used in next iteration;\ndt_prev::Float64 : timestep used in the last performed iteration;\nnstep::Int: number of timesteps performed until now;\nnrejected::Int: number of rejected iterations.\n\nWhen using the AdaptBasedOnVelocity criterion, an iteration can be rejected if the actual filament displacement is too large compared to what is imposed by the criterion. In that case, the iteration will be recomputed with a smaller timestep (dt → dt/2).\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.SimulationStats","page":"Timestepping","title":"VortexPasta.Timestepping.SimulationStats","text":"SimulationStats{T <: AbstractFloat}\n\nContains accumulated statistics of different events occurring since the beginning of a simulation.\n\nAvailable fields\n\nreconnection_count::Int: total number of reconnections;\nreconnection_length_loss::T: accumulated decrease of filament length due to reconnections. This is estimated from each reconnection event as the difference between the local vortex lengths before and after the reconnection, using the straight segment approximation.\nfilaments_removed_count::Int: total number of removed filaments (this generally happens when the number of discretisation points becomes too small for the spatial discretisation to work);\nfilaments_removed_length::T: total length of removed filaments. Note that this length is estimated using a straight segment approximation (no quadratures). This is because filaments are removed when they can no longer be represented using a continuous interpolation function.\n\n\n\n\n\n","category":"type"},{"location":"modules/Timestepping/#VortexPasta.Timestepping.maximum_displacement","page":"Timestepping","title":"VortexPasta.Timestepping.maximum_displacement","text":"maximum_displacement(::AdaptivityCriterion) -> Float64\n\nReturn the maximum node displacement δ_textcrit allowed by the adaptivity criterion.\n\nMore precisely, δ_textcrit controls the maximum displacement of a filament node during a single timestep of duration Δt.\n\nThis function is mainly relevant when using the AdaptBasedOnVelocity criterion. For other criteria this returns Inf, meaning that they don't limit the maximum allowed displacement.\n\n\n\n\n\n","category":"function"},{"location":"modules/Diagnostics/#Diagnostics","page":"Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"modules/Diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"CurrentModule = VortexPasta.Diagnostics\nCollapsedDocStrings = true","category":"page"},{"location":"modules/Diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Diagnostics","category":"page"},{"location":"modules/Diagnostics/#VortexPasta.Diagnostics","page":"Diagnostics","title":"VortexPasta.Diagnostics","text":"Diagnostics\n\nContains tools for computing different diagnostics (total energy, energy spectra, ...) from simulation data.\n\n\n\n\n\n","category":"module"},{"location":"modules/Diagnostics/#Kinetic-energy","page":"Diagnostics","title":"Kinetic energy","text":"","category":"section"},{"location":"modules/Diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"kinetic_energy\nkinetic_energy_from_streamfunction\nkinetic_energy_nonperiodic","category":"page"},{"location":"modules/Diagnostics/#VortexPasta.Diagnostics.kinetic_energy","page":"Diagnostics","title":"VortexPasta.Diagnostics.kinetic_energy","text":"kinetic_energy(iter::VortexFilamentSolver; quad = nothing) -> Real\nkinetic_energy(fs, ψs, Γ, [Ls]; quad = nothing) -> Real\n\nCompute kinetic energy of velocity field induced by a set of vortex filaments.\n\nThis function simply calls kinetic_energy_from_streamfunction.\n\n\n\n\n\n","category":"function"},{"location":"modules/Diagnostics/#VortexPasta.Diagnostics.kinetic_energy_from_streamfunction","page":"Diagnostics","title":"VortexPasta.Diagnostics.kinetic_energy_from_streamfunction","text":"kinetic_energy_from_streamfunction(iter::VortexFilamentSolver; quad = nothing)\nkinetic_energy_from_streamfunction(fs, ψs, Γ, [Ls]; quad = nothing)\n\nCompute kinetic energy per unit mass (units L^2 T^-2) from streamfunction values at filament nodes in a periodic domain.\n\nThe kinetic energy per unit mass of the velocity field induced by a set of vortex filaments can be obtained as:\n\nE = fracΓ2V  bmψ(bms)  mathrmdbms\n\nwhere Γ is the vortex circulation and V is the volume of interest (e.g. the volume of a periodic cell in periodic domains).\n\nArguments\n\nMandatory arguments\n\nψs: streamfunction values at filament nodes;\nfs: vortex filament locations;\nΓ::Real: quantum of circulation.\n\nOptional arguments\n\nLs::Tuple = (Lx, Ly, Lz): domain size in each direction. If not given, the domain volume V is taken to be 1 (see Non-periodic domains below).\n\nOptional keyword arguments\n\nquad = nothing: optional quadrature rule (e.g. quad = GaussLegendre(4)) used to evaluate line integrals. If nothing, only values at nodes are used (cheaper). Otherwise, if a quadrature rule is passed, interpolations are performed and extra allocations are needed.\n\nNon-periodic domains\n\nIf the domain is not periodic, that is, if one or more values in Ls is Infinity, then the domain volume V in the expression above will be set to 1. This corresponds to computing an energy per unit density (units L^5 T^-2) instead of per unit mass, meaning that one should multiply by the fluid density ρ (M L^-3) to get an actual kinetic energy (M L^2 T^-2).\n\nNote that in non-periodic domains one may also use the kinetic_energy_nonperiodic function, which uses a different definition commonly used for open domains and which does not require streamfunction values (but only velocity values on filament nodes). However, energy computed using that definition may not be properly conserved when it should.\n\nTherefore, it is recommended to always use kinetic_energy_from_streamfunction, even in non-periodic domains.\n\n\n\n\n\n","category":"function"},{"location":"modules/Diagnostics/#VortexPasta.Diagnostics.kinetic_energy_nonperiodic","page":"Diagnostics","title":"VortexPasta.Diagnostics.kinetic_energy_nonperiodic","text":"kinetic_energy_nonperiodic(iter::VortexFilamentSolver; quad = nothing) -> Real\nkinetic_energy_nonperiodic(fs, vs, Γ; quad = nothing) -> Real\n\nCompute kinetic energy per unit density (units L^5 T^-2) from velocity values at filament nodes in an open (non-periodic) domain.\n\nThis function returns the kinetic energy over the infinite fluid volume, which only makes sense in an open domain such that the velocity tends to zero far from the vortices.\n\nIn an open domain, the kinetic energy of the velocity field induced by a set of vortex filaments can be obtained as:\n\nE = ρ Γ  bmv  (bms  mathrmdbms)\n\nwhere Γ is the vortex circulation and ρ is the fluid density. This definition assumes that the velocity field tends to zero far from the vortices. This is true in open domains, but not in periodic ones.\n\nwarning: Energy conservation\nEnergy computed using this definition may present small temporal fluctuations in cases where energy should be conserved. For this reason, it is recommended to always use kinetic_energy_from_streamfunction, which displays proper energy conservation properties. In general, this definition will slightly overestimate the energy obtained from the streamfunction.\n\nThis function returns the energy per unit density E  ρ.\n\nMandatory arguments\n\nvs: velocity values at filament nodes;\nfs: vortex filament locations;\nΓ::Real: quantum of circulation.\n\nOptional keyword arguments\n\nSee kinetic_energy_from_streamfunction for details.\n\nPeriodic domains\n\nIn periodic domains this function will give wrong results, since there are boundary terms coming from integration by parts which are neglected in the above definition (assuming the velocity goes to zero far from the vortices, which is not the case in a periodic domain).\n\nIn this case, the kinetic_energy_from_streamfunction function should be used instead.\n\n\n\n\n\n","category":"function"},{"location":"modules/Diagnostics/#Helicity","page":"Diagnostics","title":"Helicity","text":"","category":"section"},{"location":"modules/Diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"helicity","category":"page"},{"location":"modules/Diagnostics/#VortexPasta.Diagnostics.helicity","page":"Diagnostics","title":"VortexPasta.Diagnostics.helicity","text":"helicity(iter::VortexFilamentSolver; quad = nothing) -> Real\nhelicity(fs, vs, Γ; quad = nothing) -> Real\n\nCompute helicity of a vortex configuration.\n\nThe helicity is defined as:\n\nmathcalH\n=  bmu(bmx)  bmω(bmx)  mathrmd^3bmx\n= Γ  bmv(bms)  mathrmdbms\n\nwhere bmu(bmx) and bmω(bmx) = bm  bmu(bmx) are the velocity and vorticity fields, and bmv(bms) is the velocity of the set of vortex filaments.\n\nArguments\n\nfs: list of vortex filaments (or a single AbstractFilament);\nvs: list of velocities on filament nodes (or a single vector of velocities on a filament);\nΓ: vortex circulation.\n\nSee e.g. kinetic_energy_from_streamfunction for the meaning of the optional quad keyword argument.\n\n\n\n\n\n","category":"function"},{"location":"modules/Diagnostics/#Filament-length","page":"Diagnostics","title":"Filament length","text":"","category":"section"},{"location":"modules/Diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"See filament_length in the Filaments module. For convenience, filament_length is re-exported by Diagnostics, meaning that one can do:","category":"page"},{"location":"modules/Diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"using VortexPasta.Diagnostics\nfilament_length(...)","category":"page"},{"location":"modules/Diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"without needing to import VortexPasta.Filaments.","category":"page"},{"location":"modules/Diagnostics/#Stretching-rate","page":"Diagnostics","title":"Stretching rate","text":"","category":"section"},{"location":"modules/Diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"stretching_rate","category":"page"},{"location":"modules/Diagnostics/#VortexPasta.Diagnostics.stretching_rate","page":"Diagnostics","title":"VortexPasta.Diagnostics.stretching_rate","text":"stretching_rate(iter::VortexFilamentSolver; quad = nothing) -> Real\nstretching_rate(fs, vs; quad = nothing) -> Real\n\nCompute stretching rate of one or more vortices.\n\nThe stretching rate has units L T^-1 and is given by:\n\nfracmathrmd mathcalLmathrmd t\n=  fracbmvξ  mathrmdbms\n= -  bmv  bms  mathrmdξ\n\nwhere ξ is the arc length, bmv(ξ) the local filament velocity, bms(ξ) the local curvature vector, and mathcalL the instantaneous vortex length. The last equality is obtained using integration by parts.\n\nIn the implementation, the last expression is the one used to compute the stretching rate.\n\nMandatory arguments\n\nvs: velocity values at filament nodes;\nfs: vortex filament locations.\n\nOptional keyword arguments\n\nquad = nothing: optional quadrature rule (e.g. quad = GaussLegendre(4)) used to evaluate line integrals. If nothing, only values at nodes are used (cheaper).\n\n\n\n\n\n","category":"function"},{"location":"modules/Diagnostics/#Vortex-impulse","page":"Diagnostics","title":"Vortex impulse","text":"","category":"section"},{"location":"modules/Diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"vortex_impulse","category":"page"},{"location":"modules/Diagnostics/#VortexPasta.Diagnostics.vortex_impulse","page":"Diagnostics","title":"VortexPasta.Diagnostics.vortex_impulse","text":"vortex_impulse(iter::VortexFilamentSolver; quad = nothing) -> Vec3\nvortex_impulse(f; quad = nothing) -> Vec3\n\nEstimate normalised impulse of one or more vortex filaments.\n\nThe vortex impulse is defined as\n\nbmp = frac12 ρ Γ  bms  mathrmdbms\n\nwhere ρ is the fluid density and Γ the circulation about the vortex. Note that this function returns the normalised impulse bmp  ρΓ. The returned impulse has units of L^2 (an area).\n\nNote that, for a circular vortex ring of radius R, its impulse is bmp = ρΓA where A = π R^2 is the area enclosed by the ring (and the orientation is equal to its direction of propagation, i.e. normal to the plane where the ring lives).\n\n\n\n\n\n","category":"function"},{"location":"modules/Diagnostics/#Energy-spectrum","page":"Diagnostics","title":"Energy spectrum","text":"","category":"section"},{"location":"modules/Diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"energy_spectrum!\nenergy_spectrum\ninit_energy_spectrum","category":"page"},{"location":"modules/Diagnostics/#VortexPasta.Diagnostics.energy_spectrum!","page":"Diagnostics","title":"VortexPasta.Diagnostics.energy_spectrum!","text":"energy_spectrum!(Ek::AbstractVector, ks::AbstractVector, cache; unfilter = true)\n\nCompute kinetic energy spectrum associated to vortex filament state.\n\nHere cache contains the results of long-range Biot–Savart computations. It can be either:\n\na LongRangeCache;\na BiotSavartCache (which contains a LongRangeCache);\na VortexFilamentSolver from the Timestepping module (which contains a BiotSavartCache).\n\nThe energy spectrum is computed from a recent Biot–Savart calculation using fast Ewald summation. More precisely, it is computed from the long-range velocity field in Fourier space. The LongRangeCache associated to the calculation is expected to currently contain this field.\n\nIn its most usual state, a LongRangeCache contains the long-range velocity field in the Ewald method, which is a Gaussian-filtered field (see e.g. BiotSavart.to_smoothed_velocity!). By default this function undoes the Gaussian filter, so that the returned kinetic energy spectrum is that of the unsmoothed velocity (which is singular at vortex positions, so it presents a slow decay in wavenumber space). One can pass unfilter = false to return the spectrum associated to the smoothed field.\n\nThe cache can also contain an unsmoothed vorticity field in Fourier space (the result obtained right after performing a NUFFT from the filament locations, see BiotSavart.compute_vorticity_fourier!. In this case this function does the right thing and also computes the spectrum of the associated (unsmoothed) velocity field. Currently, the unfilter argument is ignored in this case.\n\nThe vectors Ek and ks are expected to have the same length. Moreover, the vector of wavenumbers ks should satisfy ks[begin] == 0 and have a constant step Δk = ks[i + 1] - ks[i]. For convenience, the init_energy_spectrum function can be used to create these vectors.\n\nSee also energy_spectrum for an allocating variant which doesn't need predefined Ek and ks vectors.\n\n\n\n\n\n","category":"function"},{"location":"modules/Diagnostics/#VortexPasta.Diagnostics.energy_spectrum","page":"Diagnostics","title":"VortexPasta.Diagnostics.energy_spectrum","text":"energy_spectrum(iter::VortexFilamentSolver; unfilter = true) -> (ks, Ek)\nenergy_spectrum(cache; unfilter = true) -> (ks, Ek)\n\nCompute kinetic energy spectrum associated to vortex filament state.\n\nReturns a tuple of vectors (ks, Ek) where ks contains the probed wavenumbers and Ek the energy associated to each wavenumber.\n\nSee also energy_spectrum! for a non-allocating variant and for more details.\n\n\n\n\n\n","category":"function"},{"location":"modules/Diagnostics/#VortexPasta.Diagnostics.init_energy_spectrum","page":"Diagnostics","title":"VortexPasta.Diagnostics.init_energy_spectrum","text":"Diagnostics.init_energy_spectrum(cache) -> (ks, Ek)\n\nInitialise fields for storing an energy spectrum.\n\nReturns a wavenumber vector ks and an uninitialised energy spectrum Ek with the right dimensions, which can be then passed to energy_spectrum!.\n\nThe returned arrays are always on the CPU, even when the cache contains GPU data.\n\nSee energy_spectrum! for details on the cache argument.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#BiotSavart","page":"BiotSavart","title":"BiotSavart","text":"","category":"section"},{"location":"modules/BiotSavart/","page":"BiotSavart","title":"BiotSavart","text":"CurrentModule = VortexPasta.BiotSavart\nCollapsedDocStrings = true","category":"page"},{"location":"modules/BiotSavart/","page":"BiotSavart","title":"BiotSavart","text":"BiotSavart","category":"page"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart","page":"BiotSavart","title":"VortexPasta.BiotSavart","text":"BiotSavart\n\nModule for estimation of Biot–Savart integrals along vortex filaments using fast Ewald splitting.\n\n\n\n\n\n","category":"module"},{"location":"modules/BiotSavart/#Biot–Savart-parameters","page":"BiotSavart","title":"Biot–Savart parameters","text":"","category":"section"},{"location":"modules/BiotSavart/#Setting-the-parameters","page":"BiotSavart","title":"Setting the parameters","text":"","category":"section"},{"location":"modules/BiotSavart/","page":"BiotSavart","title":"BiotSavart","text":"ParamsBiotSavart\nautotune","category":"page"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.ParamsBiotSavart","page":"BiotSavart","title":"VortexPasta.BiotSavart.ParamsBiotSavart","text":"ParamsBiotSavart{T <: AbstractFloat}\n\nContains parameters for calculation of Biot–Savart integrals using fast Ewald splitting.\n\nThe type parameter T corresponds to the precision used in computations (typically Float64 or Float32).\n\nConstruction\n\nParamsBiotSavart([T = Float64]; Γ, a, α, Ls, Ns, rcut, optional_kws...)\n\nwhere the optional parameter T sets the numerical precision.\n\nMandatory and optional keyword arguments are detailed in the extended help below.\n\nSee also BiotSavart.autotune for an alternative way of setting Biot–Savart parameters.\n\nExtended help\n\nMandatory keyword arguments\n\nΓ::Real: vortex circulation (assumed constant);\na::Real: vortex core size (assumed constant);\nα::Real: Ewald splitting parameter (inverse length scale). One can set α = Zero() to efficiently disable long-range computations.\nLs::Union{Real, NTuple{3, Real}}: domain period in each Cartesian direction. If a single value is passed (e.g. Ls = 2π), it is assumed that periods are the same in all directions.\nOne can set Ls = Infinity() to disable periodicity. This should be done in combination with α = Zero().\nNs::Dims{3}: dimensions of physical grid used for long-range interactions. This parameter is not required if α = Zero().\nrcut: cutoff distance for computation of short-range interactions. For performance and practical reasons, the cutoff distance must be less than half the cell unit size in each direction, i.e. rcut < minimum(Ls) / 2. This parameter is not required if α = Zero().\n\nOptional keyword arguments (and their defaults)\n\nGeneral\n\nquadrature::StaticSizeQuadrature = GaussLegendre(3): quadrature rule for short- and long-range interactions. For example, if quadrature = GaussLegendre(4), then 4 evaluations of the Biot–Savart integrand will be done for each filament segment.\n\nShort-range interactions\n\nbackend_short::ShortRangeBackend: backend used to compute short-range interactions. The default is CellListsBackend(2), unless periodicity is disabled, in which case NaiveShortRangeBackend() is used. See ShortRangeBackend for a list of possible backends;\n\nLong-range interactions\n\nbackend_long::LongRangeBackend = NonuniformFFTsBackend(): backend used to compute long-range interactions. See LongRangeBackend for a list of possible backends;\nlongrange_truncate_spherical = false: if true, perform a spherical truncation in Fourier space, discarding all wavenumbers such that bmk  k_textmax. This is not recommended as it leads to precision loss, and should be used for testing only (in particular, for verifying error estimates which assume this kind of truncation).\n\nLocal self-induced velocity\n\nΔ = 0.25: coefficient appearing in the local self-induced velocity (LIA term), which depends on the vorticity profile at the vortex core.\nSome common values of Δ are:\nΔ = 0.25 for a constant vorticity profile (default);\nΔ = 0.5 for a hollow vortex;\nΔ ≈ 0.905 ≈ 0.558 + ln(2) / 2 for a Gaussian vorticity profile (taking a as the Gaussian standard deviation σ);\nΔ ≈ 0.615 for a Gross–Pitaevskii vortex with healing length a.\nSee Saffman (1992), sections 10.2–10.3 for the first three.\nlia_segment_fraction = nothing: can be used to indicate that the LIA term should be evaluated over a fraction of the two segments surrounding a node. In this case, it should be a real value in (0 1. The default (nothing) is equivalent to 1, and means that the LIA term is evaluated over the full segments. If smaller than 1, the velocity induced by the excluded part of the segments will be evaluated using the regular Biot–Savart law (using quadratures within each subsegment). This may improve accuracy, especially when the discretisation distance is relatively large. Since this means integrating near the singularity of the BS integral, this integral is by default estimated using adaptive quadratures (see quadrature_near_singularity below).\nquadrature_near_singularity = AdaptiveTanhSinh(T; nlevels = 5): quadrature rule to be used when integrating near a singularity, in particular when lia_segment_fraction is enabled. By default an adaptive quadrature rule AdaptiveTanhSinh is used, which is generally accurate but can be costly. One can also pass a StaticSizeQuadrature such as GaussLegendre, but in that case accuracy is not guaranteed.\n\n\n\n\n\n","category":"type"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.autotune","page":"BiotSavart","title":"VortexPasta.BiotSavart.autotune","text":"BiotSavart.autotune(fs::AbstractVector{<:AbstractFilament{T}}, [β::Real = 3.5]; kwargs...) -> ParamsBiotSavart{T}\n\nGenerate Biot-Savart parameters optimised for a given filament geometry and accuracy parameter β.\n\nBased on the given value of β, this function will try to automatically set the following Ewald-related parameters:\n\ninverse splitting parameter α;\ncut-off distance r_textcut = β  α;\nFourier-space cut-off k_textmax = 2αβ  πML, where M is the grid size and L the domain period.\n\nIn practice, this function will try to find the value of α which minimises the computation of the velocity of the filaments fs.\n\nwarning: Randomness\nThe parameters selected by this function can be quite random and change from one run to another for a same set of input parameters.\n\nnote: Default accuracy\nThe default values of β and backend_long correspond to a nominal 6-digit accuracy. See the Extended help for more details.\n\nwarning: Periodic domains only\nThis function only supports periodic domains (finite domain period L), since the chosen parameters are irrelevant in the non-periodic case.\n\nSee also ParamsBiotSavart.\n\nExtended help\n\nMandatory keyword arguments\n\nΓ::Real: vortex circulation (assumed constant);\na::Real: vortex core size (assumed constant);\nLs::Union{Real, NTuple{3, Real}}: domain period in each Cartesian direction. If a single value is passed (e.g. Ls = 2π), it is assumed that periods are the same in all directions.\n\nOptional keyword arguments\n\nThis function accepts the same keyword arguments as ParamsBiotSavart and with the same default values. In particular, the default short- and long-range backends are:\n\nbackend_short::ShortRangeBackend = CellListsBackend(2);\nbackend_long::LongRangeBackend = NonuniformFFTsBackend(σ = 1.5, m = HalfSupport(4)).\n\nAutotuning parameters\n\nThe following keyword arguments can be used to control autotuning:\n\nnruns = 4: number of Biot–Savart calculations per value of α. The minimum elapsed time among all runs will be used in autotuning;\nCstart = 1.5: initial guess for non-dimensional factor C (see Autotuning algorithm below);\nΔC = 0.1: increment of non-dimensional factor C;\nverbose = false: if true, print autotuning information.\n\nAutotuning algorithm\n\nThe autotuning algorithm basically consists in trying different values of α, which we write under the form:\n\nα = C  ( N  V )^13\n\nwhere N is the total number of filament nodes and V the domain volume. The parameter that is varied is the non-dimensional factor C.\n\nFor now the algorithm is quite basic. We try different values around C = Cstart using increments of ΔC. The parameters giving the fastest runtime are returned.\n\nTypical values of β and NUFFT parameters\n\nThe following table roughly relates accuracy (in number of digits) and values of β, as detailed in Polanco (2024):\n\nPrecision digits β NUFFT w\n3 2.0 2\n4 2.5 3\n6 3.5 4\n8 4.0 5\n10 4.5 6\n12 5.0 7\n14 5.5 8\n\nThe last column is the size of the NUFFT half-support w which ensures sufficient NUFFT accuracy. The given values assume a NUFFT oversampling factor σ = 15 and a (backwards) Kaiser–Bessel spreading kernel, which are the default when using the NonuniformFFTsBackend. Currently, this parameter is not automatically selected by this function. In other words, knowing the required value of w, one can pass:\n\nbackend_long = NonuniformFFTsBackend(m = HalfSupport(w))\n\nas a keyword argument to this function.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#Accessing-parameters","page":"BiotSavart","title":"Accessing parameters","text":"","category":"section"},{"location":"modules/BiotSavart/","page":"BiotSavart","title":"BiotSavart","text":"circulation\nperiods\ndomain_is_periodic","category":"page"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.circulation","page":"BiotSavart","title":"VortexPasta.BiotSavart.circulation","text":"BiotSavart.circulation(p::ParamsBiotSavart) -> Γ\n\nReturn the circulation Γ associated to each vortex.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.periods","page":"BiotSavart","title":"VortexPasta.BiotSavart.periods","text":"BiotSavart.periods(p::ParamsBiotSavart) -> (Lx, Ly, Lz)\n\nReturn the domain periods in each direction.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.domain_is_periodic","page":"BiotSavart","title":"VortexPasta.BiotSavart.domain_is_periodic","text":"BiotSavart.domain_is_periodic(p::ParamsBiotSavart) -> Bool\nBiotSavart.domain_is_periodic(Ls::NTuple) -> Bool\n\nCheck whether the domain is periodic.\n\nReturns true if the domain is periodic in all directions, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#Exported-functions","page":"BiotSavart","title":"Exported functions","text":"","category":"section"},{"location":"modules/BiotSavart/","page":"BiotSavart","title":"BiotSavart","text":"init_cache\nvelocity_on_nodes!\ncompute_on_nodes!","category":"page"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.init_cache","page":"BiotSavart","title":"VortexPasta.BiotSavart.init_cache","text":"init_cache(\n    p::ParamsBiotSavart, fs::AbstractVector{<:AbstractFilament};\n    timer = TimerOutput(\"BiotSavart\"),\n) -> BiotSavartCache\n\nInitialise caches for computing Biot–Savart integrals.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.velocity_on_nodes!","page":"BiotSavart","title":"VortexPasta.BiotSavart.velocity_on_nodes!","text":"velocity_on_nodes!(\n    vs::AbstractVector{<:AbstractVector{<:Vec3}},\n    cache::BiotSavartCache,\n    fs::AbstractVector{<:AbstractFilament},\n) -> vs\n\nCompute velocity induced by vortex filaments on filament nodes.\n\nVelocities induced by vortex filaments fs are written to vs.\n\nThis is the same as calling compute_on_nodes! when only the velocity is needed.\n\nUsually, fs is a vector containing all the vortex filaments in the system. In that case, vs must be a vector of vectors, which will contain the velocities of all filament nodes. The length of vs[i] must be equal to the number of nodes in the filament fs[i].\n\nThe vector of velocities where the output will be written may be initialised using one of the following lines (all are exactly equivalent):\n\nvs = map(similar ∘ nodes, fs)\nvs = [similar(nodes(f)) for f ∈ fs]\nvs = similar.(nodes.(fs))\n\nwhich initialise a velocity vector for each node of each filament (see also nodes).\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.compute_on_nodes!","page":"BiotSavart","title":"VortexPasta.BiotSavart.compute_on_nodes!","text":"compute_on_nodes!(\n    fields::NamedTuple{Names, NTuple{N, V}},\n    cache::BiotSavartCache,\n    fs::AbstractVector{<:AbstractFilament};\n    LIA = Val(true),\n    shortrange = true,\n    longrange = true,\n    callback_vorticity = identity,\n) where {Names, N, V <: AbstractVector{<:VectorOfVec}}\n\nCompute velocity and/or streamfunction on filament nodes.\n\nThe first argument contains one or more output fields to compute. It is usually of length 1 or 2, and can contain fields named velocity and streamfunction.\n\nFor example, to compute both velocity and streamfunction on the nodes of filaments fs:\n\n# Initialise fields to compute (vectors of vectors)\nvs = map(similar ∘ nodes, fs)  # one velocity vector per filament node\nψs = map(similar, vs)\n\n# The first argument to `compute_on_nodes!` must have the following form.\n# One can also choose to pass just one of the two fields.\nfields = (;\n    velocity = vs,\n    streamfunction = ψs,\n)\n\ncache = BiotSavart.init_cache(...)\ncompute_on_nodes!(fields, cache, fs)\n\nExtended help\n\nDisabling local terms / computing only local terms\n\nOne may disable computation of the locally-induced velocity and streamfunction (LIA term) by passing LIA = Val(false). Conversely, one can pass LIA = Val(:only) to compute only the LIA term. This can be useful for splitting the induced filament velocities/streamfunctions onto local and non-local parts.\n\nDisabling short-range or long-range interactions\n\nIt is also possible to disable the short-range or long-range component of Ewald splitting, if one only wants to compute one of the two components. To do this, pass either shortrange = false or longrange = false.\n\nNote that the short-range component includes the local (LIA) term as well as the short-range correction term for long-range interactions. Therefore, setting shortrange = false disables both these terms.\n\nAccessing vorticity in Fourier space\n\nThe computation of long-range quantities involves estimating the Fourier coefficients of the vorticity field associated to the vortex filaments. These coefficients are truncated to some maximum wavenumber k_textmax in each Cartesian direction. This information can be useful for other things, for instance computing energy spectra.\n\nOne can use the callback_vorticity argument to access the vorticity in Fourier space, before it is replaced by the coefficients of streamfunction and/or velocity. This argument should be a function callback_vorticity(cache) which takes a LongRangeCache. The callback should not modify anything inside the cache, or otherwise the streamfunction and velocity computed by this function will likely be wrong. Of course, this callback will be ignored if long-range computations are disabled.\n\nNote that, when the callback is called, the vorticity coefficients in cache.common.uhat don't have the right physical dimensions as they have not yet been multiplied by ΓV (where V is the volume of a unit cell). Note that ΓV is directly available in cache.common.ewald_prefactor. Besides, the vorticity coefficients at this stage have not yet been Gaussian-filtered according to Ewald's method.\n\nAn example of how to compute the (large-scale) kinetic energy associated to the Fourier-truncated vorticity field:\n\nusing Adapt: adapt  # useful in case FFTs are computed on the GPU\n\nE_from_vorticity = Ref(0.0)  # \"global\" variable updated when calling compute_on_nodes!\n\nfunction callback_vorticity(cache::LongRangeCache)\n    (; wavenumbers_d, uhat_d, ewald_prefactor,) = cache.common\n    # For simplicity, copy data to the CPU if it's on the GPU.\n    wavenumbers = adapt(Array, wavenumbers_d)\n    uhat = adapt(Array, uhat_d)\n    with_hermitian_symmetry = BiotSavart.has_real_to_complex(cache)  # this depends on the long-range backend\n    @assert with_hermitian_symmetry == wavenumbers[1][end] > 0\n    γ² = ewald_prefactor^2  # = (Γ/V)^2 [prefactor not included in the vorticity]\n    E = 0.0\n    for I ∈ CartesianIndices(uhat)\n        k⃗ = map(getindex, wavenumbers, Tuple(I))\n        kx = k⃗[1]\n        factor = (!with_hermitian_symmetry || kx == 0) ? 0.5 : 1.0\n        k² = sum(abs2, k⃗)\n        if !iszero(k²)\n            ω⃗ = uhat[I]  # Fourier coefficient of the vorticity\n            E += γ² * factor * sum(abs2, ω⃗) / k²\n        end\n    end\n    E_from_vorticity[] = E  # update value of \"global\" variable\n    nothing\nend\n\ncompute_on_nodes!(...; callback_vorticity)\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#Other-convenience-functions","page":"BiotSavart","title":"Other convenience functions","text":"","category":"section"},{"location":"modules/BiotSavart/","page":"BiotSavart","title":"BiotSavart","text":"kelvin_wave_period","category":"page"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.kelvin_wave_period","page":"BiotSavart","title":"VortexPasta.BiotSavart.kelvin_wave_period","text":"BiotSavart.kelvin_wave_period(p::ParamsBiotSavart, λ::Real) -> Real\n\nReturn the period T(λ) associated to Kelvin waves of wavelength λ.\n\nThis can be convenient for setting the timestep dt associated to a filament discretisation distance δ. The timestep should typically be proportional to the period of the Kelvin waves of wavelength δ.\n\nThe Kelvin wave period is T(λ) = 2πω(k) where k = 2πλ is the wavenumber associated to λ and ω(k) is the Kelvin wave dispersion relation:\n\nω(k) = fracΓ k^24π left\n  lnleft( frac2k a right) - γ + frac12 - Δ\nright\n\nwhere γ  05772 is the Euler–Mascheroni constant.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#Short-range-interactions","page":"BiotSavart","title":"Short-range interactions","text":"","category":"section"},{"location":"modules/BiotSavart/#Backends","page":"BiotSavart","title":"Backends","text":"","category":"section"},{"location":"modules/BiotSavart/","page":"BiotSavart","title":"BiotSavart","text":"ShortRangeBackend\nNaiveShortRangeBackend\nCellListsBackend","category":"page"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.ShortRangeBackend","page":"BiotSavart","title":"VortexPasta.BiotSavart.ShortRangeBackend","text":"ShortRangeBackend\n\nAbstract type denoting the backend used for computing short-range interactions.\n\nImplemented backends\n\nCellListsBackend: most efficient when the cutoff radius is much smaller than the domain size. Can only be used with periodic boundary conditions.\nNaiveShortRangeBackend: usually less efficient as it needs to compute distances between all pairs of locations.\n\nExtended help\n\nImplementation details\n\nA BACKEND <: ShortRangeBackend must implement the function:\n\ninit_cache_short(c::ParamsCommon, p::ParamsShortRange{<:BACKEND}, fs::AbstractVector{<:AbstractFilament}, to::TimerOutput)\n\nwhich should return a ShortRangeCache.\n\nIt may also implement the function max_cutoff_distance.\n\n\n\n\n\n","category":"type"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.NaiveShortRangeBackend","page":"BiotSavart","title":"VortexPasta.BiotSavart.NaiveShortRangeBackend","text":"NaiveShortRangeBackend <: ShortRangeBackend\n\nNaive computation of short-range interactions.\n\n\n\n\n\n","category":"type"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.CellListsBackend","page":"BiotSavart","title":"VortexPasta.BiotSavart.CellListsBackend","text":"CellListsBackend <: ShortRangeBackend\nCellListsBackend(nsubdiv::Int = 1)\n\nCompute short-range interactions using the cell lists algorithm.\n\nThis backend can be significantly faster than the NaiveShortRangeBackend when the cutoff distance r_cut is much smaller than the domain period L (roughly when r_cut ≲ L / 10).\n\nOptionally, one can choose to subdivide each cell (of size ≈ r_cut) onto nsubdiv subcells. In practice, a value of 2 or 3 can significantly improve performance compared to no subdivision (1).\n\nNote that, with this backend, the cutoff distance must satisfy r_cut ≤ M / (2M + 1) * L where M = nsubdiv.\n\nThis backend does not support non-periodic domains.\n\nSee PeriodicCellList and Wikipedia for more details.\n\n\n\n\n\n","category":"type"},{"location":"modules/BiotSavart/#Internals","page":"BiotSavart","title":"Internals","text":"","category":"section"},{"location":"modules/BiotSavart/","page":"BiotSavart","title":"BiotSavart","text":"ShortRangeCache\nmax_cutoff_distance\ninit_cache_short\nprocess_point_charges!\nadd_short_range_fields!\nlocal_self_induced_velocity\nlocal_self_induced\nnearby_charges","category":"page"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.ShortRangeCache","page":"BiotSavart","title":"VortexPasta.BiotSavart.ShortRangeCache","text":"ShortRangeCache\n\nAbstract type describing the storage of data required to compute short-range interactions.\n\nThe init_cache_short function returns a concrete instance of a ShortRangeCache.\n\nInterface\n\nFields\n\nThe following fields must be included in a cache:\n\nparams :: ParamsShortRange parameters for short-range computations;\nto :: TimerOutput for measuring time spent on different functions.\n\n\n\n\n\n","category":"type"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.max_cutoff_distance","page":"BiotSavart","title":"VortexPasta.BiotSavart.max_cutoff_distance","text":"max_cutoff_distance(::ShortRangeBackend, L::Real) -> r\nmax_cutoff_distance(::ShortRangeBackend, Ls::NTuple{3, Real}) -> r\n\nReturn the maximum cut-off distance r_cut allowed by the backend for a given domain period L.\n\nThis is usually close to L/2, but the actual value can depend on implementation details of the backend. For example, the CellListsBackend requires a slightly smaller distance, in the range L/3 ≤ r_max < L/2 depending on the backend parameters.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.init_cache_short","page":"BiotSavart","title":"VortexPasta.BiotSavart.init_cache_short","text":"init_cache_short(\n    pc::ParamsCommon, p::ParamsShortRange,\n    fs::AbstractVector{<:AbstractFilament},\n    to::TimerOutput,\n) -> ShortRangeCache\n\nInitialise the cache for the short-range backend defined in p.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.process_point_charges!","page":"BiotSavart","title":"VortexPasta.BiotSavart.process_point_charges!","text":"process_point_charges!(c::ShortRangeCache, data::PointData)\n\nProcess list of point charges.\n\nThis is useful for short-range backends like CellListsBackend, which needs to\n\nMust be called after add_point_charges! and before computing any short-range quantities (using add_short_range_fields!).\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.add_short_range_fields!","page":"BiotSavart","title":"VortexPasta.BiotSavart.add_short_range_fields!","text":"add_short_range_fields!(\n    fields::NamedTuple{Names, NTuple{N, V}},\n    cache::ShortRangeCache,\n    f::AbstractFilament;\n    LIA = Val(true),\n)\n\nCompute short-range Biot-Savart integrals.\n\nAdds the results onto fields. See compute_on_nodes! for more details.\n\nSetting LIA = Val(false) allows to disable computation of the localised induction approximation (LIA) term. In that case, that term should be computed separately using local_self_induced.\n\nBefore calling this function, one must first call add_point_charges! and then process_point_charges!.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.local_self_induced_velocity","page":"BiotSavart","title":"VortexPasta.BiotSavart.local_self_induced_velocity","text":"local_self_induced_velocity(\n    f::AbstractFilament, i::Int, [prefactor::Real];\n    a::Real, [Γ::Real],\n    Δ = 0.25, quad = nothing, fit_circle = false,\n    segment_fraction = nothing,\n)\n\nCompute local self-induced velocity of filament node f[i].\n\nThis corresponds to the LIA term (localised induction approximation).\n\nThis is the same as local_self_induced(Velocity(), f, i, [prefactor]; kwargs...). See also local_self_induced.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.local_self_induced","page":"BiotSavart","title":"VortexPasta.BiotSavart.local_self_induced","text":"local_self_induced(\n    q::OutputField, f::AbstractFilament, i::Int, [prefactor::Real];\n    a::Real, Δ::Real = 0.25, segment_fraction = nothing, quad = nothing, [Γ],\n)\n\nCompute localised induction approximation (LIA) term at node f[i].\n\nPossible output fields to be passed as first argument are Velocity() and Streamfunction().\n\nOne must pass either the circulation Γ as a keyword argument, or a precomputed prefactor which is usually equal to Γ / 4π (both for velocity and streamfunction).\n\nMandatory arguments\n\nthe vortex core size a as a keyword argument;\neither the vortex circulation Γ as a keyword argument, or the precomputed prefactor Γ / 4π as a positional argument.\n\nOptional arguments\n\nthe optional parameter Δ sets the effect of the vorticity profile (see ParamsBiotSavart for details);\nthe optional parameter segment_fraction can be used to indicate that the LIA term should only be computed over a fraction of the segments neighbouring the node f[i]. In that case, it should be a real number in (0 1 (where 1 corresponds to integrating over the full segments, which the default);\na quadrature rule can be passed via quad, which can improve the estimation of the LIA term and the stability of the solver (even a 1-point quadrature rule can importantly improve stability!);\nif quad = nothing, one may set fit_circle = true to estimate the binormal vector by fitting a circle passing through 3 neighbouring nodes (as done in Schwarz PRB 1985), instead of using local derivatives. For now, this is only implemented for q = Velocity(), and it may be removed in the future.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.nearby_charges","page":"BiotSavart","title":"VortexPasta.BiotSavart.nearby_charges","text":"nearby_charges(c::ShortRangeCache, x⃗::Vec3)\n\nReturn an iterator over the charges that are \"close\" to the location x⃗.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#Long-range-interactions","page":"BiotSavart","title":"Long-range interactions","text":"","category":"section"},{"location":"modules/BiotSavart/#Backends-2","page":"BiotSavart","title":"Backends","text":"","category":"section"},{"location":"modules/BiotSavart/","page":"BiotSavart","title":"BiotSavart","text":"LongRangeBackend\nNonuniformFFTsBackend\nFINUFFTBackend\nCuFINUFFTBackend\nExactSumBackend","category":"page"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.LongRangeBackend","page":"BiotSavart","title":"VortexPasta.BiotSavart.LongRangeBackend","text":"LongRangeBackend\n\nAbstract type denoting the backend to use for computing long-range interactions.\n\nImplemented backends\n\nNonuniformFFTsBackend: estimates long-range interactions via the non-uniform fast Fourier transform (NUFFT) using the NonuniformFFTs.jl package;\nFINUFFTBackend: estimates long-range interactions via the NUFFT using the FINUFFT library;\nCuFINUFFTBackend: estimates long-range interactions via the NUFFT using the CUDA implementation of the FINUFFT library. CUDA.jl must be loaded before using this backend (CUDA devices only);\nExactSumBackend: computes long-range interactions using exact Fourier sums. This is really inefficient and should only be used for testing.\n\nExtended help\n\nImplementation details\n\nThe following functions must be implemented by a BACKEND <: LongRangeBackend:\n\ninit_cache_long_ewald(c::ParamsCommon, p::ParamsLongRange{<:BACKEND}, to::TimerOutput) -> LongRangeCache.\nhas_real_to_complex,\nexpected_period (optional),\nfolding_limits (optional),\nKernelAbstractions.get_backend (required for GPU-based backends).\n\n\n\n\n\n","category":"type"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.NonuniformFFTsBackend","page":"BiotSavart","title":"VortexPasta.BiotSavart.NonuniformFFTsBackend","text":"NonuniformFFTsBackend <: LongRangeBackend\n\nCompute long-range interactions using the NonuniformFFTs.jl package.\n\nThis backend may be faster than other NUFFT-based backends since it allows real valued non-uniform data, meaning that we can use real-to-complex FFTs to accelerate computations.\n\nTransforms can be performed either on the CPU (parallelised with threads, default) or on a single GPU (in principle any kind of GPU should work, but only CUDA has been tested). This must be set via the device argument (see below).\n\nOptional arguments\n\nThe signature of NonuniformFFTsBackend is:\n\nNonuniformFFTsBackend([device = CPU()]; σ = 1.5, m = HalfSupport(4), kws...)\n\nwhere all arguments are passed to NonuniformFFTs.jl.\n\nUsing a GPU\n\nTransforms are run on all available CPUs by default. To use a GPU, pass the corresponding KernelAbstractions.jl backend as the only positional argument. For example, to use a CUDA device:\n\nusing CUDA\nbackend_long = NonuniformFFTsBackend(CUDABackend(); kwargs...)\n\nOn AMD GPUs the following should work:\n\nusing AMDGPU\nbackend_long = NonuniformFFTsBackend(ROCBackend(); kwargs...)\n\nKeyword arguments\n\nSome relevant keyword arguments are:\n\nσ = 1.5: upsampling factor, which must be larger than 1. Usual values are between 1.25 (smaller FFTs, less accurate) and 2.0 (larger FFTs, more accurate). Other values such as 1.5 (default) also work;\nm = HalfSupport(4): the half-width of the NUFFT kernels. Larger means higher accuracy;\nfftw_flags = FFTW.MEASURE: flags passed to the FFTW planner (ignored on GPU devices).\n\nThe default parameters (σ = 1.5, m = HalfSupport(4)) correspond to a relative NUFFT tolerance of 10^-6.\n\nSee the NonuniformFFTs.jl docs for a full list of possible keyword arguments.\n\n\n\n\n\n","category":"type"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.FINUFFTBackend","page":"BiotSavart","title":"VortexPasta.BiotSavart.FINUFFTBackend","text":"FINUFFTBackend <: LongRangeBackend\n\nCompute long-range interactions using the FINUFFT.jl package.\n\nTo use this backend, one first needs to load FINUFFT by doing\n\nusing FINUFFT\n\nThis package provides a Julia interface to the FINUFFT C++ library, which enables efficient and accurate computation of non-uniform fast Fourier transforms (NUFFTs) based on an \"exponential of a semi-circle\" kernel.\n\nComputations can be parallelised using threads.\n\nOptional arguments\n\nThe signature of FINUFFTBackend is:\n\nFINUFFTBackend(; tol = 1.0e-6, kws...)\n\nwhere all arguments are passed to FINUFFT.\n\nSome relevant options are:\n\ntol = 1.0e-6 tolerance in NUFFT computations;\nupsampfac = 1.25 upsampling factor. Must be either 1.25 (usually faster) or 2.0 (required to exceed 9 digits of accuracy);\nnthreads = Threads.nthreads() number of threads to use. By default, all threads available to Julia are used;\nfftw = FFTW.MEASURE flags passed to the FFTW planner.\n\nOther options described in the FINUFFT docs and not listed above are also accepted.\n\n\n\n\n\n","category":"type"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.CuFINUFFTBackend","page":"BiotSavart","title":"VortexPasta.BiotSavart.CuFINUFFTBackend","text":"CuFINUFFTBackend <: LongRangeBackend\n\nGPU version of FINUFFTBackend.\n\nTo use this backend, one first needs to load both FINUFFT and CUDA by doing\n\nusing FINUFFT\nusing CUDA\n\nWorks with Nvidia GPUs only.\n\ncompat: Compat\nThe minimal required version of the FINUFFT libraries is 2.3.0-rc1. In previous versions, cuFINUFFT ignores the modeord = 1 option which is needed in our implementation.\n\nOptional arguments\n\nThe signature of CuFINUFFTBackend is:\n\nCuFINUFFTBackend(; tol = 1.0e-6, kws...)\n\nwhere all arguments are passed to cuFINUFFT.\n\nSome relevant options are:\n\ntol = 1.0e-6 tolerance in NUFFT computations;\nupsampfac = 1.25 upsampling factor. Should be either 1.25 or 2.0;\ngpu_device::CUDA.CuDevice: useful if multiple GPUs are available. By default the currently active CUDA device is used, i.e. gpu_device = CUDA.device().\n\nSee the cuFINUFFT docs for details and other possible options.\n\n\n\n\n\n","category":"type"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.ExactSumBackend","page":"BiotSavart","title":"VortexPasta.BiotSavart.ExactSumBackend","text":"ExactSumBackend <: LongRangeBackend\n\nCompute long-range interactions \"exactly\" (up to filament discretisation errors) using sums of Fourier series across non-uniform points.\n\nThis should only be used for testing, as it is very slow and scales very badly with the number of non-uniform points.\n\n\n\n\n\n","category":"type"},{"location":"modules/BiotSavart/#Internals-2","page":"BiotSavart","title":"Internals","text":"","category":"section"},{"location":"modules/BiotSavart/","page":"BiotSavart","title":"BiotSavart","text":"LongRangeCache\nNullLongRangeCache\ninit_cache_long\nexpected_period\nfolding_limits\nset_num_points!\nadd_point_charges!\nhas_real_to_complex\ncompute_vorticity_fourier!\nto_smoothed_streamfunction!\nto_smoothed_velocity!\ninterpolate_to_physical!\ntransform_to_fourier!\nsimilar(::LongRangeCache, ::Dims{3})","category":"page"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.LongRangeCache","page":"BiotSavart","title":"VortexPasta.BiotSavart.LongRangeCache","text":"LongRangeCache\n\nAbstract type describing the storage of data required to compute long-range interactions.\n\nThe init_cache_long function returns a concrete instance of a LongRangeCache (or NullLongRangeCache(), if long-range computations were disabled by setting α = Zero()).\n\nUseful fields\n\nMost useful fields of a cache::LongRangeCache are in the cache.common field. In particular, cache.common contains the fields:\n\nwavenumbers_d::NTuple{3, AbstractVector}: Fourier wavenumbers in each direction;\nuhat_d::StructArray{Vec3{Complex{T}}, 3}: a full vector field in Fourier space;\npointdata_d::PointData: data associated to vector charges applied on non-uniform points. These are available in pointdata_d.charges and pointdata_d.points;\newald_prefactor::Real: the quantity Γ  V where V is the volume of a periodic cell.\n\nThe _d suffixes means that data is on the computing device associated to the long-range backend (i.e. on the GPU for GPU-based backends).\n\nExtended help\n\nImplementation details\n\nFields\n\nAll caches must include a common <: LongRangeCacheCommon field which contains common definitions for all backends.\n\nFunctions\n\nThe following functions must be implemented by a cache:\n\ntransform_to_fourier!,\ninterpolate_to_physical!.\n\n\n\n\n\n","category":"type"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.NullLongRangeCache","page":"BiotSavart","title":"VortexPasta.BiotSavart.NullLongRangeCache","text":"NullLongRangeCache <: LongRangeCache\n\nDummy cache type returned by init_cache_long when long-range computations are disabled.\n\nThis is the case when the Ewald splitting parameter α is set to Zero().\n\n\n\n\n\n","category":"type"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.init_cache_long","page":"BiotSavart","title":"VortexPasta.BiotSavart.init_cache_long","text":"init_cache_long(p::ParamsLongRange, pointdata::PointData, [to::TimerOutput]) -> LongRangeCache\n\nInitialise the cache for the long-range backend defined in p.\n\nNote that, if pc.α === Zero(), then long-range computations are disabled and this returns a NullLongRangeCache.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.expected_period","page":"BiotSavart","title":"VortexPasta.BiotSavart.expected_period","text":"expected_period(::LongRangeBackend) -> Union{Nothing, Real}\n\nDomain period expected by the backend.\n\nThis is used for rescaling input coordinates to the requirements of the backend. For instance, FINUFFT assumes a period 2π, and therefore coordinates are rescaled if the input data has a period different from 2π.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.folding_limits","page":"BiotSavart","title":"VortexPasta.BiotSavart.folding_limits","text":"folding_limits(::LongRangeBackend) -> Union{Nothing, NTuple{2, Real}}\n\nDomain limits required by the backend.\n\nThis is used for folding input coordinates so that they are within the limits expected by the backend. For instance, FINUFFT requires coordinates to be in the -3π 3π interval.\n\nNote that, if a backend defines folding_limits, then it must also define expected_period.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.set_num_points!","page":"BiotSavart","title":"VortexPasta.BiotSavart.set_num_points!","text":"set_num_points!(data::PointData, N::Integer)\n\nSet the total number of non-uniform points that the cache must hold.\n\nThis will reallocate space to make all points fit in the cache. It will also reset the contributions of previously-added charges.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.add_point_charges!","page":"BiotSavart","title":"VortexPasta.BiotSavart.add_point_charges!","text":"add_point_charges!(data::PointData, fs::AbstractVector{<:AbstractFilament}, quad::StaticSizeQuadrature)\nadd_point_charges!(cache::LongRangeCache, fs::AbstractVector{<:AbstractFilament})\n\nAdd vector charges at multiple non-uniform locations.\n\nThis can be used for both short-range and long-range computations.\n\nIn the case of long-range computations, this must be done before type-1 NUFFTs, to transform from non-uniform data in physical space to uniform data in Fourier space. It must be called before compute_vorticity_fourier!.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.has_real_to_complex","page":"BiotSavart","title":"VortexPasta.BiotSavart.has_real_to_complex","text":"has_real_to_complex(::LongRangeBackend) -> Bool\nhas_real_to_complex(::ParamsLongRange) -> Bool\nhas_real_to_complex(::LongRangeCacheCommon) -> Bool\nhas_real_to_complex(::LongRangeCache) -> Bool\n\nCheck whether the backend performs real-to-complex (fast) Fourier transforms.\n\nIf true, it means that input non-uniform data in physical space can be real-valued, and that uniform data in Fourier space only contains half the total number of modes along the first dimension to account for Hermitian symmetry.\n\nThis function is useful in particular for:\n\nknowing which kind of non-uniform data (vorticities) one must give to the backend;\nknowing how to interpret Fourier-space data, e.g. to compute Fourier spectra.\n\nThis function returns false for backends such as FINUFFTBackend, as these require complex input data and don't take advantage of Hermitian symmetry.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.compute_vorticity_fourier!","page":"BiotSavart","title":"VortexPasta.BiotSavart.compute_vorticity_fourier!","text":"compute_vorticity_fourier!(cache::LongRangeCache)\n\nEstimate vorticity in Fourier space.\n\nThe vorticity, written to cache.common.uhat_d, is estimated using some variant of non-uniform Fourier transforms (depending on the chosen backend).\n\nNote that this function doesn't perform smoothing over the vorticity using the Ewald operator. Moreover, the resulting vorticity doesn't have the right dimensions, as it must be multiplied by ΓV (where Γ is the circulation and V is the volume of a periodic cell) to have dimensions T^-1. In fact, this factor is included in the Ewald operator (see to_smoothed_streamfunction! for details).\n\nMust be called after add_point_charges!.\n\nAfter calling this function, one may want to use to_smoothed_streamfunction! and/or to_smoothed_velocity! to obtain the respective fields.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.to_smoothed_streamfunction!","page":"BiotSavart","title":"VortexPasta.BiotSavart.to_smoothed_streamfunction!","text":"to_smoothed_streamfunction!(cache::LongRangeCache)\n\nConvert Fourier-transformed vorticity field to coarse-grained streamfunction field in Fourier space.\n\nThis operation can be simply written as:\n\nhatbmψ_α(bmk) = ϕ_α(bmk)  hatbmω(bmk)\n\nwhere\n\nϕ_α(k) = fracΓV  frace^-k^2  4α^2k^2\n\nis the Ewald operator. The effect of this operator is to:\n\ninvert the Laplacian in -² bmψ = bmomega;\nsmoothen the fields according to the Ewald parameter α (an inverse length scale);\nrescale values by the vortex circulation Γ and the volume V of a periodic cell so that the streamfunction has the right units (L^2 T^-1).\n\nThis function should be called after compute_vorticity_fourier!. If one only needs the velocity and not the streamfunction, one can also directly call to_smoothed_velocity!.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.to_smoothed_velocity!","page":"BiotSavart","title":"VortexPasta.BiotSavart.to_smoothed_velocity!","text":"to_smoothed_velocity!(cache::LongRangeCache)\n\nConvert Fourier-transformed vorticity field to coarse-grained velocity field in Fourier space.\n\nIf called right after compute_vorticity_fourier!, this function performs the operation:\n\nhatbmv_α(bmk) = i bmk  ϕ_α(bmk)   hatbmω(bmk)\n\nwhere ϕ_α is the Ewald operator defined in to_smoothed_streamfunction!.\n\nOptionally, if one is also interested in the streamfunction, one can call to_smoothed_streamfunction! before this function. In that case, the cache already contains the smoothed streamfunction, and only the curl operator (i bmk ) is applied by this function.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.interpolate_to_physical!","page":"BiotSavart","title":"VortexPasta.BiotSavart.interpolate_to_physical!","text":"interpolate_to_physical!([output::StructVector{<:Vec3},] cache::LongRangeCache)\n\nPerform type-2 NUFFT to interpolate values in cache.common.uhat_d to non-uniform points in physical space.\n\nResults are written to the output vector, which defaults to cache.pointdata_d.charges.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.transform_to_fourier!","page":"BiotSavart","title":"VortexPasta.BiotSavart.transform_to_fourier!","text":"transform_to_fourier!(cache::LongRangeCache)\n\nTransform stored non-uniform data to Fourier space.\n\nThis usually corresponds to a type-1 NUFFT.\n\nNon-uniform data must be first added via add_point_charges!.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#Base.similar-Tuple{LongRangeCache, Tuple{Int64, Int64, Int64}}","page":"BiotSavart","title":"Base.similar","text":"Base.similar(cache::LongRangeCache, Ns::Dims{3}) -> LongRangeCache\n\nCreate a LongRangeCache similar to an existent one, but possibly holding a different amount of wavenumbers in Fourier space.\n\nIn principle, the grid resolution Ns can be different from the original one (cache.common.params.Ns). This can be useful for computing high-resolution fields in Fourier space (e.g. for extending the data to higher wavenumbers than allowed by the original cache).\n\nFor convenience, point data already in cache.common.pointdata_d is copied to the new cache. This means that, if one already filled the original cache using add_point_charges!, then one can directly call transform_to_fourier! with the new cache to get the vorticity field in Fourier space at the wanted resolution Ns.\n\n\n\n\n\n","category":"method"},{"location":"modules/BiotSavart/#KernelAbstractions-utils","page":"BiotSavart","title":"KernelAbstractions utils","text":"","category":"section"},{"location":"modules/BiotSavart/","page":"BiotSavart","title":"BiotSavart","text":"KernelAbstractions.jl is used to write generic code which works on CPUs and different kinds of GPUs.","category":"page"},{"location":"modules/BiotSavart/","page":"BiotSavart","title":"BiotSavart","text":"ka_generate_kernel\nKernelAbstractions.get_backend","category":"page"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.ka_generate_kernel","page":"BiotSavart","title":"VortexPasta.BiotSavart.ka_generate_kernel","text":"ka_generate_kernel(kernel, backend::KA.Backend, x::AbstractArray; [workgroupsize])\nka_generate_kernel(kernel, backend::KA.Backend, ndrange::Dims; [workgroupsize])\n\nGenerate statically sized KA kernel.\n\nIn this context, \"statically sized\" means that the kernel will be specifically compiled for the dimensions of the array x, and will be recompiled if an array of a different size is used later.\n\nHere kernel is a KA kernel (a Julia function) annotated with the @kernel macro.\n\nBy default, the workgroupsize is determined automatically and may depend on the actual backend (CPU, GPU) and on the array dimensions ndrange = size(x).\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#KernelAbstractions.get_backend","page":"BiotSavart","title":"KernelAbstractions.get_backend","text":"KernelAbstractions.get_backend(backend::LongRangeBackend) -> KernelAbstractions.Backend\nKernelAbstractions.get_backend(cache::LongRangeCache) -> KernelAbstractions.Backend\n\nGet KernelAbstractions (KA) backend associated to a given long-range backend.\n\nnote: Note\nThe word \"backend\" means two different things here! For KA, it refers to the device where kernels are executed (e.g. CPU, CUDABackend, ...).\n\nBy default this returns KA.CPU(static = true), meaning that things are run on the CPU using threads, and that a static thread assignment is used.\n\n\n\n\n\n","category":"function"},{"location":"modules/BiotSavart/#Internals-3","page":"BiotSavart","title":"Internals","text":"","category":"section"},{"location":"modules/BiotSavart/","page":"BiotSavart","title":"BiotSavart","text":"BiotSavartCache\nbackground_vorticity_correction!","category":"page"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.BiotSavartCache","page":"BiotSavart","title":"VortexPasta.BiotSavart.BiotSavartCache","text":"BiotSavartCache\n\nIncludes arrays and data required for computation of Biot–Savart integrals.\n\nFields\n\npointdata: contains vector values at points in space. This is used for both short-range and long-range computations;\nshortrange: cache associated to short-range computations;\nlongrange: cache associated to long-range computations. It can be NullLongRangeCache() in case the Ewald parameter α was set to Zero();\nto: a TimerOutput instance for measuring the time spent on different functions.\n\n\n\n\n\n","category":"type"},{"location":"modules/BiotSavart/#VortexPasta.BiotSavart.background_vorticity_correction!","page":"BiotSavart","title":"VortexPasta.BiotSavart.background_vorticity_correction!","text":"background_vorticity_correction!(\n    fields::NamedTuple, fs::AbstractVector{<:AbstractFilament}, params::ParamsBiotSavart,\n)\n\nCorrect computed fields in case the mean filament vorticity is non-zero.\n\nThis ensures that results do not depend on the Ewald splitting parameter α when the filament \"charge\" is non-zero in a periodic domain.\n\nIn practice, as detailed below, this function only corrects the short-range streamfunction, as the velocity is not affected by the background vorticity, and long-range corrections are done implicitly in Fourier space.\n\nnote: Note\nThis function is automatically called by compute_on_nodes! and should never be called manually. This documentation is only included for information purposes.\n\nExtended help\n\nThe mean vorticity associated to the filaments is given by\n\n bmω  = -fracΓV _mathcalC mathrmdbms\n\nwhere V = L^3 is the periodic domain volume.\n\nThis quantity is always zero when all filaments are closed. It can be non-zero if there are infinite unclosed filaments which are not compensated by oppositely-oriented infinite filaments.\n\nWhen the mean filament vorticity is non-zero, one must compensate it by adding a uniform background vorticity bmω_textback = - bmω , so that the total circulation around the volume is zero.\n\nIn practice, in the long-range component of Ewald summation, this compensation is done implicitly by setting the zero mode hatbmomega(bmk = bm0) = bm0. As for the short-range component, only the streamfunction needs to be corrected, while the velocity is not affected by the background vorticity.\n\nThe correction to the short-range streamfunction is given by\n\nbmψ^_textback\n= fracbmω_textback4π _mathbbR^3 fracoperatornameerfc(αbmr)bmr  mathrmd^3bmr\n= fracbmω_textback4 α^2\n\nTherefore, this function simply adds this short-range correction to the streamfunction.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"EditURL = \"../../literate/tutorials/01-vortex_ring.jl\"","category":"page"},{"location":"tutorials/01-vortex_ring/#tutorial-vortex-ring","page":"Vortex ring","title":"Vortex ring","text":"","category":"section"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"The following tutorial goes through the simulation of a single vortex ring propagating due to its self-induced propulsion.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"The aim is to show how one can:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Discretise a vortex filament using a spatial curve;\ncompute things like the self-induced vortex velocity;\nsimulate the motion of the vortex filament over a time period.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"We assume that VortexPasta and GLMakie have been installed following the instructions in the Installation section. The code in this tutorial should be executed in the same local environment where those packages were installed.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Pages = [\"01-vortex_ring.md\"]\nDepth = 2:3","category":"page"},{"location":"tutorials/01-vortex_ring/#Defining-a-vortex-ring","page":"Vortex ring","title":"Defining a vortex ring","text":"","category":"section"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"The first thing to do is to define a circular vortex ring. In VortexPasta, curves are initialised using the Filaments.init function defined in the VortexPasta.Filaments submodule.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"The most straightforward way of defining an arbitrary curve is by first defining a set of discretisation points (which we also call nodes) and then passing that to Filaments.init. In VortexPasta, a point in 3D space is represented by the Vec3 type (which is nothing else than an SVector from the StaticArrays.jl package).","category":"page"},{"location":"tutorials/01-vortex_ring/#tutorial-vortex-ring-init-filament","page":"Vortex ring","title":"Initialising the ring","text":"","category":"section"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Let's define a set of points discretising a circular ring of radius R living on the plane z = 1 and centred at bmx_0 = 3 3 1:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"using VortexPasta\nusing VortexPasta.Filaments\nusing VortexPasta.Filaments: Vec3\n\nR = 2.0   # radius of the circular ring\nN = 16    # number of discretisation points\nx⃗₀ = Vec3(3.0, 3.0, 1.0)  # ring centre\nθs = range(0, 2π; length = N + 1)[1:N]  # discretisation angles (we exclude θ = 2π)\npoints = [x⃗₀ + R * Vec3(cos(θ), sin(θ), 0) for θ ∈ θs]","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Now that we have defined a set of points, we can create a filament using Filaments.init. Note that this function requires choosing a discretisation method which will be used to interpolate the curve in-between nodes and to estimate curve derivatives. Here we use the QuinticSplineMethod, which represents curves as periodic quintic splines (that is, piecewise polynomials of degree 5):","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"f = Filaments.init(ClosedFilament, points, QuinticSplineMethod())","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Other possible discretisation options are the CubicSplineMethod and FiniteDiffMethod. The latter estimates derivatives at discretisation points using finite differences (based on the locations of neighbouring points), and performs Hermite interpolations using those derivatives to reconstruct the curve in-between nodes.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Besides, note that the first argument (ClosedFilament) is mandatory and is only there to make sure that we're creating a closed (as opposed to an open-ended) filament. This means in particular that the filament will be automatically \"closed\" when evaluated outside of its range of definition 1:N. For example, one has f[1] == f[N + 1]:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"@show f[1] f[N] f[N + 1]\nnothing  # hide","category":"page"},{"location":"tutorials/01-vortex_ring/#Getting-geometric-information-out-of-a-filament","page":"Vortex ring","title":"Getting geometric information out of a filament","text":"","category":"section"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Above we have used the f[i] syntax to obtain the location of a discretisation point. As mentioned, curve locations can also be evaluated in-between discretisation points using interpolation. For instance, to evaluate the curve location at some point in-between nodes i and i + 1, one can call f(i, ζ), where ζ is some real value between 0 and 1. In particular, f(i, 0.5) gives an estimation of the midpoint between both nodes, while f(i, 0.0) and f(i, 1.0) respectively correspond to f[i] and f[i + 1]:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"i = 2\n@show f[i] f(i, 0.0) f(i, 0.5) f(i, 1.0) f[i + 1]\nnothing  # hide","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"A similar syntax can be used to obtain derivatives at discretisation points or in-between them:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"@show f[i] f[i, Derivative(1)] f[i, Derivative(2)]\n@show f(i, 0.5) f(i, 0.5, Derivative(1)) f(i, 0.5, Derivative(2))\nnothing  # hide","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"These derivatives assume that curves are parametrised as bms(t) for t  0 T, and are computed with respect to this parameter. In practice, the parameter t roughly corresponds to the integrated arc length (and thus T is a rough estimation of the total curve length), but this should never be assumed. In particular, the first derivative bmst is tangent to the curve but it's not necessarily unitary (which would be the case if t was the actual arc length ξ).","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"In some cases, one may want to directly obtain geometrically-relevant quantities such as the unit tangent or the curvature vector (see Geometric quantities for definitions and a list of possible quantities):","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"t̂ = f[i, UnitTangent()]       # \"t̂\" can be typed by t\\hat<tab>\nρ⃗ = f[i, CurvatureVector()]   # \"ρ⃗\" can be typed by \\rho<tab>\\vec<tab>\n@show t̂ ρ⃗\nnothing  # hide","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"We can check that both vectors are orthogonal and that their respective norms are 1 and approximately 1R (where R is the vortex ring radius):","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"using LinearAlgebra: norm, ⋅  # the dot product ̇`⋅` can be obtained via \\cdot<tab>\n@show t̂ ⋅ ρ⃗ norm(t̂) norm(ρ⃗) 1/R\nnothing  # hide","category":"page"},{"location":"tutorials/01-vortex_ring/#Plotting-the-filament","page":"Vortex ring","title":"Plotting the filament","text":"","category":"section"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"We can readily plot our vortex ring using Makie. For convenience, VortexPasta overloads the Makie plot and plot! functions to be able to directly plot filaments.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"using GLMakie\nset_theme!(theme_black())\nGLMakie.activate!()  # hide\nMakie.inline!(true)  # hide\nfig = Figure()                         # create an empty figure\nax = Axis3(fig[1, 1]; aspect = :data)  # add an Axis3 for plotting in 3D\nzlims!(ax, 0.5, 1.5)                   # set axis limits in the z direction\nplot!(ax, f)                           # plot filament onto axis\nfig                                    # display the figure","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Note that, by default, the plot simply shows the N filament nodes (circular markers) joined by straight lines. To see how points are actually interpolated in-between nodes we can use the refinement keyword argument:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"fig = Figure()\nax = Axis3(fig[1, 1]; aspect = :data)\nzlims!(ax, 0.5, 1.5)\nplot!(ax, f; refinement = 4)\nfig","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"It is also possible to plot other quantities such as the estimated tangent and curvature vectors along the curve:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"fig = Figure()\nax = Axis3(fig[1, 1]; aspect = :data)\nzlims!(ax, 0.5, 1.5)\nplot!(\n    ax, f;\n    refinement = 4, linewidth = 4, markersize = 12,\n    tangents = true, tangentcolor = :Yellow,         # plot tangent vectors\n    curvatures = true, curvaturecolor = :LightBlue,  # plot curvature vectors\n    arrowwidth = 0.03, arrowscale = 1.2, arrowsize = (1, 1, 1.2) .* 0.1,  # arrow properties\n    vectorpos = 0.5,    # plot vectors at the midpoint in-between nodes\n)\nfig","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"See filamentplot! for more details and for other possible options.","category":"page"},{"location":"tutorials/01-vortex_ring/#Computing-the-vortex-ring-velocity","page":"Vortex ring","title":"Computing the vortex ring velocity","text":"","category":"section"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"An isolated vortex ring of radius R and circulation Γ is known to translate with a velocity (Saffman, 1993):","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"v_textring = fracΓ4πR left ln left(frac8Raright) - Δ right","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"where a is the radius of the vortex core – assumed to be much smaller than R – and Δ is a coefficient which depends on the actual vorticity profile at the core.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"note: Some typical values of Δ\nΔ = 12 for a hollow vortex: ω(r) = ω₀  δ(r - a);\nΔ = 14 for a uniform vorticity distribution: ω(r) = ω₀ for r  a.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"This velocity can be derived by computing the Biot–Savart integral along the circular vortex ring and excluding a very small region (proportional to a) from the integral, in the vicinity of the point of interest, thus avoiding the singularity.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"In VortexPasta, the velocity induced by one or more vortex filaments is computed by the VortexPasta.BiotSavart submodule. The basic steps for computing the velocity induced by a set of vortices on itself is:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Set physical and numerical parameters (ParamsBiotSavart),\ninitialise a \"cache\" containing arrays and data needed for computations (BiotSavart.init_cache),\ncompute filament velocities from their positions (velocity_on_nodes!).","category":"page"},{"location":"tutorials/01-vortex_ring/#Physical-and-numerical-parameters","page":"Vortex ring","title":"Physical and numerical parameters","text":"","category":"section"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Before being able to estimate the vortex ring velocity, we need to set the parameters needed to estimate Biot–Savart integrals. All of the required and optional parameters are described in ParamsBiotSavart.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Relevant physical parameters are of two types:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"vortex properties: circulation Γ, core radius a and core parameter Δ;\ndomain size (or period) L.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Γ = 1.0    # vortex circulation                              || \"Γ\" can be typed by \\Gamma<tab>\na = 1e-8   # vortex core size\nΔ = 1/2    # vortex core parameter (1/2 for a hollow vortex) || \"Δ\" can be typed by \\Delta<tab>\nL = 2π     # domain period (same in all directions in this case)\nnothing  # hide","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Note that here we work with nondimensional quantities, but we could try to relate these physical parameters to actual properties of, say, liquid helium-4. In this case, the vortex core size is a  10^-8textcm and the quantum of circulation is Γ = κ = hm  0997  10^-3textcm^2texts, where h is Planck's constant and m the mass of a helium atom. So the above parameters can be relevant to ^4textHe if one interprets lengths in centimetres and the time unit is about 1000 seconds.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"There are also important numerical parameters which need to be set. See the Parameter selection section for an advice on how to set them.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Following that page, we start by setting the resolution M of the numerical grid used for long-range computations and the accuracy parameter β, and we set the other parameters based on that:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"M = floor(Int, 32 * 2/3)  # we prefer if the FFT size is a power of 2, here M′ = σM = 32 (where σ = 1.5)\nkmax = π * M / L          # this is the maximum resolved wavenumber (the Nyquist frequency)\nβ = 3.5                   # non-dimensional accuracy parameter\nα = kmax / (2β)           # Ewald splitting parameter || \"α\" can be typed by \"\\alpha<tab>\"\nrcut = β / α              # cut-off distance for short-range computations\nrcut / L                  # note: the cut-off distance should be less than half the period L","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Additionally, we can optionally set the parameters for numerical integration. In particular, we can set the quadrature rule used to approximate line integrals within each filament segment (see Numerical integration):","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"quadrature = GaussLegendre(3)  # use 3-point Gauss–Legendre quadrature\nnothing  # hide","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"See GaussLegendre or the Wikipedia page for more details.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Finally, we put all these parameters together in a ParamsBiotSavart object:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"using VortexPasta.BiotSavart\nparams = ParamsBiotSavart(;\n    Γ, α, Δ, a,\n    Ls = (L, L, L),  # same domain size in all directions\n    Ns = (M, M, M),  # same long-range resolution in all directions\n    rcut,\n    quadrature,\n)","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Note that there are a few parameters, namely the short-range and long-range backends, which haven't been discussed yet. These correspond to different ways of computing both components. We leave them here at their default values. See CellListsBackend and NonuniformFFTsBackend for details on the defaults and their parameters.","category":"page"},{"location":"tutorials/01-vortex_ring/#Computing-the-velocity-on-filament-nodes","page":"Vortex ring","title":"Computing the velocity on filament nodes","text":"","category":"section"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"The last thing to do before launching computations is to create a \"cache\" where all data (arrays, …) required for computations are kept. This is in part to avoid making large allocations every time we wish to compute Biot–Savart integrals, which would be quite bad for performance. Luckily, creating a cache is very simple:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"fs = [f]  # note: we need to pass a *vector* of filaments\ncache = BiotSavart.init_cache(params, fs)\nnothing  # hide","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"We can now estimate the velocity of all filament nodes using velocity_on_nodes!. But first we need to allocate the output, which will contain all velocities:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"vs = map(similar ∘ nodes, fs)\n@show summary(vs) summary(vs[1])\nnothing  # hide","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Note that this is a 1-element vector (because we only have 1 filament). Moreover, the element vs[1] is a vector of Vec3 (3-element vectors, specifically velocity vectors in this case), in which the element vs[1][i] will be the velocity of the filament node fs[1][i].","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"To actually fill vs with the velocities of the filament nodes, we call velocity_on_nodes!:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"velocity_on_nodes!(vs, cache, fs)\nvs[1]  # prints the velocities of all nodes of the first (and only) filament","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"We have done our first Biot–Savart calculation! We can see that all nodes have practically zero velocity in the x and y directions, while they all have approximately the same velocity in the z direction. Good news, this is exactly what we expect for a vortex ring!","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"We can compute the mean velocity and quantify the velocity variation along the filament:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"using Statistics: mean, std\nv_mean = mean(vs[1])\nv_std = std(vs[1])\nv_std_normalised = v_std / norm(v_mean)  # normalised standard deviation\n@show v_mean v_std v_std_normalised\nnothing  # hide","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Note that there are some (very small) fluctuations of the velocity about the mean. As discussed and verified further below, this is explained by periodicity effects, as the vortex ring is affected by its periodic images. Furthermore, different points along the ring are at different distances from the images, and therefore the velocity induced by the images varies slightly as we move along the vortex ring. In other words, periodicity introduces a slight anisotropy on the behaviour of the vortex ring.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"To visualise things, it is easy to plot the filament with the node velocities:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"fig = Figure()\nax = Axis3(fig[1, 1]; aspect = :data)\nzlims!(ax, 0.5, 1.5)\nplot!(\n    ax, fs[1], vs[1];\n    refinement = 4,\n    arrowscale = 0.2, arrowwidth = 0.02, arrowsize = (0.08, 0.08, 0.10),\n)\nfig","category":"page"},{"location":"tutorials/01-vortex_ring/#Comparison-with-analytical-expression","page":"Vortex ring","title":"Comparison with analytical expression","text":"","category":"section"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"We can finally compare the filament velocity with the analytical vortex ring velocity according to the expression at the start of this section:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"v_ring = Γ / (4π * R) * (log(8R / a) - Δ)\nvz = v_mean[3]\nrelative_difference = (v_ring - vz) / v_ring\n@show v_ring vz relative_difference\nnothing  # hide","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"We can see that we're quite close, and that the relative difference between the two is of the order of 5%. This is already nice, but note that most of the difference may be explained by periodicity effects, as shown in more detail in the next section. Indeed, the vortex ring is not alone, but is also affected by its periodic images.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"We can visualise this by plotting the ring and its nearest 26 periodic images (actually there's an infinity of them!):","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"fig = Figure()\nax = Axis3(fig[1, 1]; aspect = :data)\nhidespines!(ax)\nhidexdecorations!(ax; label = false)\nhideydecorations!(ax; label = false)\nhidezdecorations!(ax; label = false)\nfimage = copy(f)\nplot!(ax, f; refinement = 4, markersize = 0, color = :OrangeRed, linewidth = 2)\nfor I ∈ CartesianIndices((-1:1, -1:1, -1:1))\n    local widths = (L, L, L)\n    local offset = Vec3(Tuple(I) .* widths)\n    local box = Rect(offset..., widths...)\n    wireframe!(ax, box; color = (:white, 0.5), linewidth = 0.2)  # plot cube\n    iszero(I) && continue  # don't replot the \"original\" filament\n    fimage .= f .+ Ref(offset)\n    update_coefficients!(fimage)  # updates interpolation coefficients\n    plot!(ax, fimage; refinement = 4, markersize = 0, color = :LightBlue, linewidth = 1)\nend\nfig","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"One can show that the images have the tendency to slow the vortex down, which is consistent with our results (since vz < v_ring). The effect here is relatively important because the ring diameter 2R is comparable to the domain period L:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"2R/L","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"We can expect the periodicity effect on the ring to be much weaker for smaller rings.","category":"page"},{"location":"tutorials/01-vortex_ring/#ring-disabling-periodicity","page":"Vortex ring","title":"Side note: disabling periodicity","text":"","category":"section"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"It is actually possible to disable the periodic boundary conditions, effectively leading to an open domain with a unique vortex ring.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"In VortexPasta.jl, disabling periodicity amounts to disabling the long-range part of Ewald summation, so that all scales are computed by the \"short\"-range component. The cut-off distance is therefore infinity, and it makes no sense to use cell lists to accelerate the computations. Other methods exist (and are now standard) to accelerate this kind of computation, but these are not implemented here. So, while it is possible to disable periodicity, this should only be used for testing or for small calculations.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"To disable periodicity, one should pass α = Zero() and Ls = Infinity() to ParamsBiotSavart:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"params_inf = ParamsBiotSavart(;\n    Γ, α = Zero(), Δ, a,\n    Ls = Infinity(),\n    quadrature,\n)","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Here Zero and Infinity are custom types that, as one may expect, represent 0 and +.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"We can now compute the vortex ring velocity in the absence of periodic effects:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"cache_inf = BiotSavart.init_cache(params_inf, fs)\nvs_inf = map(similar, vs)\nvelocity_on_nodes!(vs_inf, cache_inf, fs)\nv_mean_inf = mean(vs_inf[1])\nv_std_inf = std(vs_inf[1])\nv_std_normalised_inf = v_std_inf / norm(v_mean_inf)\n@show v_mean_inf v_std_inf v_std_normalised_inf\nnothing  # hide","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"The velocity fluctuations along the filament are now practically zero! This should be contrasted with the standard deviation of about 0001 we obtained in the periodic case. This is consistent with what was explained on the anisotropy introduced by periodicity, in the sense that not all points on the filament \"feel\" the effect of the periodic images in the same way.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Moreover, the mean velocity is even closer to the analytical velocity:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"vz_inf = v_mean_inf[3]\nrelative_difference_inf = (v_ring - vz_inf) / v_ring","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"The relative difference is reduced from 5% to about 0.01%! Once again, this clearly shows that periodic images have some (very minor) impact on the effective vortex ring velocity.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Note that we could further reduce the difference with the analytical result by increasing the filament resolution N. The results also depend on the chosen discretisation scheme: QuinticSplineMethod allows to accurately describe the circular vortex ring geometry (and FourierMethod even more so), while methods like CubicSplineMethod and FiniteDiffMethod are less accurate.","category":"page"},{"location":"tutorials/01-vortex_ring/#Making-the-ring-move","page":"Vortex ring","title":"Making the ring move","text":"","category":"section"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Up to now we have shown how to compute the velocity self-induced by a vortex filament on its discretisation points. We now want to use this velocity to advect the vortex filament over time. In the case of a vortex ring, its displacement is very simple and boring (the vortex ring moves with constant velocity), but this case is still useful for instance for testing the stability of timestepping schemes.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"For running temporal simulations, we want to use the VortexPasta.Timestepping submodule. The syntax is somewhat inspired from the popular DifferentialEquations.jl ecosystem.","category":"page"},{"location":"tutorials/01-vortex_ring/#A-basic-simulation","page":"Vortex ring","title":"A basic simulation","text":"","category":"section"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"We start by defining a VortexFilamentProblem, which takes (1) an initial condition (in our case, the initial vortex ring we already defined); (2) the time span of the simulation; and (3) parameters for Biot–Savart computations (which we already defined as well):","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"using VortexPasta.Timestepping\nT = L / 2vz       # time it should take for the ring to cross half the periodic box\ntspan = (0.0, T)  # time span; this basically determines when to stop the simulation\nprob = VortexFilamentProblem(fs, tspan, params)","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"The second step is to \"initialise\" the problem using init. This means choosing a temporal scheme, an initial timestep, as well as optional parameters related for instance to temporal adaptivity, spatial refinement of the filaments, or vortex reconnections.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"For now, we use the explicit RK4 timestepping scheme, set a constant timestep dt, and leave the defaults for everything else:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"l_min = minimum_knot_increment(fs)       # this is an estimate for the minimum distance between discretisation points\ndt = 3 * l_min^2 / (Γ * log(l_min / a))  # we set the timestep to be proportional to some characteristic \"fast\" timescale\niter = init(prob, RK4(); dt)","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Note that the maximum possible timestep to avoid numerical instability is mainly limited by the filament resolution ℓ_textmin. More precisely, the limit is the frequency of spurious oscillations associated to that length scale. These correspond to Kelvin waves, whose frequency roughly scales as ω(ℓ)  Γ ln (ℓ  a)  ℓ^2. See the Kelvin wave tutorial for more details.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"note: Adaptive timestepping\nOne can use adaptive timestepping with the AdaptBasedOnSegmentLength criterion, which automatically updates the timestep based on the current minimal distance between filament nodes.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"We now call solve! to run the simulation until t = T = L  2 v_textring:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"solve!(iter)  # run the simulation until t = T\niter.t / T    # check that the current time is t == T","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"We can check that, as expected, the ring has crossed half the periodic box:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"displacement = @. (iter.fs - prob.fs) / L\ndisplacement[1]  # prints displacement of the first (and only) filament","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"As we can see, the filament nodes have basically only moved in the z direction by almost exactly L  2.","category":"page"},{"location":"tutorials/01-vortex_ring/#tutorial-vortex-ring-simulation-state","page":"Vortex ring","title":"Accessing the instantaneous simulation state","text":"","category":"section"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Above we have simply run a simulation from start to finish, without caring about what happened in-between. In reality, one usually wants to be able to do things with the intermediate states, for instance, to track the evolution of the total vortex length, the energy, or simply to make nice movies.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"There are two ways of doing this, both inspired by DifferentialEquations.jl (see here and here):","category":"page"},{"location":"tutorials/01-vortex_ring/#1.-Using-the-integrator-interface","page":"Vortex ring","title":"1. Using the integrator interface","text":"","category":"section"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"This option is actually quite intuitive. The idea is to explicitly iterate timestep by timestep (typically using a for or while loop) until we decide it's time to stop. At each iteration we perform a simulation timestep (going from t_n to t_n + 1 = t_n + Δt), and then we can do whatever we want with the instantaneous solution contained in iter.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Note that, in this case, the time span defined in the VortexFilamentProblem is completely ignored, meaning that we can stop the simulation whenever we want.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"To use this interface, we create the solver in the same way as before, and then we advance the solver one timestep at a time using step!. For instance, we can choose to stop when we have performed 20 timesteps. And every 5 timestep we print some information:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"iter = init(prob, RK4(); dt)\nwhile iter.nstep ≤ 20\n    # Print the time and the mean location of the vortex ring every 5 solver iterations.\n    local dt  # avoid \"soft scope\" warning\n    (; nstep, t, dt,) = iter\n    if nstep % 5 == 0\n        Xavg = mean(iter.fs[1])\n        println(\"- step = $nstep, t = $t, dt = $dt\")\n        println(\"  Average ring location: \", Xavg)\n    end\n    step!(iter)  # run a single timestep\nend","category":"page"},{"location":"tutorials/01-vortex_ring/#2.-Using-callbacks","page":"Vortex ring","title":"2. Using callbacks","text":"","category":"section"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"We can do the same using a callback. This is a function which gets called at each solver iteration with the current state of the solver.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"The idea is to create such a function which receives a single iter argument. Then we tell init to use this function as a callback, and use solve! as we did earlier to run the simulation until the end time:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"# Prints the time and the mean location of the vortex ring every 5 solver iterations.\nfunction print_solver_info(iter)\n    (; nstep, t, dt,) = iter\n    if nstep % 5 == 0\n        Xavg = mean(iter.fs[1])\n        println(\"- step = $nstep, t = $t, dt = $dt\")\n        println(\"  Average ring location: \", Xavg)\n    end\nend\niter = init(prob, RK4(); dt, callback = print_solver_info)\nsolve!(iter)\nnothing  # hide","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Note that the callback is also called once when the solver is initialised (when nstep = 0).","category":"page"},{"location":"tutorials/01-vortex_ring/#Making-an-animation","page":"Vortex ring","title":"Making an animation","text":"","category":"section"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"We can use either of the two methods above to create a video of the moving vortex. Here we will use Makie to create the animation. See the Makie docs on animations for more details.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"In this example we will use the integrator interface. We start by initialising the solver and creating a plot with to the initial condition:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"iter = init(prob, RK4(); dt)\n\nf_obs = Observable(iter.fs[1])  # variable to be updated over time\nt_obs = Observable(iter.t)      # variable to be updated over time\n\nfig = Figure()\nax = Axis3(fig[1, 1]; aspect = :data, title = @lift(\"Time: $($t_obs)\"))\nhidespines!(ax)\nbox = Rect(0, 0, 0, L, L, L)  # periodic domain limits\nwireframe!(ax, box; color = (:white, 0.5), linewidth = 0.5)\nplot!(ax, f_obs; markersize = 0, refinement = 4, linewidth = 2)\nfig","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Note that we have wrapped the vortex ring filament iter.fs[1] in an Observable. The plot will be automatically updated each time we modify this Observable object:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"record(fig, \"vortex_ring.mp4\") do io\n    recordframe!(io)      # add initial frame (initial condition) to movie\n    while iter.t < 2T\n        step!(iter)       # run a single timestep\n        notify(f_obs)     # tell Makie that filament positions have been updated\n        t_obs[] = iter.t  # update displayed time\n        yield()           # allows to see the updated plot\n        recordframe!(io)  # add current frame to movie\n    end\nend\nnothing  # hide","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Note that here we have used record and recordframe! to generate a movie file, but these are not needed if one just wants to see things moving in real time as the simulation runs.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"(Image: )","category":"page"},{"location":"tutorials/01-vortex_ring/#Saving-state-to-disk","page":"Vortex ring","title":"Saving state to disk","text":"","category":"section"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"It is often useful to be able to save the solver state to disk, for instance to be able to restart a simulation from that state or to analyse the data. In VortexPasta this is possible using the VortexPasta.FilamentIO submodule, which defines functions for writing (and reading back) vortex filament data.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Data is written in the HDF5 format, which is a binary format that can be easily explored using command-line tools or the HDF5 interfaces available in many different programming languages. More precisely, data is written to VTKHDF files, which are HDF5 files with a specific organisation that can be readily understood by visualisation tools such as ParaView. In other words, simulation outputs can be readily visualised without the need to convert them or to have a \"translation\" file explaining how to visualise the binary data.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"note: VTKHDF file extension\nParaView doesn't recognise the usual .h5 file extension as a VTKHDF file. For this reason, it is recommended to use .vtkhdf if one wants to visualise the data.","category":"page"},{"location":"tutorials/01-vortex_ring/#Writing-filament-data-and-reading-it-back","page":"Vortex ring","title":"Writing filament data and reading it back","text":"","category":"section"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Writing filament data is done via the write_vtkhdf function:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"using VortexPasta.FilamentIO\nwrite_vtkhdf(\"vortex_ring_initial.vtkhdf\", fs)  # write filament locations to disk","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"This creates an HDF5 file with the following structure:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"$ h5ls -r vortex_ring_initial.vtkhdf\n/                                     Group\n/VTKHDF                               Group\n/VTKHDF/Lines/Connectivity            Dataset {17}\n/VTKHDF/Lines/NumberOfCells           Dataset {1}\n/VTKHDF/Lines/NumberOfConnectivityIds Dataset {1}\n/VTKHDF/Lines/Offsets                 Dataset {2}\n/VTKHDF/NumberOfPoints                Dataset {1}\n/VTKHDF/Points                        Dataset {17, 3}\n/VTKHDF/RefinementLevel               Dataset {SCALAR}\n[...]","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"(The [...] includes the Polygons, Strips and Vertices groups which are just there to make ParaView happy.) Note that everything is written to a VTKHDF group. In this case, we have a single cell which corresponds to our vortex ring (one VTK cell corresponds to one vortex filament). The important datasets here are Points, which contains the discretisation points of all filaments, and Lines/Offsets, which allows to identify which point corresponds to which vortex. See write_vtkhdf for more details.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"The generated files can be read back using read_vtkhdf:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"fs_read = read_vtkhdf(\"vortex_ring_initial.vtkhdf\", Float64, CubicSplineMethod())\nfs_read == fs","category":"page"},{"location":"tutorials/01-vortex_ring/#Visualising-VTKHDF-files","page":"Vortex ring","title":"Visualising VTKHDF files","text":"","category":"section"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Opening this file in ParaView should produce something like this:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"(Image: )","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Things look quite rough since, by default, we only export the discretisation points, which ParaView connects by straight lines. As with Makie plots, we can make things look nicer by passing the refinement argument:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"write_vtkhdf(\"vortex_ring_initial_refined.vtkhdf\", fs; refinement = 4)","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"(Image: )","category":"page"},{"location":"tutorials/01-vortex_ring/#Attaching-more-data","page":"Vortex ring","title":"Attaching more data","text":"","category":"section"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"It can also be useful to include other data associated to the filaments, such as the velocity of the discretisation points. One can also easily add geometric quantities along filaments (see GeometricQuantity for a list of possible options).","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"As an example, we can save the positions, velocities, streamfunction, local curvature vector and time values corresponding to the final state of our last simulation:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"write_vtkhdf(\"vortex_ring_final.vtkhdf\", iter.fs; refinement = 4) do io\n    io[\"velocity\"] = iter.vs\n    io[\"streamfunction\"] = iter.ψs\n    io[\"curvatures\"] = CurvatureVector()  # note: no need to explicitly compute curvatures!\n    io[\"time\"] = iter.t\nend","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"The HDF5 file structure now looks like:","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"$ h5ls -r vortex_ring_final.vtkhdf\n/                                     Group\n/VTKHDF                               Group\n/VTKHDF/FieldData                     Group\n/VTKHDF/FieldData/time                Dataset {1}\n/VTKHDF/Lines/Connectivity            Dataset {65}\n/VTKHDF/Lines/NumberOfCells           Dataset {1}\n/VTKHDF/Lines/NumberOfConnectivityIds Dataset {1}\n/VTKHDF/Lines/Offsets                 Dataset {2}\n/VTKHDF/NumberOfPoints                Dataset {1}\n/VTKHDF/PointData                     Group\n/VTKHDF/PointData/curvatures          Dataset {65, 3}\n/VTKHDF/PointData/streamfunction      Dataset {65, 3}\n/VTKHDF/PointData/velocity            Dataset {65, 3}\n/VTKHDF/Points                        Dataset {65, 3}\n/VTKHDF/RefinementLevel               Dataset {SCALAR}\n[...]","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Note that a PointData group has been created with two datasets: streamfunction and velocity. These correspond to data attached to the filaments, and have the same dimensions as the Points dataset. These can be readily visualised in ParaView. Besides, a FieldData group has been created with the time dataset. In VTK, \"field data\" corresponds to values that are not directly attached to the geometry, such as scalar quantities in this case.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Loading the attached data is done in a similar way (see read_vtkhdf for details):","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"vs_read = map(similar ∘ nodes, fs)\nψs_read = map(similar ∘ nodes, fs)\nfs_read = read_vtkhdf(\"vortex_ring_final.vtkhdf\", Float64, CubicSplineMethod()) do io\n    read!(io, vs_read, \"velocity\")\n    read!(io, ψs_read, \"streamfunction\")\n    local t_read = read(io, \"time\", FieldData(), Float64)  # note: this is read as an array\n    @show t_read\nend\n@show (fs_read ≈ iter.fs) (vs_read == iter.vs) (ψs_read == iter.ψs)\nnothing  # hide","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"Note that, when reading \"refined\" datasets, only the original discretisation points and data on them are read back. The points and data added in-between nodes for refinement purposes are discarded.","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"","category":"page"},{"location":"tutorials/01-vortex_ring/","page":"Vortex ring","title":"Vortex ring","text":"This page was generated using Literate.jl.","category":"page"},{"location":"modules/PaddedArrays/#PaddedArrays","page":"PaddedArrays","title":"PaddedArrays","text":"","category":"section"},{"location":"modules/PaddedArrays/","page":"PaddedArrays","title":"PaddedArrays","text":"CurrentModule = VortexPasta.PaddedArrays\nCollapsedDocStrings = true","category":"page"},{"location":"modules/PaddedArrays/","page":"PaddedArrays","title":"PaddedArrays","text":"PaddedArrays","category":"page"},{"location":"modules/PaddedArrays/#VortexPasta.PaddedArrays","page":"PaddedArrays","title":"VortexPasta.PaddedArrays","text":"PaddedArrays\n\nModule defining the PaddedArray type for dealing with arrays padded by ghost cells.\n\nAmong other things, this type allows to efficiently work with periodic boundary conditions in one and more spatial dimensions.\n\n\n\n\n\n","category":"module"},{"location":"modules/PaddedArrays/#Types","page":"PaddedArrays","title":"Types","text":"","category":"section"},{"location":"modules/PaddedArrays/","page":"PaddedArrays","title":"PaddedArrays","text":"PaddedArray\nPaddedVector","category":"page"},{"location":"modules/PaddedArrays/#VortexPasta.PaddedArrays.PaddedArray","page":"PaddedArrays","title":"VortexPasta.PaddedArrays.PaddedArray","text":"PaddedArray{M, T, N} <: AbstractArray{T, N}\n\nPads a vector with M \"ghost\" entries on each side, along each direction.\n\nCan be useful for dealing with periodic boundary conditions. In that use case, one can call pad_periodic! once the non-ghost entries have been filled to conveniently impose those kind of conditions.\n\nSee also PaddedVector.\n\n\n\nPaddedArray{M}(data::AbstractArray)\n\nInterpret input array as a padded array.\n\nNote that the input array is not modified. Instead, its M first and M last entries along each direction are considered as \"ghost\" entries.\n\nIn other words, the \"logical\" dimensions of the resulting PaddedArray are size(v) = size(data) .- 2M. Along a given direction of size N, indexing functions like axes return the range 1:N (or an equivalent). However, the array can in reality be indexed (and modified) over the range (1 - M):(N + M).\n\nSee PaddedVector for some one-dimensional examples.\n\n\n\n\n\n","category":"type"},{"location":"modules/PaddedArrays/#VortexPasta.PaddedArrays.PaddedVector","page":"PaddedArrays","title":"VortexPasta.PaddedArrays.PaddedVector","text":"PaddedVector{M, T} <: AbstractVector{T}\n\nAlias for PaddedArray{M, T, 1} which can be used to work with one-dimensional data.\n\n\n\nPaddedVector{M}(data::AbstractVector)\n\nInterpret input vector as a padded vector.\n\nSee PaddedArray for details.\n\nExamples\n\njulia> v = PaddedVector{2}(collect(1:10))\n6-element PaddedVector{2, Int64, Vector{Int64}}:\n 3\n 4\n 5\n 6\n 7\n 8\n\njulia> eachindex(v)\nBase.OneTo(6)\n\njulia> v[begin]\n3\n\njulia> v[begin - 2]\n1\n\njulia> v[end]\n8\n\njulia> v[end + 2]\n10\n\njulia> v[end - 1] = 42; println(v)\n[3, 4, 5, 6, 42, 8]\n\n\n\n\n\n","category":"type"},{"location":"modules/PaddedArrays/#Functions","page":"PaddedArrays","title":"Functions","text":"","category":"section"},{"location":"modules/PaddedArrays/","page":"PaddedArrays","title":"PaddedArrays","text":"pad_periodic!","category":"page"},{"location":"modules/PaddedArrays/#VortexPasta.PaddedArrays.pad_periodic!","page":"PaddedArrays","title":"VortexPasta.PaddedArrays.pad_periodic!","text":"pad_periodic!(v::PaddedArray{M, T, N}, [L = zero(T)])\n\nFill ghost cells in a periodic manner.\n\nIn the simplest case of a 1D PaddedArray (N = 1), this function will copy:\n\nv[begin:(begin + M - 1)] → v[(end + 1):(end + M)], and\nv[(end - M + 1):end] → v[(begin - M):(begin - 1)].\n\nSomething equivalent (but more complicated) is done in multiple dimensions.\n\nIf L ≠ 0, it is interpreted as an unfolding period (or as an end-to-end distance after a single period), such that v[N + i] - v[i] = L, where N = length(v).\n\n\n\n\n\n","category":"function"},{"location":"modules/BasicTypes/#BasicTypes","page":"BasicTypes","title":"BasicTypes","text":"","category":"section"},{"location":"modules/BasicTypes/","page":"BasicTypes","title":"BasicTypes","text":"CurrentModule = VortexPasta.BasicTypes\nCollapsedDocStrings = true","category":"page"},{"location":"modules/BasicTypes/","page":"BasicTypes","title":"BasicTypes","text":"BasicTypes","category":"page"},{"location":"modules/BasicTypes/#VortexPasta.BasicTypes","page":"BasicTypes","title":"VortexPasta.BasicTypes","text":"BasicTypes\n\nDefines and exports basic types used in all computations.\n\n\n\n\n\n","category":"module"},{"location":"modules/BasicTypes/#Exported-types","page":"BasicTypes","title":"Exported types","text":"","category":"section"},{"location":"modules/BasicTypes/","page":"BasicTypes","title":"BasicTypes","text":"Derivative\nVec3\nVectorOfVectors\nZero\nInfinity\n∞","category":"page"},{"location":"modules/BasicTypes/#VortexPasta.BasicTypes.Derivative","page":"BasicTypes","title":"VortexPasta.BasicTypes.Derivative","text":"Derivative{N}\n\nRepresents the N-th order derivative operator.\n\nUsed in particular to interpolate derivatives along filaments.\n\n\n\n\n\n","category":"type"},{"location":"modules/BasicTypes/#VortexPasta.BasicTypes.Vec3","page":"BasicTypes","title":"VortexPasta.BasicTypes.Vec3","text":"Vec3{T}\n\nThree-element static vector, alias for SVector{3, T}.\n\nUsed to describe vectors and coordinates in 3D space.\n\n\n\n\n\n","category":"type"},{"location":"modules/BasicTypes/#VortexPasta.BasicTypes.VectorOfVectors","page":"BasicTypes","title":"VortexPasta.BasicTypes.VectorOfVectors","text":"VectorOfVectors{T, V <: AbstractVector{T}} <: AbstractVector{V <: AbstractVector}\nVectorOfVectors(data::AbstractVector{<:AbstractVector})\n\nContains a list of vectors.\n\nIt behaves as much as possible as a basic vector of vectors. For instance:\n\nits length is the number of contained vectors;\nits element type (eltype) is the type of a contained vector;\nit only allows linear indexing (e.g. u[i] to get a single vector). To get an individual element (of type T), one should do u[i][j].\n\nNote that the individual vectors u[i] can have different lengths from each other.\n\nThere are also some differences:\n\nit overloads broadcasting mechanisms, so that doing @. u = 2 * u + v (where both variables are VectorOfVectors) works as expected and is efficient;\ncopying a VectorOfVectors recursively copies its contained vectors, instead of just copying array references (\"pointers\").\n\nExamples\n\njulia> data = [rand(n) for n ∈ 1:4]\n4-element Vector{Vector{Float64}}:\n [0.6293451231426089]\n [0.4503389405961936, 0.47740714343281776]\n [0.7031298490032014, 0.6733461456394962, 0.16589443479313404]\n [0.6134782250008441, 0.6683403279577278, 0.4570310908017041, 0.2993652953937611]\n\njulia> us = VectorOfVectors(data)\n4-element VectorOfVectors{Float64, Vector{Float64}}:\n [0.6293451231426089]\n [0.4503389405961936, 0.47740714343281776]\n [0.7031298490032014, 0.6733461456394962, 0.16589443479313404]\n [0.6134782250008441, 0.6683403279577278, 0.4570310908017041, 0.2993652953937611]\n\njulia> us[2]\n2-element Vector{Float64}:\n 0.4503389405961936\n 0.47740714343281776\n\njulia> vs = @. us + 2 * us  # broadcasting\n4-element VectorOfVectors{Float64, Vector{Float64}}:\n [1.888035369427827]\n [1.3510168217885807, 1.4322214302984533]\n [2.109389547009604, 2.0200384369184885, 0.4976833043794021]\n [1.8404346750025324, 2.0050209838731834, 1.3710932724051124, 0.8980958861812833]\n\n\n\n\n\n\n","category":"type"},{"location":"modules/BasicTypes/#VortexPasta.BasicTypes.Zero","page":"BasicTypes","title":"VortexPasta.BasicTypes.Zero","text":"Zero <: RealConst <: Real\n\nSingleton type representing zero.\n\n\n\n\n\n","category":"type"},{"location":"modules/BasicTypes/#VortexPasta.BasicTypes.Infinity","page":"BasicTypes","title":"VortexPasta.BasicTypes.Infinity","text":"Infinity <: RealConst <: Real\n\nSingleton type representing infinity.\n\n\n\n\n\n","category":"type"},{"location":"modules/BasicTypes/#VortexPasta.BasicTypes.∞","page":"BasicTypes","title":"VortexPasta.BasicTypes.∞","text":"∞\n\nAlias for Infinity().\n\n\n\n\n\n","category":"constant"},{"location":"methods/VFM/#methods-VFM","page":"The vortex filament model","title":"The vortex filament model","text":"","category":"section"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"The standard vortex filament model (VFM) describes the motion of thin vortex lines in three-dimensional space.","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"Vortex lines are assumed to be very thin with respect to the scales of interest, such that they can be effectively described as spatial curves.","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"Pages = [\"VFM.md\"]\nDepth = 2:3","category":"page"},{"location":"methods/VFM/#BiotSavart","page":"The vortex filament model","title":"The Biot–Savart law","text":"","category":"section"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"In the VFM, each vortex line induces a velocity field around it given by the Biot–Savart law:","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"bmv(bmx) =\nfracΓ4π _mathcalC frac(bms - bmx) times mathrmdbmsbms - bmx^3","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"where Γ is the vortex circulation (equal to κ for quantum vortices), and bms is a point along the vortex line. Here mathcalC denotes the whole set of vortex lines in the system.","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"Mathematically, the above equation derives from the vorticity field:","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"bmω(bmx)  bmnabla  bmv(bmx)\n= Γ _mathcalC δ(bms - bmx)  mathrmdbms","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"where δ is Dirac delta function. That is, the vorticity field is singular and localised at the locations of quantum vortices.","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"The Biot–Savart law describes in particular the motion induced by vortex filaments on themselves and on surrounding vortex lines. The VFM thus describes the collective motion of a set of mutually-interacting vortex filaments which obey the Biot–Savart law. Note that the Biot–Savart integral is singular when evaluated at a vortex location bms  mathcalC, and the integral must be desingularised by taking into account the finite thickness of the vortex core. The VFM also accounts for vortex reconnections, which occur when two vortex segments are sufficiently close to each other and which change the topology of the vortex system.","category":"page"},{"location":"methods/VFM/#VFM-desingularisation","page":"The vortex filament model","title":"Desingularisation","text":"","category":"section"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"In the VFM, one usually wants to evaluate the Biot–Savart law at locations bmx = bms_0 on the vortex. It is clear that the Biot–Savart integral, as written above, is singular when evaluated at a point bms_0 on the curve.","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"The divergence of the Biot–Savart integral is of course unphysical, and is related to the fact that the actual thickness of vortex lines not really infinitesimal but finite. The standard way of accounting for the radius a of the vortex core is to split the integral into local and non-local parts:","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"newcommandvvecbmv\nnewcommandsvecbms\nnewcommandddmathrmd\nnewcommandsjsvec_0\nvvec(sj) =\nfracΓ4π _mathcalC_0 frac(svec - sj) times ddsvecsvec - sj^3\n+\nfracΓ4π _mathcalC  mathcalC_0 frac(svec - sj) times ddsvecsvec - sj^3\n= vvec_textlocal(sj) + vvec_textnon-local(sj)","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"Here mathcalC_0 denotes a portion of the set of curves mathcalC which is in the neighbourhood of the point of interest bms_0.","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"To illustrate this, the figure below shows a trefoil knot curve, or rather its projection on the XY plane. Note that here we represent a discretised version of the curve, where the number of degrees of freedom is finite and controlled by the positions of the markers.","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"(Image: )","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"details: Code for this figure\nusing CairoMakie\nCairoMakie.activate!(type = \"svg\", pt_per_unit = 1.0)\nMakie.set_theme!()\n\nusing VortexPasta.Filaments\nusing VortexPasta.Filaments: Vec3\nusing VortexPasta.PredefinedCurves: define_curve, TrefoilKnot\n\ntrefoil = define_curve(TrefoilKnot())\nN = 32\ni = (N ÷ 2) + 3\nrefinement = 8\ncolours = Makie.wong_colors()\nf = Filaments.init(trefoil, ClosedFilament, N, CubicSplineMethod())\n\nfig = Figure(Text = (fontsize = 24,))\nax = Axis(fig[1, 1]; aspect = DataAspect(), xlabel = \"x\", ylabel = \"y\")\nhidexdecorations!(ax; label = false, ticklabels = false, ticks = false)\nhideydecorations!(ax; label = false, ticklabels = false, ticks = false)\n\n# Plot complete filament in grey\nlet color = (:grey, 0.6)\n    plot!(ax, f; refinement, color, linewidth = 1.5)\n    text!(\n        ax, f(i ÷ 2 + 1, 0.6);\n        text = L\"\\bar{\\mathcal{C}}_{\\!i}\", align = (:right, :bottom), color,\n        fontsize = 28,\n    )\nend\n\n# Plot point of interest and local segment around it\nlet color = colours[2], arrowcol = colours[3]\n    # Plot nodes (i - 1):(i + 1)\n    scatter!(ax, getindex.(Ref(f), (i - 1):(i + 1)); color)\n    text!(\n        ax, f[i - 1] + Vec3(0.08, 0.0, 0.0);\n        text = L\"\\mathbf{s}_{i - 1}\", align = (:left, :center), color,\n    )\n    text!(\n        ax, f[i] + Vec3(0.08, 0.0, 0.0);\n        text = L\"\\mathbf{s}_i\", align = (:left, :center), color,\n    )\n    text!(\n        ax, f[i + 1] + Vec3(-0.08, 0.08, 0.0);\n        text = L\"\\mathbf{s}_{i + 1}\", align = (:right, :center), color,\n    )\n\n    # Plot local segments\n    let ζs = range(0, 1; length = refinement + 1)\n        lines!(ax, f.(i - 1, ζs); color, linewidth = 3)\n        lines!(ax, f.(i, ζs); color, linewidth = 3)\n        text!(\n            f(i - 1, 0.5);\n            text = L\"ℓ^{-}\", align = (:right, :bottom), color,\n        )\n        text!(\n            f(i, 0.6) + Vec3(-0.08, 0, 0);\n            text = L\"ℓ^{+}\", align = (:right, :center), color,\n        )\n        text!(\n            ax, f(i - 1, 0.7) + Vec3(0.2, 0.0, 0.0);\n            text = L\"\\mathcal{C}_{\\!i}\", align = (:left, :top), color,\n            fontsize = 28,\n        )\n    end\n\n    # Plot tangent and curvature vectors (assuming this is a 2D plot...)\n    s⃗ = f[i]\n    t̂ = f[i, UnitTangent()]\n    ρ⃗ = f[i, CurvatureVector()]\n    arrows!(ax, [s⃗[1]], [s⃗[2]], [t̂[1]], [t̂[2]]; color = arrowcol)\n    arrows!(ax, [s⃗[1]], [s⃗[2]], [ρ⃗[1]], [ρ⃗[2]]; color = arrowcol)\n    text!(\n        ax, s⃗ + t̂ + Vec3(0.05, 0.0, 0.0);\n        text = L\"\\mathbf{s}′\", align = (:left, :center), color = arrowcol,\n    )\n    text!(\n        ax, s⃗ + ρ⃗ + Vec3(0.0, 0.04, 0.0);\n        text = L\"\\mathbf{s}″\", align = (:center, :bottom), color = arrowcol,\n    )\nend\n\nsave(\"trefoil_local.svg\", fig)\nnothing  # hide","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"Here, to evaluate the velocity induced by the trefoil vortex on its point bms_i, we split the curve into a local part mathcalC_i (orange) and a non-local part barmathcalC_i = mathcalC  mathcalC_i (grey). The non-local part is far from the singularity, so there is no need to modify the Biot–Savart integral as written above. As for the local part, we can approximate it using a Taylor expansion of the Biot–Savart integral about bms_i and truncating the integral at a small distance ϵ  a from the singularity. See for instance Arms and Hama (1965).","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"More explicitly, from a Taylor expansion of bms(ξ) close to bms_i = bms(ξ_i), one can show that the Biot–Savart integrand is approximately","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"fracbms(ξ) - bms_i  bms(ξ)bms(ξ) - bms_i^3\n fracbms_i  bms_i2 ξ - ξ_i","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"where ξ is the curve arc length and derivatives (primes) are with respect to ξ. Note that bms_i and bms_i are respectively the unit tangent and curvature vectors at bms_i (see figure).","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"Now, if one integrates e.g. from bms(ξ_i + ϵ) to bms_i + 1 = bms(ξ_i + 1), one gets:","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"bmv_i^+\n fracΓ4π fracbms_i  bms_i2\n_ξ_i + ϵ^ξ_i + 1 fracmathrmdξξ - ξ_i\n= fracΓ4π fracbms_i  bms_i2\nln left( fracℓ^+ϵ right)","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"where ℓ^+ = ξ_i + 1 - ξ_i is the length of the curve segment bms_i  bms_i + 1 (see figure). Doing something similar for the segment bms_i - 1  bms(ξ_i - ϵ) and adding both contributions, we obtain the local velocity:","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"bmv_textlocal(bms_i)\n= fracΓ4π bms_i  bms_i ln left( fracsqrtℓ^- ℓ^+ϵ right)\n= fracΓ4π bms_i  bms_i left ln left( frac2sqrtℓ^- ℓ^+a right) - Δ right","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"where we have taken the cut-off distance to be ϵ = frace^Δ a2 (Saffman, 1993; §11.2). Here Δ is a coefficient which depends on the form of the vorticity profile within the vortex core (see the vortex ring tutorial).","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"In the code, the local velocity is sometimes referred to as the LIA (local induction approximation) term, as it has been historically used as a fast (and incomplete) approximation to the full Biot–Savart integral.","category":"page"},{"location":"methods/VFM/#Streamfunction-and-energy","page":"The vortex filament model","title":"Streamfunction and energy","text":"","category":"section"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"Everything that has been discussed until now applies to the velocity derived from the Biot–Savart law. Sometimes we may also be interested in the streamfunction vector bmψ. In particular, the streamfunction values on vortex lines can be used to estimate the total energy of the vortex filament system.","category":"page"},{"location":"methods/VFM/#Biot-Savart-streamfunction","page":"The vortex filament model","title":"The Biot–Savart law for the streamfunction","text":"","category":"section"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"In three dimensions, the streamfunction is a vector field which is directly related to the velocity and vorticity by","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"bmv = bm  bmψ quad Rightarrow quad bmω = bm  bmv = -²bmψ","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"That is, if one knows the vorticity field bmω, then the streamfunction is the solution of a Poisson equation with the vorticity as source term. The solution can be written in terms of the Green's function G(bmr) = 1(4πr) associated to the 3D Poisson equation:","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"newcommandxvecbmx\nnewcommandyvecbmy\nnewcommandvortbmω\nnewcommandddmathrmd\nbmψ(xvec) = (G  vort)(xvec)\n=  G(xvec - yvec) vort(yvec)  dd^3yvec\n= frac14π  fracvort(yvec)xvec - yvec  dd^3yvec","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"Using the fact that the vorticity has the form bmω(bmx) = Γ _mathcalC δ(bms - bmx)  mathrmdbms leads to the Biot–Savart law for the streamfunction:","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"newcommandxvecbmx\nnewcommandsvecbms\nnewcommandvortbmω\nnewcommandddmathrmd\nbmψ(xvec)\n= Γ _mathcalC G(xvec - svec)  ddsvec\n= fracΓ4π _mathcalC fracddsvecxvec - svec","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"Note that the usual Biot–Savart law for the velocity can be recovered by taking the curl of the above expression:","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"newcommandxvecbmx\nnewcommandsvecbms\nnewcommandvvecbmv\nnewcommandvortbmω\nnewcommandddmathrmd\nnewcommandcurlbm \nvvec(xvec)\n= curl bmψ(xvec)\n= Γ _mathcalC bm G(xvec - svec)  ddsvec\n= -fracΓ4π _mathcalC frac(xvec - svec)  ddsvecxvec - svec^3","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"where we have used bm G(bmr) = -bmr  (4π r^3).","category":"page"},{"location":"methods/VFM/#VFM-energy","page":"The vortex filament model","title":"Connection with kinetic energy","text":"","category":"section"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"The kinetic energy of the system is given by","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"newcommandxvecbmx\nnewcommandddmathrmd\nE\n= fracρ2  bmv(xvec)  bmv(xvec)  dd^3xvec\n= fracρ2  bmψ(xvec)  bmω(xvec)  dd^3xvec","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"where the second equality is obtained using integration by parts and assuming we're in a periodic domain (or, alternatively, that the velocity goes to zero far from the vortices), and ρ is the fluid density. As before, using bmω(bmx) = Γ _mathcalC δ(bms - bmx)  mathrmdbms leads to","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"newcommandsvecbms\nnewcommandddmathrmd\nE = fracρΓ2 _mathcalC bmψ(svec)  ddsvec","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"That is, the energy is simply the line integral of the tangential component of the streamfunction along vortex filaments.","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"Note that, if one uses the expression for bmψ(bmx) from the previous section, one can directly write the total energy from the configuration of the vortex lines:","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"newcommandsvecbms\nnewcommandddmathrmd\nE = fracρΓ^28π _mathcalC _mathcalC fracdd svec  dd svec_1svec - svec_1","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"where the prime over the integral is to account for the desingularisation of the streamfunction integral (see section below).","category":"page"},{"location":"methods/VFM/#Desingularisation-of-the-streamfunction-integral","page":"The vortex filament model","title":"Desingularisation of the streamfunction integral","text":"","category":"section"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"As for the velocity, the Biot–Savart integral for the streamfunction is singular when evaluated on a vortex line. We can use the same approach to desingularise it, by splitting the integral onto a local and a non-local part.","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"Using the same notation as for the velocity, a leading-order Taylor expansion of the integrand leads to:","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"bmψ_i^+\n fracΓ2π fracbms_i2 _ξ_i + ϵ^ξ_i + 1 fracmathrmdξξ - ξ_i\n= fracΓ2π fracbms_i2 ln left( fracℓ^+ϵ right)","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"and then to:","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"bmψ_textlocal(bms_i)\n= fracΓ bms_i2π ln left( fracsqrtℓ^- ℓ^+ϵ right)","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"Note that, here, the cut-off distance ϵ is not necessarily the same as for the velocity. In fact, if one considers a system of non-colliding vortex rings, one can show that, for the system to be Hamiltonian, one needs to take ϵ = frace^Δ - 1 a2 (as verified in the example below). This finally leads to:","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"bmψ_textlocal(bms_i)\n= fracΓ bms_i2π left ln left( frac2 sqrtℓ^- ℓ^+a right) - (Δ - 1) right","category":"page"},{"location":"methods/VFM/#VFM-ring","page":"The vortex filament model","title":"Example: vortex ring","text":"","category":"section"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"For a circular vortex ring of radius R, one can analytically compute the non-local Biot–Savart integrals. Under the approximation that the local segments are much smaller than the vortex radius (ℓ^-  ℓ^+  R), one obtains:","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"newcommandvvecbmv\nnewcommandpsivecbmψ\nnewcommandsvecbms\nnewcommandddmathrmd\nnewcommandsjsvec_i\nbeginalign*\nvvec_textnon-local(sj)\n= fracΓ4π sj  sj ln left( frac8Rℓ^* right)\n\npsivec_textnon-local(sj)\n= fracΓ2π sj left ln left( frac8Rℓ^* right) - 2 right\nendalign*","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"where we have defined ℓ^* = 2sqrtℓ^- ℓ^+. In the expression for the velocity, bms_i  bms_i = hatbmz  R, where hatbmz is the direction orthogonal to the plane where the ring lives. As a reminder, bms_i is the local unit tangent vector, while the second derivative bms_i corresponds to the curvature vector (oriented towards the \"interior\" of the curve) and whose magnitude is 1R.","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"Adding the local integrals obtained by desingularisation leads to:","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"newcommandvvecbmv\nnewcommandpsivecbmψ\nnewcommandsvecbms\nnewcommandddmathrmd\nnewcommandsjsvec_i\nbeginalign*\nvvec(sj)\n= fracΓ hatbmz4πR left ln left( frac8Ra right) - Δ right\n\npsivec(sj)\n= fracΓ sj2π left ln left( frac8Ra right) - (Δ + 1) right\nendalign*","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"The first expression obtained is the well-known self-induced velocity of a thin vortex ring.","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"From the second expression, we can easily obtain the energy associated to the vortex ring:","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"E = fracρ Γ^2 R2 left ln left( frac8Ra right) - (Δ + 1) right","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"We can finally check that, with the desingularisation procedure described in the previous sections, the vortex ring obeys Hamilton's equation v = Ep (Roberts and Donnelly, 1970). Here bmp is the vortex impulse (Saffman, 1993):","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"bmp = fracρ Γ2 _mathcalC bms  mathrmdbms","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"For a vortex ring, bmp = ρ Γ π R^2 hatbmz, that is, the impulse is directly related to the area enclosed by the vortex.","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"Noting that","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"fracER = fracρ Γ^22 left ln left( frac8Ra right) - Δ right\nquad textand quad\nfracbmpR = 2ρ ΓπR hatbmz","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"we finally obtain that","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"fracEp\n= fracΓ4πR left ln left( frac8Ra right) - Δ right\n= v_textring","category":"page"},{"location":"methods/VFM/#Energy-in-open-domains","page":"The vortex filament model","title":"Energy in open domains","text":"","category":"section"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"In open (non-periodic and unbounded) domains, assuming that the velocity field goes to zero sufficiently far from the vortices, a commonly used alternative expression for the energy is (Saffman, 1993):","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"E₀ = ρ Γ _mathcalC bmv  (bms  mathrmdbms)","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"which only requires knowing the velocity bmv on the vortex filaments. Besides the above assumptions, this assumes that the fluid is incompressible everywhere.","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"However, this definition does not satisfy Hamilton's equation, meaning that this \"energy\" may present fluctuations in time in cases where the previous definition will be conserved.","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"This can be easily shown for the case of a vortex ring, in which case applying this definition to the expression for the vortex ring velocity leads to","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"E₀ = fracρ Γ^2 R2 left ln left( frac8Ra right) - Δ right","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"which overestimates the actual vortex ring energy by a ρ Γ^2 R  2 term (and thus doesn't satisfy Hamilton's equation).","category":"page"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"These differences might be explained by the fact that this second definition doesn't take into account the internal structure of the vortices, unlike the first definition which does this via the local contribution to the streamfunction.","category":"page"},{"location":"methods/VFM/#References","page":"The vortex filament model","title":"References","text":"","category":"section"},{"location":"methods/VFM/","page":"The vortex filament model","title":"The vortex filament model","text":"A classical reference for the VFM is Schwarz (1985), while a more modern review is given by Hänninen and Baggaley (2014).","category":"page"},{"location":"modules/Quadratures/#Quadratures","page":"Quadratures","title":"Quadratures","text":"","category":"section"},{"location":"modules/Quadratures/","page":"Quadratures","title":"Quadratures","text":"CurrentModule = VortexPasta.Quadratures\nCollapsedDocStrings = true","category":"page"},{"location":"modules/Quadratures/","page":"Quadratures","title":"Quadratures","text":"Quadratures","category":"page"},{"location":"modules/Quadratures/#VortexPasta.Quadratures","page":"Quadratures","title":"VortexPasta.Quadratures","text":"Quadratures\n\nModule defining quadrature rules for numerical integration along filaments.\n\nQuadrature rules are determined using the FastGaussQuadrature.jl package.\n\nSee the Wikipedia page on Gaussian quadratures for more details.\n\nFor convenience, quadrature rules in this module are defined on the 0 1 interval, as opposed to the standard -1 1 interval.\n\n\n\n\n\n","category":"module"},{"location":"modules/Quadratures/#Quadrature-rules","page":"Quadratures","title":"Quadrature rules","text":"","category":"section"},{"location":"modules/Quadratures/","page":"Quadratures","title":"Quadratures","text":"AbstractQuadrature","category":"page"},{"location":"modules/Quadratures/#VortexPasta.Quadratures.AbstractQuadrature","page":"Quadratures","title":"VortexPasta.Quadratures.AbstractQuadrature","text":"AbstractQuadrature\n\nAbstract type defining a quadrature rule.\n\n\n\n\n\n","category":"type"},{"location":"modules/Quadratures/#Fixed-size-quadratures","page":"Quadratures","title":"Fixed-size quadratures","text":"","category":"section"},{"location":"modules/Quadratures/","page":"Quadratures","title":"Quadratures","text":"These quadrature rules are meant to have a small size (typically less than 10). They have virtually zero creation cost, i.e. doing quad = GaussLegendre(4) is basically free.","category":"page"},{"location":"modules/Quadratures/","page":"Quadratures","title":"Quadratures","text":"StaticSizeQuadrature\nGaussLegendre\nNoQuadrature","category":"page"},{"location":"modules/Quadratures/#VortexPasta.Quadratures.StaticSizeQuadrature","page":"Quadratures","title":"VortexPasta.Quadratures.StaticSizeQuadrature","text":"StaticSizeQuadrature{N} <: AbstractQuadrature\n\nAbstract type defining an N-point quadrature rule.\n\nThese quadrature rules can be created basically for free.\n\n\n\n\n\n","category":"type"},{"location":"modules/Quadratures/#VortexPasta.Quadratures.GaussLegendre","page":"Quadratures","title":"VortexPasta.Quadratures.GaussLegendre","text":"GaussLegendre(N) <: StaticSizeQuadrature{N}\n\nN-point Gauss–Legendre quadrature.\n\n\n\n\n\n","category":"type"},{"location":"modules/Quadratures/#VortexPasta.Quadratures.NoQuadrature","page":"Quadratures","title":"VortexPasta.Quadratures.NoQuadrature","text":"NoQuadrature() <: StaticSizeQuadrature{1}\n\nInexpensive 1-point quadrature rule.\n\nWhen integrating, evaluates approximated values at the segment midpoint. However, unlike a 1-point Gauss–Legendre quadrature, midpoint values are interpolated using a basic linear interpolation. In other words, segments are assumed to be straight.\n\n\n\n\n\n","category":"type"},{"location":"modules/Quadratures/#Variable-size-quadratures","page":"Quadratures","title":"Variable-size quadratures","text":"","category":"section"},{"location":"modules/Quadratures/","page":"Quadratures","title":"Quadratures","text":"These quadrature rules should be constructed just once, as they allocate vectors. These are usually adaptive quadratures.","category":"page"},{"location":"modules/Quadratures/","page":"Quadratures","title":"Quadratures","text":"PreallocatedQuadrature\nAdaptiveTanhSinh","category":"page"},{"location":"modules/Quadratures/#VortexPasta.Quadratures.PreallocatedQuadrature","page":"Quadratures","title":"VortexPasta.Quadratures.PreallocatedQuadrature","text":"PreallocatedQuadrature{T <: AbstractFloat} <: AbstractQuadrature\n\nAbstract type defining a preallocated quadrature with element type T.\n\nThis is generally used for adaptive quadratures.\n\n\n\n\n\n","category":"type"},{"location":"modules/Quadratures/#VortexPasta.Quadratures.AdaptiveTanhSinh","page":"Quadratures","title":"VortexPasta.Quadratures.AdaptiveTanhSinh","text":"AdaptiveTanhSinh([T = Float64]; nlevels = 10, rtol = sqrt(eps(T))) <: PreallocatedQuadrature{T}\n\nAdaptive tanh-sinh quadrature.\n\nBehaves well when there are singularities at (or near) the endpoints.\n\nIt can be easily made adaptive because it can be written as a simple trapezoidal rule after a change of variables.\n\nOptional arguments\n\nT = Float64: quadrature precision;\nnlevels = 10: maximum number of adaptivity levels. Must be ≥ 2;\nrtol = sqrt(eps(T)): relative tolerance.\n\nComputations are stopped either when the maximum adaptivity level is reached, or when the difference between two levels falls below the relative tolerance rtol.\n\nNote that the maximum number of function evaluations is 2^nlevels, so it can make sense to use a small number of levels (or a large tolerance) when function evaluations are expensive.\n\n\n\n\n\n","category":"type"},{"location":"modules/Quadratures/#Estimating-integrals","page":"Quadratures","title":"Estimating integrals","text":"","category":"section"},{"location":"modules/Quadratures/","page":"Quadratures","title":"Quadratures","text":"Quadratures.integrate","category":"page"},{"location":"modules/Quadratures/#VortexPasta.Quadratures.integrate","page":"Quadratures","title":"VortexPasta.Quadratures.integrate","text":"Quadratures.integrate(f::Function, quad::AbstractQuadrature, lims::NTuple{2,T})\nQuadratures.integrate(f::Function, quad::AbstractQuadrature, ::Type{T})\n\nIntegrate f(x) using the chosen quadrature.\n\nThere are two variants:\n\nThe first one requires passing the limits (a, b), which should be floats of the desired accuracy;\nthe second one assumes the default limits (0, 1), but requires setting the float type T. It may avoid some operations when the limits are (0, 1).\n\nIn both cases T must be a subtype of AbstractFloat (e.g. Float64).\n\nNote that T is simply ignored for adaptive quadratures such as AdaptiveTanhSinh, which preallocate the quadrature coefficients with a possibly different element type T′ (which can be chosen when creating the quadrature).\n\n\n\n\n\n","category":"function"},{"location":"modules/Quadratures/#Computing-quadrature-rules","page":"Quadratures","title":"Computing quadrature rules","text":"","category":"section"},{"location":"modules/Quadratures/","page":"Quadratures","title":"Quadratures","text":"quadrature","category":"page"},{"location":"modules/Quadratures/#VortexPasta.Quadratures.quadrature","page":"Quadratures","title":"VortexPasta.Quadratures.quadrature","text":"quadrature([T = Float64], q::StaticSizeQuadrature{N}) -> (xs, ws)\n\nReturn N-point quadrature rule valid in 0 1 interval.\n\nQuadrature nodes xs and weights ws are returned as tuples.\n\nThis only works for fixed-size (non-adaptive) quadrature rules such as GaussLegendre.\n\n\n\n\n\n","category":"function"},{"location":"modules/Quadratures/#Other-functions","page":"Quadratures","title":"Other functions","text":"","category":"section"},{"location":"modules/Quadratures/","page":"Quadratures","title":"Quadratures","text":"length","category":"page"},{"location":"modules/Quadratures/#Base.length","page":"Quadratures","title":"Base.length","text":"Base.length(q::StaticSizeQuadrature{N}) -> N\n\nReturn the number of points associated to the quadrature.\n\n\n\n\n\nBase.length(s::SegmentIterator{<:AbstractFilament}) -> Int\n\nReturn the number of segments in a filament.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"EditURL = \"../../literate/tutorials/02-kelvin_waves.jl\"","category":"page"},{"location":"tutorials/02-kelvin_waves/#tutorial-kelvin-waves","page":"Kelvin waves","title":"Kelvin waves","text":"","category":"section"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"This tutorial describes the simulation of Kelvin waves propagating along nearly-straight and infinite vortex lines.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Here we will:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"learn how to define infinite but unclosed filaments;\nlook at diagnostics such as the energy over time;\nperform spatial and temporal Fourier analysis to detect relevant wavenumbers and frequencies associated to Kelvin waves.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"It is recommended to first follow the vortex ring tutorial before following this tutorial.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Pages = [\"02-kelvin_waves.md\"]\nDepth = 2:3","category":"page"},{"location":"tutorials/02-kelvin_waves/#Physical-configuration","page":"Kelvin waves","title":"Physical configuration","text":"","category":"section"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"The idea of this tutorial is to study the time evolution of an infinite straight line slightly modified by a sinusoidal perturbation.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"We will consider such a vortex line in a cubic periodic domain of size L = 2π. The line is oriented in the z direction and modified by a perturbation of amplitude ϵL along x. The perturbation is periodic with period λ = Lm = 2πm where m is an integer representing the mode of the perturbation (relative to the domain size L).","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Such an infinite line bms = (x y z) can be parametrised as","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"beginalign*\n  x(t) = x_0 + ϵ  sin(2πmt) \n  y(t) = y_0 \n  z(t) = z_0 + left( t - frac12 right) L\nendalign*","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"for t  mathbbR. In particular, note that the line exactly crosses the domain after a period T = 1, going from bms(t) to bms(t + 1) = bms(t) + (0  0  L).","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"The analytical prediction is that, over time, a small perturbation should rotate around the vortex in the direction opposite to its circulation. Its frequency is given by (see e.g. Schwarz (1985)):","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"ω_textKW(k) = fracΓ k^24π left\n  lnleft( frac2k a right) - γ + frac12 - Δ\nright","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"where k = 2πmL is the perturbation wavenumber, γ  05772 the Euler–Mascheroni constant, Δ the vortex core parameter and a its radius (a  1k).","category":"page"},{"location":"tutorials/02-kelvin_waves/#Defining-an-unclosed-infinite-curve","page":"Kelvin waves","title":"Defining an unclosed infinite curve","text":"","category":"section"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Following the vortex ring tutorial, one may want to define such a line as follows:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"using VortexPasta\nusing VortexPasta.Filaments\nusing VortexPasta.Filaments: Vec3\n\nN = 64  # number of discretisation points per line\nm = 2    # perturbation mode\nL = 2π   # domain period\nx⃗₀ = Vec3(L/4, L/4, L/2)  # line \"origin\"\nϵ = 0.01\nts = range(0, 1; length = N + 1)[1:N]  # important: we exclude the endpoint (t = 1)\npoints = [x⃗₀ + Vec3(ϵ * L * sinpi(2m * t), 0, L * (t - 1/2)) for t ∈ ts]\nf = Filaments.init(ClosedFilament, points, QuinticSplineMethod())\nnothing  # hide","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Let's look at the result:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"using GLMakie\nset_theme!()  # hide\nGLMakie.activate!(px_per_unit = 2)  # hide\n\n# Give a colour to a filament based on its local orientation wrt Z.\nfunction filament_colour(f::AbstractFilament, refinement)\n    cs = Float32[]\n    ζs = range(0, 1; length = refinement + 1)[1:refinement]  # for interpolation\n    for seg ∈ segments(f), ζ ∈ ζs\n        colour = seg(ζ, UnitTangent())[3]  # in [-1, 1]\n        push!(cs, colour)\n    end\n    let seg = last(segments(f))  # \"close\" the curve\n        colour = seg(1.0, UnitTangent())[3]\n        push!(cs, colour)\n    end\n    cs\nend\n\n# Plot a list of filaments\nfunction plot_filaments(fs::AbstractVector)\n    fig = Figure()\n    ax = Axis3(fig[1, 1]; aspect = :data)\n    ticks = range(0, 2π; step = π/2)\n    tickformat(xs) = map(x -> string(x/π, \"π\"), xs)\n    ax.xticks = ax.yticks = ax.zticks = ticks\n    ax.xtickformat = ax.ytickformat = ax.ztickformat = tickformat\n    hidespines!(ax)\n    wireframe!(ax, Rect(0, 0, 0, L, L, L); color = (:black, 0.5), linewidth = 0.2)\n    for f ∈ fs\n        refinement = 4\n        color = filament_colour(f, refinement)\n        plot!(\n            ax, f;\n            refinement, color, colormap = :RdBu_9, colorrange = (-1, 1), markersize = 4,\n        )\n    end\n    fig\nend\n\n# Plot a single filament\nplot_filaments(f::AbstractFilament) = plot_filaments([f])\n\nplot_filaments(f)","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Things look almost as expected except for the fact that the line tries to close itself when it reaches the end. To avoid this, one needs to explicitly give Filaments.init an end-to-end vector via the offset keyword argument. In our case the end-to-end vector is bmΔ = (0 0 2π).","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"f = Filaments.init(ClosedFilament, points, QuinticSplineMethod(); offset = (0, 0, 2π))\nplot_filaments(f)","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Now everything looks fine! Note that the end-to-end vector corresponds to the separation between a node f[i] and the node f[i + N]. For example:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"@show f[end + 1] - f[begin]\n@show Vec3(0, 0, 2π)\nnothing  # hide","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"note: End-to-end vector\nThe end-to-end vector must be an integer multiple of the domain period, which in this case is (2π 2π 2π).","category":"page"},{"location":"tutorials/02-kelvin_waves/#Defining-a-curve-from-parametric-function","page":"Kelvin waves","title":"Defining a curve from parametric function","text":"","category":"section"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"The Filaments.init function actually allows to define a curve directly from its (continuous) parametric function. In this case one doesn't need to care about end-to-end vectors and \"offsets\", since these are usually encoded in the parametrisation.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"For example, for the curve above we would define the function:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"fcurve(t) = x⃗₀ + Vec3(\n    ϵ * L * sinpi(2 * m * t),\n    0,\n    (t - 0.5) * L,\n)","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"The function will be evaluated over the interval t  0 1. The only assumption is that the parametric function must either represent:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"a closed curve with period T = 1;\nan unclosed periodic curve which crosses the domain after a period T = 1.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Here we are in the second case, and the function above indeed satisfies this condition.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Now we just pass the function to Filaments.init:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"f′ = Filaments.init(fcurve, ClosedFilament, N, QuinticSplineMethod())\nnothing  # hide","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Note that this generates a filament which is practically identical to the previous one (just with a shift in the node positions, not really visible here):","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"plot_filaments([f, f′])","category":"page"},{"location":"tutorials/02-kelvin_waves/#Using-predefined-curves","page":"Kelvin waves","title":"Using predefined curves","text":"","category":"section"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"There is another convenient way of defining such curves, using the VortexPasta.PredefinedCurves module which provides definitions of parametric functions for commonly-used curves. As we will see in the next section, this is particularly convenient when we want to create multiple vortices which share the same geometry, but which have for instance different orientations or different spatial locations in the domain.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Here we want to use the PeriodicLine definitions, which allow one to pass arbitrary functions as perturbations. Note that curve definitions in PredefinedCurves are normalised. In particular, the period of PeriodicLine is 1, and the perturbation that we give it will be in terms of this unit period.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"using VortexPasta.PredefinedCurves: PeriodicLine, define_curve\nx_perturb(t) = ϵ * sinpi(2m * t)  # perturbation along x (takes t ∈ [0, 1])\np = PeriodicLine(x = x_perturb)   # this represents a line with period 1 along z\nnothing  # hide","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"We now want to \"convert\" this line to a parametric function which can be then evaluated to generate points. This is done using the define_curve function, which allows in particular to rescale the curve (we want a period of L = 2π instead of 1). We would also like the curve to be centred at bmx_0.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"S = define_curve(p; scale = L, translate = x⃗₀)\n@show S(0.0) S(0.5) S(1.0)\nnothing  # hide","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"As we can see, S is a function which can be evaluated at any value of t. In fact, S is identical to the fcurve function we defined above. We can now pass this function to Filaments.init to generate a filament:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"f = Filaments.init(S, ClosedFilament, N, QuinticSplineMethod())\nplot_filaments(f)","category":"page"},{"location":"tutorials/02-kelvin_waves/#Ensuring-periodicity-of-the-velocity","page":"Kelvin waves","title":"Ensuring periodicity of the velocity","text":"","category":"section"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"For now we have initialised one infinite unclosed filament. One needs to be careful when working with unclosed filaments in periodic domains. Indeed, a single straight vortex filament in a periodic domain generates a non-zero circulation along the domain boundaries (or equivalently, a non-zero mean vorticity), which violates the periodicity condition.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"The mean vorticity in the periodic domain is given by","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":" bmω \n= frac1V _Ω bmω(bmx)  mathrmd^3bmx\n= fracΓV _mathcalC mathrmdbms\n= fracΓV _mathcalC bms(t)  mathrmdt","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"where Ω represents the periodic domain and V = L^3 is its volume. So the last integral must be zero to ensure periodicity. It is quite obvious that this is not the case for the filament defined above, and we can readily verify it:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"integrate(f′, GaussLegendre(4)) do ff, i, ζ\n    ff(i, ζ, Derivative(1))\nend","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"This means that, for each vortex oriented in the +z direction, we need to compensate by a vortex oriented in the -z direction to obtain a zero total circulation.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"In practice, to make sure that the total circulation is zero and to stabilise the system, we want to have four vortices such that their coordinates respect mirror symmetry with respect to the planes x = L2 and y = L2. Respecting these two symmetries means that both planes effectively become impermeable (but free-slip) walls. That is, the velocity induced by the vortices on those planes can only be parallel to the planes and not normal to them. More generally, due to periodicity, all planes x = nL2 and y = nL2 (for integer n) effectively become impermeable walls.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Let's now create these four vortices:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"funcs = [\n    # \"Positive\" vortices\n    define_curve(p; scale = (+L, +L, +L), translate = (0.25L, 0.25L, 0.5L)),\n    define_curve(p; scale = (-L, -L, +L), translate = (0.75L, 0.75L, 0.5L)),  # mirror symmetry wrt x and y\n    # \"Negative\" vortices: we use the `orientation` keyword to flip their orientation.\n    define_curve(p; scale = (+L, -L, +L), translate = (0.25L, 0.75L, 0.5L), orientation = -1),  # mirror symmetry wrt y\n    define_curve(p; scale = (-L, +L, +L), translate = (0.75L, 0.25L, 0.5L), orientation = -1),  # mirror symmetry wrt x\n]\nfs = map(S -> Filaments.init(S, ClosedFilament, N, QuinticSplineMethod()), funcs)\nplot_filaments(fs)","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Here the colours represent the local orientation of the curve tangent with respect to the z axis. We can check that, when we sum the contributions of all filaments, the mean vorticity is zero:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"# This computes the integral along each filament and sums the results.\nsum(fs) do f\n    integrate(f, GaussLegendre(4)) do ff, i, ζ\n        f(i, ζ, Derivative(1))\n    end\nend","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Now we're ready to perform simulations.","category":"page"},{"location":"tutorials/02-kelvin_waves/#Simulating-Kelvin-waves","page":"Kelvin waves","title":"Simulating Kelvin waves","text":"","category":"section"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"As in the vortex ring tutorial, we use the Timestepping module to perform a temporal simulation of the configuration we just prepared.","category":"page"},{"location":"tutorials/02-kelvin_waves/#Setting-physical-and-numerical-parameters","page":"Kelvin waves","title":"Setting physical and numerical parameters","text":"","category":"section"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"We start by setting the parameters for Biot–Savart computations:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"using VortexPasta.BiotSavart\nM = floor(Int, 32 * 2/3)  # resolution of long-range grid\nkmax = π * (M - 1) / L    # maximum resolved wavenumber (Nyquist frequency) for long-range part\nβ = 3.5                   # accuracy parameter\nα = kmax / (2β)           # Ewald splitting parameter\n\nparams = ParamsBiotSavart(;\n    Γ = 1.0,    # vortex circulation\n    a = 1e-8,   # vortex core size\n    Δ = 1/4,    # vortex core parameter (1/4 for a constant vorticity distribution)\n    α = α,      # Ewald splitting parameter\n    Ls = (L, L, L),  # same domain size in all directions\n    Ns = (M, M, M),  # same long-range resolution in all directions\n    rcut = β / α,    # cut-off distance for short-range computations\n    quadrature = GaussLegendre(3),        # quadrature for integrals over filament segments\n    backend_long = NonuniformFFTsBackend(),  # this is the default\n    backend_short = CellListsBackend(2),\n)","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"We would like to compute a few periods of Kelvin wave oscillations. For this, we first compute the expected Kelvin wave frequency and its associated period:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"(; Γ, a, Δ,) = params         # extract parameters needed for KW frequency\nγ = MathConstants.eulergamma  # Euler–Mascheroni constant\nk = 2π * m / L\nω_kw = Γ * k^2 / (4 * π) * (\n    log(2 / (k * a)) - γ + 1/2 - Δ\n)\nT_kw = 2π / ω_kw              # expected Kelvin wave period","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"We create a VortexFilamentProblem to simulate a few Kelvin wave periods. To make things more interesting later when doing the temporal Fourier analysis of the results, we don't simulate an integer number of periods so that the results are not exactly time-periodic.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"using VortexPasta.Timestepping\ntspan = (0.0, 3.2 * T_kw)\nprob = VortexFilamentProblem(fs, tspan, params)","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"We now create a callback which will be used to store some data for further analysis. We will store the times and the position over time of a single filament node to be able to visualise and analyse the oscillations. Moreover, we will store the system energy to verify that energy is conserved over time (see VFM notes for detains on how it is computed). For computing the energy we use the kinetic_energy_from_streamfunction function from the Diagnostics module.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"using VortexPasta.Diagnostics\n\ntimes::Vector{Float64} = Float64[]\nX_probe::Vector{Vec3{Float64}} = Vec3{Float64}[]  # will contain positions of a chosen node\nenergy::Vector{Float64} = Float64[]\n\nfunction callback(iter)\n    (; nstep, t,) = iter\n    if nstep == 0  # make sure vectors are empty at the beginning of the simulation\n        empty!(times)\n        empty!(X_probe)\n        empty!(energy)\n    end\n    push!(times, t)\n    s⃗ = iter.fs[1][3]  # we choose a single node of a single filament\n    push!(X_probe, s⃗)\n    # Compute energy\n    E = Diagnostics.kinetic_energy_from_streamfunction(iter)\n    push!(energy, E)\n    nothing\nend","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Note that we have annotated the types of the variables times, X_probe and energy for performance reasons, since these are global variables which are used (and modified) from within the callback function. See here and here for details.","category":"page"},{"location":"tutorials/02-kelvin_waves/#tutorial-kelvin-waves-timestep","page":"Kelvin waves","title":"Choosing the timestep and the temporal scheme","text":"","category":"section"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"In the vortex ring tutorial we have used the standard RK4 scheme. To capture the vortex evolution and avoid blow-up, this scheme requires the timestep Δt to be of the order of the period of the fastest resolved Kelvin waves, which have a wavelength λ equal to (twice) the filament resolution δ (the typical distance between two discretisation points).","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"We first estimate the filament resolution using minimum_node_distance:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"δ = minimum_node_distance(prob.fs)  # should be close to L/N in our case","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Now we compute the Kelvin wave frequency associated to this distance:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"kelvin_wave_period(λ; a, Δ, Γ) = 2 * λ^2 / Γ / (log(λ / (π * a)) + 1/2 - (Δ + MathConstants.γ))\ndt_kw = kelvin_wave_period(δ; a, Δ, Γ)","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Note that this time scale is very small compared to the period of the large-scale Kelvin waves:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"T_kw / dt_kw","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"This means that we would need a relatively large simulation time to observe the evolution of large-scale Kelvin waves over multiple periods.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"For the RK4 scheme, this time scale really seems to set the maximum allowed timestep limit. We can check that a simulation with RK4 using dt = dt_kw remains stable. In particular, energy stays constant in time after running a few iterations with this timestep:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"iter = init(prob, RK4(); dt = dt_kw, callback)\nfor _ ∈ 1:40\n    step!(iter)\nend\nenergy'","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"However, using dt = 2 * dt_kw quickly leads to instability and energy blow-up:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"iter = init(prob, RK4(); dt = 2 * dt_kw, callback)\nfor _ ∈ 1:40\n    step!(iter)\nend\nenergy'","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"This limit is basically set by the short-range Biot–Savart interactions and in particular the local term (see Desingularisation), which presents fast temporal variations. On the upside, this term is cheap to compute, which means that we can take advantage of a splitting scheme (such as Strang splitting) to accelerate computations.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"The idea is to write the time evolution of a vortex point due to the Biot–Savart law as:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"fracmathrmdbmsmathrmdt = bmv(bms)\n= bmv_textlocal(bms) + bmv_textnon-local(bms)","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"where the local term bmv_textlocal(bms) represents the fast dynamics (thus requiring very small timesteps) while being cheap to compute, while the non-local term bmv_textnon-local(bms) represents the slow dynamics and has a higher computational cost.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Using a splitting method can make sense when it is easier or more convenient to separately solve the two equations:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"beginalign*\nfracmathrmdbmsmathrmdt = bmv_textlocal(bms)  quad  text(fast)\n\nfracmathrmdbmsmathrmdt = bmv_textnon-local(bms)  quad  text(slow)\nendalign*","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"In some applications, this is the case because one of the terms is linear or because one of the sub-equations can be solved analytically. This is not the case here, but this splitting is still convenient because it allows us to use different timesteps for each sub-equation. In particular, we can use a smaller timestep for the local (fast) term, which is the one that sets the timestep limit.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"One of the most popular (and classical) splitting methods is Strang splitting, which is second order in time. In this method, a single simulation timestep (t  t + Δt) is decomposed in 3 steps:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Advance solution bms(t)  bms_1 in the interval t  t + fracΔt2 using equation text(fast).\nAdvance solution bms_1  bms_2 in the interval t  t + Δt using equation text(slow).\nAdvance solution bms_2  bms(t + Δt) in the interval t + fracΔt2  t + Δt using equation text(fast).","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"In the following we use the Strang splitting scheme, which allows to use different explicit Runge–Kutta schemes for the \"fast\" and \"slow\" equations, and allows to set a smaller timestep to solve the former.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Concretely, we solve steps 1 and 3 using the standard RK4 scheme, while for step 2 the Midpoint scheme is used by default (but this can be changed, see Strang docs for details). Moreover, steps 1 and 3 are decomposed into M = 16 substeps, meaning that they are solved with a smaller timestep Δt_textfast = (Δt2)  M = Δt  32. In practice, this means that we can multiply our \"global\" timestep Δt by 32 and retain the stability of the solver.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"scheme = Strang(RK4(); nsubsteps = 16)\ndt = 32 * dt_kw","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"More generally, when using Strang splitting with the RK4 scheme for the fast dynamics, setting nsubsteps = M allows us to set the global timestep to dt = 2M * dt_kw. We could tune the number M of inner iterations to allow even larger timesteps, but this might lead to precision loss.","category":"page"},{"location":"tutorials/02-kelvin_waves/#Running-the-simulation","page":"Kelvin waves","title":"Running the simulation","text":"","category":"section"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"We now solve the full problem with this splitting scheme. Note that we use LocalTerm to identify the \"fast\" motions to the local (LIA) term of the Biot–Savart integrals. We could alternatively use ShortRangeTerm for a different interpretation of what represents the \"fast\" motions.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"iter = init(prob, scheme; dt, callback, fast_term = LocalTerm())\nreset_timer!(iter.to)  # to get more accurate timings (removes most of the compilation time)\nsolve!(iter)\niter.to","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"We can check that energy is conserved:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"energy'","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"We see that the energy seems to take the same value at all times. We can verify this quantitatively by looking at its standard deviation (normalised by the mean energy), which is negligible:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"using Statistics: mean, std\nEmean = mean(energy)\nEstd = std(energy)\nEstd / Emean","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"We now plot the evolution of the x and y coordinates of the closen filament node:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"using CairoMakie  # hide\nCairoMakie.activate!(type = \"svg\", pt_per_unit = 1.0, visible = false)  # hide\nfig = Figure()\nax = Axis(fig[1, 1]; xlabel = L\"t / T_{\\text{KW}}\", ylabel = \"Position\")\ntnorm = times ./ T_kw  # normalised time\nxpos = map(s⃗ -> s⃗[1], X_probe)  # get all X positions over time\nypos = map(s⃗ -> s⃗[2], X_probe)  # get all Y positions over time\nscatterlines!(ax, tnorm, xpos; marker = 'o', label = L\"x(t)\")\nscatterlines!(ax, tnorm, ypos; marker = 'o', label = L\"y(t)\")\nLegend(fig[1, 2], ax; orientation = :vertical, framevisible = false, padding = (0, 0, 0, 0), labelsize = 22, rowgap = 5)\nfig","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"We see that the x and y positions of the chosen point oscillate sinusoidally. The period of the oscillations are very close to the expected Kelvin wave period T_textKW.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"The oscillations above suggest circular trajectories, as we can check in the following figure:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"scatterlines(\n    xpos, ypos;\n    color = tnorm,\n    axis = (aspect = DataAspect(), xlabel = L\"x(t)\", ylabel = L\"y(t)\"),\n)","category":"page"},{"location":"tutorials/02-kelvin_waves/#Measuring-performance","page":"Kelvin waves","title":"Measuring performance","text":"","category":"section"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"The VortexPasta solver uses the TimerOutputs.jl package to estimate the time spent (and memory allocated) in different stages of the computation.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Accessing timing information is very simple, as it is all included in the to field of the VortexFilamentSolver:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"show(IOContext(stdout, :displaysize => (40, 100)), iter.to)  # hide\niter.to\nnothing  # hide","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"We can see that, in this particular case, the runtime is mostly dominated by the the LIA (local) term, which is computed much more often than the non-local interactions due to the use of a splitting scheme for the temporal evolution.","category":"page"},{"location":"tutorials/02-kelvin_waves/#Fourier-analysis","page":"Kelvin waves","title":"Fourier analysis","text":"","category":"section"},{"location":"tutorials/02-kelvin_waves/#Spatial-analysis","page":"Kelvin waves","title":"Spatial analysis","text":"","category":"section"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"The idea is to identify the spatial fluctuations of a single vortex with respect to the unperturbed filament. For this, we first write the perturbations in complex representation as a function of the z coordinate, i.e. w(z) = x(z) + i y(z).","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"We want to apply the FFT to these two functions. For this, we need all points of the vortex filament to be equispaced in z:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"f = iter.fs[1]               # vortex to analyse\nzs = getindex.(nodes(f), 3)  # z locations\nN = length(zs)\nzs_expected = range(zs[begin], zs[begin] + L; length = N + 1)[1:N]  # equispaced locations\nisapprox(zs, zs_expected; rtol = 1e-5)  # check that z locations are approximately equispaced","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Now that we have verified this, we define the complex function w(z) = x(z) + i y(z) and we perform a complex-to-complex FFT to obtain hatw(k):","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"xs = getindex.(nodes(f), 1)  # x locations\nys = getindex.(nodes(f), 2)  # y locations\nws = @. xs + im * ys\n\nusing FFTW: fft, fft!, fftfreq\nw_hat = fft(ws)\n@. w_hat = w_hat / N  # normalise FFT\n@show w_hat[1]       # the zero frequency gives the mean location\nw_hat[1] ≈ π/2 + π/2 * im  # we expect the mean location to be (π/2, π/2)","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"The associated wavenumbers are multiples of 2πΔz = 2πNL:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Δz = L / N\n@assert isapprox(Δz, zs[2] - zs[1]; rtol = 1e-4)\nks = fftfreq(N, 2π / Δz)\nks'  # should be integers if L = 2π","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Note that this includes positive and negative wavenumbers. More precisely, ks[2:N÷2] contains the positive wavenumbers, and ks[N÷2+1:end] contains the corresponding negative wavenumbers.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"We now want to compute the wave action spectrum n(k) = hatw(k)^2 + hatw(-k)^2, which is related to the amplitude of the oscillations at the scale λ = 2πk.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"function wave_action_spectrum(ks::AbstractVector, w_hat::AbstractVector)\n    @assert ks[2] == -ks[end]  # contains positive and negative wavenumbers\n    @assert length(ks) == length(w_hat)\n    N = length(ks)\n    dk = ks[2]  # this is the wavenumber increment\n    if iseven(N)\n        Nh = N ÷ 2\n        @assert ks[Nh + 1] ≈ -(ks[Nh] + dk)  # wavenumbers change sign after index Nh\n    else\n        Nh = N ÷ 2 + 1\n        @assert ks[Nh + 1] == -ks[Nh]  # wavenumbers change sign after index Nh\n    end\n    ks_pos = ks[2:Nh]  # only positive wavenumbers\n    nk = similar(ks_pos)\n    for j ∈ eachindex(ks_pos)\n        local k = ks_pos[j]\n        i⁺ = 1 + j      # index of coefficient corresponding to wavenumber +k\n        i⁻ = N + 1 - j  # index of coefficient corresponding to wavenumber -k\n        @assert ks[i⁺] == -ks[i⁻] == k  # verification\n        nk[j] = abs2(w_hat[i⁺]) + abs2(w_hat[i⁻])\n    end\n    ks_pos, nk\nend\n\nks_pos, nk = wave_action_spectrum(ks, w_hat)\nnk_normalised = nk ./ ((ϵ * L)^2 / 2)\nsum(nk_normalised)  # we expect the sum to be 1","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"We can finally plot the final state:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"fig = Figure()\nax = Axis(fig[1, 1]; xscale = log10, yscale = log10, xlabel = L\"k\", ylabel = L\"2 \\, n(k) / A^2\", xlabelsize = 20, ylabelsize = 20)\nscatterlines!(ax, ks_pos, nk_normalised)\nxlims!(ax, 0.8 * ks_pos[begin], nothing)\nylims!(ax, 1e-30, 1e1)\nvlines!(ax, ks_pos[m]; linestyle = :dash, color = :orangered)\nfig","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"We see that the wave action spectrum is strongly peaked at the wavenumber k = 2πmL (dashed vertical line) corresponding to the perturbation mode m we chose at the beginning. Note that the other peaks (which here are about 6 orders of magnitude smaller than the main peak) are not numerical artefacts. Instead, these peaks appearing at wavenumbers q = k (1 + 2n) for integer n can be explained analytically (see box below). Their relative magnitude should further decrease if one decreases the perturbation amplitude.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"details: A kind of proof using LIA\nOne way to illustrate this analytically is using the local induction approximation (LIA). Let's consider the perturbed line bms(z) = ϵ sin(z) 0 z parametrised by the z coordinate. The LIA can be written asbmv_textLIA = C fracbms  bmsbms^3where C is (roughly) a constant. Derivatives are with respect to the chosen parametrisation (which can differ from the \"natural\" arc-length parametrisation), hence the normalising factor in the denominator.In our case we have bms = ϵ cos(z) 0 1 and bms = -ϵ sin(z) 0 0, and thusv_textLIA = fracC ϵ sin(z)(1 + ϵ^2 cos^2 z)^32Using a Taylor expansion, one can easily show that the denominator introduces fluctuations over the odd harmonics q = 1 + 2n for n   1 2 3  :v_textLIA = C ϵ sin(z) left1 - frac32 ϵ^2 cos^2 z + mathcalO(ϵ^4) rightNoting that sin(z) cos^2(z) = sin(z) + sin(3z)  4, one clearly sees that the term in ϵ^2 excites modes at wavenumber q = 3, i.e. the third harmonic of the perturbed mode k = 1. Since the contribution is proportional to ϵ^2, this non-linear effect should be negligible for very small perturbation amplitudes. It is easy to see that all of this generalises to all odd harmonics q = 1 + 2n by taking into account higher-order terms of the Taylor expansion.In the tutorial, we initially perturbed the mode k = 2, which excites its odd harmonics q = k (1 + 2n) = 6 10 14  as seen in the above figure.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"We also see that the sum _k n(k) (which is basically just the value of the main peak in this case) is equal to A^22, where A = ϵL is the amplitude of the initial perturbation.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"The main conclusion is that, when we perturb a single Kelvin wave mode as we did here, that original mode is exactly preserved over time (except for negligible high-order effects).","category":"page"},{"location":"tutorials/02-kelvin_waves/#tutorial-kelvin-waves-temporal-analysis","page":"Kelvin waves","title":"Temporal analysis","text":"","category":"section"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"We can do something similar to analyse the temporal oscillations of the filament. For example, we can take the same temporal data we analysed before, corresponding to the position of a single filament node:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"xt = getindex.(X_probe, 1)  # x positions of a single node over time\nyt = getindex.(X_probe, 2)  # y positions of a single node over time\nzt = getindex.(X_probe, 3)  # z positions of a single node over time\nstd(zt) / mean(zt)    # ideally, the z positions shouldn't change over time","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Similarly to before, we now write w(t) = x(t) + i y(t) and perform an FFT:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"inds_t = eachindex(times)[begin:end - 1]  # don't consider the last time to make sure the timestep Δt is constant\nwt = @views @. xt[inds_t] + im * yt[inds_t]\nNt = length(wt)           # number of time snapshots\nΔt = times[2] - times[1]  # timestep\n@assert times[begin:end-1] ≈ range(times[begin], times[end-1]; length = Nt)  # check that times are equispaced\nw_hat = fft(wt)\n@. w_hat = w_hat / Nt  # normalise FFT\nωs = fftfreq(Nt, 2π / Δt)\n\nωs_pos, nω = wave_action_spectrum(ωs, w_hat)\nωs_normalised = ωs_pos ./ ω_kw  # normalise by expected KW frequency\n\nfig = Figure()\nax = Axis(fig[1, 1], xscale = log10, yscale = log10, xlabel = L\"ω / ω_{\\text{kw}}\", ylabel = L\"n(ω)\", xlabelsize = 20, ylabelsize = 20)\nscatterlines!(ax, ωs_normalised, nω; label = \"Original signal\")\nxlims!(ax, 0.8 * ωs_normalised[begin], 1.2 * ωs_normalised[end])\nvlines!(ax, 1.0; linestyle = :dash, color = :orangered)\nfig","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"We see that the temporal spectrum is strongly peaked near the analytical Kelvin wave frequency (dashed vertical line). However, since the trajectory is not perfectly periodic in time (the signal is discontinuous when going from the final time to the initial time), other frequencies are also present in the spectrum (this is known as spectral leakage).","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"To reduce the effect of spectral leakage, the usual solution is to apply a window function to the original signal to make it periodic. There are many examples of window functions which are commonly used in signal processing.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"Here we use the DSP.jl package which includes many definitions of window functions. Note that we first need to subtract the mean value from our input signal before multiplying it by the window function. Below we compare the previous temporal spectrum with the one obtained after applying the Hann window:","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"using DSP: DSP\n\nwt_mean = mean(wt)\nwindow = DSP.Windows.hanning(Nt)\nwt_windowed = @. (wt - wt_mean) * window\nw_hat = fft(wt_windowed)\n@. w_hat = w_hat / Nt  # normalise FFT\n_, nω_windowed = wave_action_spectrum(ωs, w_hat)\n\nscatterlines!(ax, ωs_normalised, nω_windowed; label = \"Windowed signal\")\nLegend(fig[0, 1], ax; orientation = :horizontal, framevisible = false, colgap = 32, patchsize = (40, 10))\nrowgap!(fig[:, 1].layout, 6)  # reduce gap between plot and legend (default gap is 18)\nfig","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"The new spectrum is still peaked near the expected frequency, while artificial modes far from this frequency are strongly damped compared to the original spectrum. Note however that windowing tends to smoothen the spectrum around the analytical Kelvin wave frequency.","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"","category":"page"},{"location":"tutorials/02-kelvin_waves/","page":"Kelvin waves","title":"Kelvin waves","text":"This page was generated using Literate.jl.","category":"page"},{"location":"modules/CellLists/#CellLists","page":"CellLists","title":"CellLists","text":"","category":"section"},{"location":"modules/CellLists/","page":"CellLists","title":"CellLists","text":"CurrentModule = VortexPasta.CellLists\nCollapsedDocStrings = true","category":"page"},{"location":"modules/CellLists/","page":"CellLists","title":"CellLists","text":"CellLists","category":"page"},{"location":"modules/CellLists/#VortexPasta.CellLists","page":"CellLists","title":"VortexPasta.CellLists","text":"CellLists\n\nModule implementing the cell lists algorithm over N-dimensional periodic domains.\n\nSee the Wikipedia article for some details.\n\n\n\n\n\n","category":"module"},{"location":"modules/CellLists/#Types","page":"CellLists","title":"Types","text":"","category":"section"},{"location":"modules/CellLists/","page":"CellLists","title":"CellLists","text":"PeriodicCellList","category":"page"},{"location":"modules/CellLists/#VortexPasta.CellLists.PeriodicCellList","page":"CellLists","title":"VortexPasta.CellLists.PeriodicCellList","text":"PeriodicCellList{N, T}\nPeriodicCellList(\n    ::Type{T}, rs_cut::NTuple{N, Real}, periods::NTuple{N, Real},\n    [nsubdiv = static(1)];\n    [to_coordinate::Function = identity],\n)\n\nConstruct a cell list for dealing with pair interactions.\n\nAbove, N is the number of spatial dimensions, and T is the type of each element. In the simplest cases, T can simply describe a coordinate in N-dimensional space (e.g. T = SVector{N, Float64}). One can also deal with more complicated elements which include more information. As an example, see further below for how to deal with filament segments in 3D space.\n\nThe cutoff radii rs_cut (which can be different in each direction) don't need to exactly divide the domain period L into equal pieces, but it's recommended that it does so for performance reasons.\n\nOptionally, one can choose to subdivide each cell (of size ≈ rcut) onto nsubdiv subcells. This can significantly improve performance, since it allows to discard some spurious pair interactions (i.e. beyond the chosen cutoff radius) as described here. In practice, a value of 2 or 3 can significantly improve performance compared to no subdivision (1). For convenience, it can be passed as nsubdiv = Val(M) or as nsubdiv = static(M).\n\nInfinite non-periodic domains (in the sense of period = Infinity()) are not supported.\n\nDealing with filament segments\n\nOne of the possible uses of PeriodicCellList is to classify filament segments (which are typically shorter than the cutoff radius) according to their spatial location. In that case, T is not a simple coordinate, but may contain more information including things like (1) the filament the segment belongs to, and (2) the location of the segment within the filament. As there is no unique way of associating a coordinate to a segment, one should pass the to_coordinate argument which \"converts\" the segment to a coordinate in space. For instance, the passed to_coordinate function may return the midpoint of the segment, which will be used to determine the cell associated to the segment.\n\nThe applied cutoff radius r_textcut should be much larger than the maximum segment length ℓ, or should at least account for ℓ. Basically, if one wants an actual cut-off radius r₀, then the applied cutoff radius passed to the constructor should be r_textcut = r₀ + ℓ. Otherwise, a small amount of interactions within r₀ - ℓ r₀ may be missed.\n\n\n\n\n\n","category":"type"},{"location":"modules/CellLists/#Functions","page":"CellLists","title":"Functions","text":"","category":"section"},{"location":"modules/CellLists/","page":"CellLists","title":"CellLists","text":"add_element!\nfinalise_cells!\nempty!\nnearby_elements","category":"page"},{"location":"modules/CellLists/#VortexPasta.CellLists.add_element!","page":"CellLists","title":"VortexPasta.CellLists.add_element!","text":"add_element!(cl::PeriodicCellList{N, T}, el::T, [x⃗])\n\nAdd element to the cell list.\n\nDetermines the cell associated to the element and then appends the element to that cell.\n\nOptionally, one may pass the coordinate location x associated to the element. Otherwise, it will be obtained from the element according to\n\nx⃗ = to_coordinate(el)\n\nwhere to_coordinate corresponds to the keyword argument of PeriodicCellList.\n\n\n\n\n\n","category":"function"},{"location":"modules/CellLists/#VortexPasta.CellLists.finalise_cells!","page":"CellLists","title":"VortexPasta.CellLists.finalise_cells!","text":"CellLists.finalise_cells!(cl::PeriodicCellList)\n\n\"Finalise\" cells before iterating over its elements.\n\nThis function performs operations needed to iterate over elements of the cell lists, such as filling ghost cells. It must be called once after all elements have been added to the cell list using add_element! and before one starts iterating using nearby_elements.\n\n\n\n\n\n","category":"function"},{"location":"modules/CellLists/#Base.empty!","page":"CellLists","title":"Base.empty!","text":"Base.empty!(tsf::TimeSeriesFile)\n\nReset TimeSeriesFile, removing all entries.\n\n\n\n\n\nBase.empty!(cl::PeriodicCellList) -> cl\n\nRemove all elements from the cell list.\n\n\n\n\n\n","category":"function"},{"location":"modules/CellLists/#VortexPasta.CellLists.nearby_elements","page":"CellLists","title":"VortexPasta.CellLists.nearby_elements","text":"nearby_elements(cl::PeriodicCellList{N}, x⃗)\n\nReturn an iterator over the elements that are sufficiently close to the point x⃗.\n\nThe iterator returns the elements which are likely to be within the cutoff radius of the point x⃗. More precisely, it returns elements in the same cell as x⃗ as well as in neighbouring cells.\n\nHere x⃗ should be a coordinate, usually represented by an SVector{N} or an NTuple{N}.\n\n\n\n\n\n","category":"function"},{"location":"tips/parallelisation/#Parallelisation","page":"Parallelisation","title":"Parallelisation","text":"","category":"section"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"VortexPasta.jl can take advantage of thread-based CPU parallelisation (equivalent to OpenMP). In particular, it can be run on a single node of a computing cluster.","category":"page"},{"location":"tips/parallelisation/#Starting-Julia-with-multiple-threads","page":"Parallelisation","title":"Starting Julia with multiple threads","text":"","category":"section"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"There are a few ways of starting Julia with multiple threads:","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"either via the JULIA_NUM_THREADS environment variable,\nor via the -t / --threads command-line option.","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"If both are used, the second takes precedence.","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"The command-line flag can be used in two ways:","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"$ julia -t 8     # start Julia with 8 threads\n$ julia -t auto  # start Julia with the number of CPUs available to this Julia process","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"The second option can be useful in particular when running SLURM jobs, as Julia will use the number of CPUs associated to the SLURM allocation.","category":"page"},{"location":"tips/parallelisation/#Pinning-threads","page":"Parallelisation","title":"Pinning threads","text":"","category":"section"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"When Julia is started with multiple threads, it can (and often does) assign more than one thread to the same CPU, even when the requested number of threads is smaller or equal to the total number of CPUs. This is clearly suboptimal.","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"The ThreadPinning.jl package solves this issue. The easiest way to use it by putting the following lines at the top of your Julia script:","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"using ThreadPinning\npinthreads(:cores)","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"Note that this should be changed when using SLURM.","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"One can then check that threads are correctly pinned to separate CPUs using threadinfo.","category":"page"},{"location":"tips/parallelisation/#slurm-job","page":"Parallelisation","title":"Running SLURM jobs","text":"","category":"section"},{"location":"tips/parallelisation/#slurm-submitting-jobs","page":"Parallelisation","title":"Submitting jobs","text":"","category":"section"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"Here is a sample SLURM script for running a simulation on which can be submitted using sbatch:","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"#!/bin/bash\n\n#SBATCH --job-name=\"JOB_NAME\"\n#SBATCH --partition=PARTITION_NAME_ON_CLUSTER\n#SBATCH --time=1:00:00\n#SBATCH --distribution=block:block\n#SBATCH --nodes=1\n#SBATCH --ntasks=1\n#SBATCH --hint=nomultithread\n#SBATCH --cpus-per-task=32\n#SBATCH --exclusive\n#SBATCH --mem=120G\n#SBATCH --threads-per-core=1\n\necho \" - SLURM_JOB_ID = $SLURM_JOB_ID\"\necho \" - SLURM_JOB_NODELIST = $SLURM_JOB_NODELIST\"\necho \" - SLURM_TASKS_PER_NODE = $SLURM_TASKS_PER_NODE\"\necho \" - SLURM_CPUS_PER_TASK = $SLURM_CPUS_PER_TASK\"\n\nsrun --cpu-bind=verbose,cores julia -t auto --heap-size-hint=100G --project=. script.jl","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"Here the number of threads is set via the --cpus-per-task option.","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"Some other notes:","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"the --exclusive flag is optional; it is recommended if one wants to use a full node (i.e. if the number of requested CPUs corresponds to the total number of CPUs on a node);\nabove, we passed the --heap-size-hint=100G option to the julia command. This may help avoid out of memory errors, by telling Julia's garbage collector that the total used memory should stay below the specified value. Just to be sure, we also explicitly requested a (slightly larger) amount of memory to SLURM using the --mem option;\nthe --hint=nomultithread option tells SLURM to avoid using hyperthreading, which is generally not good for performance.","category":"page"},{"location":"tips/parallelisation/#Pinning-SLURM-threads","page":"Parallelisation","title":"Pinning SLURM threads","text":"","category":"section"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"As mentioned above, it is a good idea to pin Julia threads to the CPUs available to the Julia process.","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"When using SLURM, one can achieve this by using the :affinitymask criterion in ThreadPinning's pinthreads:","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"using ThreadPinning\npinthreads(:affinitymask)","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"It can be convenient to have a Julia script which does the Right Thing (TM) depending on whether it runs within a SLURM job or not. To achieve this, one can do:","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"using ThreadPinning\n\nif haskey(ENV, \"SLURM_JOB_ID\")\n    pinthreads(:affinitymask)\nelse\n    pinthreads(:cores)\nend","category":"page"},{"location":"tips/parallelisation/#Using-MKL-FFT-routines","page":"Parallelisation","title":"Using MKL FFT routines","text":"","category":"section"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"The default NonuniformFFTsBackend in VortexPasta.jl computes threaded FFTs using the FFTW.jl package, which by default wraps the FFTW libraries written in C. However, FFTW.jl has an unresolved issue which can be encountered (somewhat randomly) when computing FFTs using a large number of threads.","category":"page"},{"location":"tips/parallelisation/#Switching-to-MKL-in-FFTW.jl","page":"Parallelisation","title":"Switching to MKL in FFTW.jl","text":"","category":"section"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"One workaround is to switch to the FFT implementation in Intel's MKL libraries, which don't seem to display this issue. The FFTW.jl package makes it easy to switch to the MKL implementation via their FFTW interface.","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"One simply needs to do:","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"using FFTW\nFFTW.set_provider!(\"mkl\")","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"and restart Julia. This will create (or update) a LocalPreferences.toml file next to the Project.toml file associated to the active Julia project.","category":"page"},{"location":"tips/parallelisation/#Correctly-using-threads-with-MKL","page":"Parallelisation","title":"Correctly using threads with MKL","text":"","category":"section"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"The above change is not enough if one wants MKL's FFTs to be efficient when using threads. One also needs to set the following environment variables (for example in a SLURM script):","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"export MKL_NUM_THREADS=$SLURM_CPUS_PER_TASK      # on SLURM\nexport MKL_NUM_THREADS=$NUMBER_OF_JULIA_THREADS  # in general\nexport MKL_DYNAMIC=false","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"The MKL_DYNAMIC=false option tells MKL not to mess around with thread pinning.","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"Secondly, one also needs to add:","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"using MKL","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"at the start of the Julia script to be run (one may need to ]add MKL first). Failing to do this can really degrade performance.","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"Note that one can also set the environment variables directly in the Julia script. Including thread pinning, the beginning of the Julia script could look like:","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"using MKL\nusing ThreadPinning\n\nENV[\"MKL_NUM_THREADS\"] = Threads.nthreads()  # same as number of Julia threads\nENV[\"MKL_DYNAMIC\"] = false\n\nif haskey(ENV, \"SLURM_JOB_ID\")\n    pinthreads(:affinitymask)\nelse\n    pinthreads(:cores)\nend\n\n# Tell threadinfo to give us information about BLAS (and MKL) and optionally about the SLURM set-up.\nthreadinfo(blas = true, hints = true, slurm = haskey(ENV, \"SLURM_JOB_ID\"))","category":"page"},{"location":"tips/parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"Note that, with the hints = true option, ThreadPinning will complain about our choice of using MKL_NUM_THREADS = number_of_julia_threads. This warning can be ignored, since FFTs are executed from a single Julia thread and it's therefore what we want.","category":"page"},{"location":"methods/Ewald/#methods-Ewald","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"","category":"section"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"The main originality of the VortexPasta solver is that it adapts the Ewald summation method to accelerate the computation of the Biot–Savart law along vortex filaments. See for example Arnold and Holm (2005) for a nice introduction to Ewald methods applied to the electrostatic interaction between point charges.","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"The adaptation of these methods to the vortex filament model is described in Polanco (2024). That paper also explains the role of the different parameters entering the method on accuracy and performance.","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"Pages = [\"Ewald.md\"]\nDepth = 2:3","category":"page"},{"location":"methods/Ewald/#Splitting-the-Biot–Savart-integral","page":"Ewald summation for Biot–Savart","title":"Splitting the Biot–Savart integral","text":"","category":"section"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"The basic idea of the method is to split the Biot–Savart integral into short- and long-range parts:","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"beginalign*\n    bmv(bmx)\n    = fracΓ4π _mathcalC\n    frac(bms - bmx) times mathrmdbmsbms - bmx^3\n    \n    = fracΓ4π _mathcalC\n    Big g^(bms - bmx) + g^(bms - bmx) Big\n    frac(bms - bmx) times mathrmdbmsbms - bmx^3\n    \n    = bmv^(bmx) + bmv^(bmx)\nendalign*","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"where the short-range and long-range scalar functions g^(r) and g^(r) have the properties:","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"g^(r) + g^(r) = 1 for all r  0;\ng^(r) decays exponentially with r, so that long-range interactions can be neglected beyond some cut-off distance r_textcut when computing the short-range velocity bmv^;\ng^(r)  r^2 is non-singular and smooth at r = 0, which implies that g^(r) must quickly tend to 0 as r  0. In periodic domains, this enables the use of the fast Fourier transform (FFT) to efficiently estimate long-range interactions.","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"The traditional choice of splitting functions satisfying all these properties is:","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"beginalign*\n    g^(r) = operatornameerfc(αr) + frac2αrsqrtπ e^-α^2 r^2\n    \n    g^(r) = operatornameerf(αr) - frac2αrsqrtπ e^-α^2 r^2\nendalign*","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"Here operatornameerf and operatornameerfc are respectively the error function and the complementary error function, which satisfy operatornameerf(z) + operatornameerfc(z) = 1. Above we have introduced the Ewald splitting parameter α, which is the inverse of a length scale. This parameter is purely numerical and, in theory, its choice has no impact on the final result bmv(bmx). In practice this is the case as long as other numerical parameters are well chosen (see discussion further below).","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"The two splitting functions are plotted below. In the horizontal axis, the scale r is non-dimensionalised by the splitting parameter α. Note that the long-range splitting function is smooth at r = 0 and has the Taylor expansion g^(r) = frac43 sqrtπ (αr)^3 + mathcalO(r^5). Also plotted are the two error functions. Note in particular that, for small r, operatornameerf(αr) = 2αrsqrtπ + mathcalO(r^3).","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"(Image: )","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"details: Code for this figure\nusing SpecialFunctions: erf, erfc\nusing CairoMakie\nCairoMakie.activate!(type = \"svg\", pt_per_unit = 1.0)  # hide\nMakie.set_theme!()  # hide\nrs = 2.0.^(-4:0.1:3)\ngs(αr) = erfc(αr) + 2αr / sqrt(π) * exp(-αr^2)  # short-range\ngl(αr) =  erf(αr) - 2αr / sqrt(π) * exp(-αr^2)  # long-range\nxticks = LogTicks(-4:1:3)\nyticks = LogTicks(-16:4:0)\nfig = Figure(size = (600, 400), fontsize = 18)\nax = Axis(fig[1, 1]; xticks, yticks, xscale = log2, yscale = log10, xlabel = L\"αr\", ylabel = \"Splitting function\")\nylims!(ax, 1e-17, 4)\nls = lines!(ax, rs, gs.(rs); label = L\"g^<(r)\")\nll = lines!(ax, rs, gl.(rs); label = L\"g^>(r)\")\nlines!(ax, rs, erfc.(rs); label = L\"\\mathrm{erfc}(αr)\", linestyle = :dot, color = ls.color)\nlines!(ax, rs, erf.(rs); label = L\"\\mathrm{erf}(αr)\", linestyle = :dot, color = ll.color)\nlet rs = 2.0.^(range(-4, -1; length = 3)), color = :grey20  # plot ~r^3 slope\n    ys = @. 0.2 * rs^3\n    lines!(ax, rs, ys; linestyle = :dash, color)\n    text!(ax, rs[2], ys[2]; text = L\"r^3\", align = (:left, :top), color)\nend\nlet rs = 2.0.^(range(-4, -2; length = 3)), color = :grey20  # plot ~r^1 slope\n    ys = @. 0.5 * (2 / sqrt(π)) * rs\n    lines!(ax, rs, ys; linestyle = :dash, color)\n    text!(ax, rs[2], ys[2]; text = L\"r\", align = (:left, :top), color)\nend\naxislegend(ax; position = (0, 0), labelsize = 20)\nsave(\"splitting_functions.svg\", fig)\nnothing  # hide","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"For small αr, the long-range splitting function goes to zero as r^3, consistently with its Taylor expansion. This means that, as we wanted, g^(r)  r^2 is non-singular and smooth at r = 0.","category":"page"},{"location":"methods/Ewald/#Short-range-velocity","page":"Ewald summation for Biot–Savart","title":"Short-range velocity","text":"","category":"section"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"As seen in the figure above, the short-range splitting function is dominant for small αr, while it decays exponentially to 0 for large αr. In particular, for r  5α, its value decays below about 10^-10, meaning that it is safe to set the cut-off distance r_textcut around this value.","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"Therefore, the short-range velocity is obtained as","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"bmv^(bmx) =\nfracGamma4π _bms - bmx  r_textcut\ng^(bms - bmx)\nfrac(bms - bmx) times mathrmdbmsbms - bmx^3","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"i.e. the integral is performed over vortex points which are sufficiently close to the point of interest bmx. Moreover, integrals are estimated using numerical integration.","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"Note that one can use a cell lists algorithm to further speed-up the search for nearby points.","category":"page"},{"location":"methods/Ewald/#Long-range-velocity","page":"Ewald summation for Biot–Savart","title":"Long-range velocity","text":"","category":"section"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"The long-range velocity bmv^ has a simple physical interpretation. Indeed, it can be shown, by differentiating the splitting functions defined above, that its associated long-range vorticity bmω^(bmx)  bm  bmv^(bmx) is nothing else that a Gaussian-filtered version of the actual vorticity field induced by the vortex filaments (which is singular).","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"More precisely, the long-range vorticity is given by the convolution bmω^ = H  bmω, where H(bmr) = (α  sqrtπ)^3  e^-α^2 r^2 is a 3D Gaussian kernel. Intuitively, this means that the long-range velocity bmv^ corresponds to the velocity induced by a coarse-grained version of the vortex filaments. In this view, vortices are not \"infinitesimal\" anymore, but are closer to the smooth vortices which we are used to see in classical viscous fluids. In periodic domains, such a smooth vorticity field can be accurately and efficiently expanded in Fourier series, and the curl operator can be readily inverted in Fourier space to obtain the coarse-grained velocity field bmv^.","category":"page"},{"location":"methods/Ewald/#1.-Estimating-the-vorticity-in-Fourier-space","page":"Ewald summation for Biot–Savart","title":"1. Estimating the vorticity in Fourier space","text":"","category":"section"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"The idea is to first expand the (actual) vorticity field in Fourier series:","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"bmω(bmx) = Γ _mathcalC δ(bmx - bms)  mathrmdbms\n= _bmk hatbmω(bmk)  e^i bmk  bmx\nquadtextfor  bmk  bmK","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"Here L is the domain period (assumed the same in all directions for simplicity), and bmK = left frac2π bmnL bmn  mathbbZ^3 right is the set of wavenumbers associated to the Fourier series expansion. The Fourier coefficients hatbmω(bmk) are given by","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"hatbmω(bmk)\n= frac1L^3  bmω(bmx)  e^-i bmk  bmx  mathrmdbmx\n= fracΓL^3 _mathcalC e^-i bmk  bms  mathrmdbms","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"To estimate this integral, we discretise the curves defining the support mathcalC of the vortex filaments, leading to a weighted sum over discrete points bmx_i:","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"hatbmω(bmk)\n fracΓL^3 _j bmw_i  e^-i bmk  bmx_i","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"The weights are related to the length of the discrete segments and to the quadrature rule used to estimate the integrals over segments (see the Numerical integration section). The important point here is that, since the discrete points are generally not on an equispaced grid, one cannot directly use the fast Fourier transform (FFT) to efficiently evaluate these coefficients. Nevertheless, they can be efficiently and accurately estimated using the non-uniform FFT (NUFFT) algorithm. More precisely, this corresponds to a type-1 NUFFT, which converts from non-uniform sources in physical space to uniform wavenumbers bmk in Fourier space.","category":"page"},{"location":"methods/Ewald/#2.-Coarse-grained-vorticity-and-velocity-in-Fourier-space","page":"Ewald summation for Biot–Savart","title":"2. Coarse-grained vorticity and velocity in Fourier space","text":"","category":"section"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"Once we have obtained the hatbmω(bmk) coefficients, obtaining the Fourier coefficients for the coarse-grained vorticity and coarse-grained velocity is straightforward. The former is obtained by convolution with a Gaussian, which is simply a product in Fourier space:","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"hatbmω^(bmk)\n= hatbmω(bmk)  e^-k^2  4α^2 quadtextwhere  k = bmk","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"Similarly, the curl operator can be easily inverted in Fourier space to get the coarse-grained velocity:","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"hatbmv^(bmk)\n= fraci bmkk^2  hatbmω^(bmk)\n= fraci bmkk^2  hatbmω(bmk)  e^-k^2  4α^2\nquadtextfor  k  0","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"warning: Zero mean vorticity condition\nThe velocity is well defined only if hatbmω(bm0) = bm0, that is, if the mean vorticity of the vortex filament system is zero. Otherwise we get division by zero, which is related to the fact that we're dealing with an infinitely periodic system and energy diverges with a non-zero mean vorticity.This condition is automatically satisfied when dealing with closed vortex filaments. This may however not be the case for infinite filaments (for instance, putting a single straight infinite filament in the domain is ill-defined).","category":"page"},{"location":"methods/Ewald/#Ewald-notes-kmax","page":"Ewald summation for Biot–Savart","title":"3. Notes on required resolution","text":"","category":"section"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"Above we have assumed that we can evaluate Fourier coefficients for any wavenumber bmk. In fact, for practical reasons, we cannot evaluate all coefficients hatbmω(bmk) for every possible bmk, and we need to set the number of wavenumbers N to compute in each direction (this is the parameter one tunes in NUFFT implementations). In other words, we need to truncate the estimations at some maximum wavenumber, namely the Nyquist frequency, which is related to N by k_textmax = π N  L.","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"Similarly to the cut-off distance in physical space, one can expect that the appropriate value of k_textmax (which is an inverse length scale) to get good accuracy should be proportional to the Ewald splitting parameter α. A rule of thumb is to choose a wavenumber at which the Gaussian factor e^-k_textmax^2  4α^2 matches the desired accuracy. For instance, at k_textmax = 8α, this factor has dropped to about 10^-7 (see figure below). Of course, one can vary the k_textmax  α ratio depending on the wanted accuracy.","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"(Image: )","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"details: Code for this figure\nusing CairoMakie\nCairoMakie.activate!(type = \"svg\", pt_per_unit = 1.0)  # hide\nMakie.set_theme!()  # hide\nks_α = range(0, 12.2; step = 0.1)\nxticks = 0:12\nyticks = LogTicks(-16:2:0)\nys = @. exp(-ks_α^2 / 4)\nlines(\n    ks_α, ys;\n    axis = (yscale = log10, xticks, yticks, xlabel = L\"k/α\", ylabel = L\"\\exp \\, \\left[ -k^2 / 4α^2 \\right]\",),\n    figure = (fontsize = 20, size = (600, 400),),\n)\nsave(\"gaussian_kalpha.svg\", current_figure())\nnothing  # hide","category":"page"},{"location":"methods/Ewald/#4.-Physical-velocity-at-filament-locations","page":"Ewald summation for Biot–Savart","title":"4. Physical velocity at filament locations","text":"","category":"section"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"The last step is to evaluate, from the coarse-grained velocity hatbmv^(bmk) in Fourier space, the physical coarse-grained velocity bmv^(bms) on vortex filament locations bms (which, once again, are generally not on a regular grid). This operation can be written as:","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"bmv^(bms_i) = _bmk hatbmv^(bmk)  e^i bmk  bms_i","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"for a set of locations bms_i  mathcalC. Note that in practice this sum is truncated to the chosen k_textmax.","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"This operation can be efficiently computed using a type-2 NUFFT (from uniform wavenumbers bmk to non-uniform locations bmx), which can be understood as an interpolation of the coarse-grained velocity field on the chosen points.","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"From the above steps, we can directly write the large-scale velocity at bms_i from the geometry of vortex lines:","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"newcommandddmathrmd\nnewcommandsvecbms\nnewcommandsjsvec_i\nnewcommandkvecbmk\nbeginalign*\nbmv^(sj) =\n_kvec  bm0\nfracik^2  e^-k^2  4α^2 kvec  hatbmω(kvec)  e^i kvec  sj\n\n=\nfraciΓL^3 _kvec  bm0 frace^-k^2  4α^2k^2 _mathcalC e^i kvec  (sj - svec)  kvec  dd svec\n\n=\nfracΓL^3 _kvec  bm0 frace^-k^2  4α^2k^2 _mathcalC sinkvec  (svec - sj)  kvec  dd svec\nendalign*","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"which is analogous to the term for long-range electrostatic forces in e.g. Arnold and Holm (2005), Eq. (17).","category":"page"},{"location":"methods/Ewald/#Ewald-desingularisation","page":"Ewald summation for Biot–Savart","title":"Desingularisation","text":"","category":"section"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"As discussed in the VFM page, the Biot–Savart integral must be desingularised if the velocity is to be evaluated on a point bmx = bms_i belonging itself to the curve.","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"In this case, the actual velocity that we want to compute is","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"newcommandvvecbmv\nnewcommandsvecbms\nnewcommandsjsvec_i\nbeginalign*\nvvec(sj)\n= vvec_textlocal(sj) + vvec_textnon-local(sj)\n\n= vvec_textlocal(sj) +\nBig vvec^_textnon-local(sj) + vvec^_textnon-local(sj) Big\nendalign*","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"which basically means that both short-range and long-range components should skip the computation of their respective integrals in the vicinity of bms_i, and that the expression for the local velocity should be used instead.","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"note: Note\nThe terms local/non-local and short/long-range are completely orthogonal and should not be confused! The first pair of terms refer to the VFM while the second pair refers to Ewald summation. For example, as discussed right below, it is possible (and it makes sense) to compute the local long-range velocity component.","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"For the short-range component, it is straightforward to skip the local part of the modified Biot–Savart integral: one just integrates over segments within the cut-off distance, but excluding the two segments which are in direct contact with bms_i (the mathcalC_i region represented in the trefoil figure of the VFM page).","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"In the case of the long-range component special care is needed, as the procedure detailed above computes the full (coarse-grained) Biot–Savart integral, including the \"singular\" region. As discussed above, the modified long-range integral is actually not singular, so this is not a problem. But it means that we now need to subtract the local long-range velocity:","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"newcommandvvecbmv\nnewcommandsvecbms\nnewcommandddmathrmd\nnewcommandsjsvec_i\nvvec^_textlocal(sj)\n= fracΓ4π _mathcalC_i g^(svec - sj) frac(svec - sj)  dd svecsvec - sj^3","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"which can be numerically computed using the same method as for the non-local short-range velocity.","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"To summarise, in practice the velocity on a vortex position bms_i is computed as","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"newcommandvvecbmv\nnewcommandsvecbms\nnewcommandsjsvec_i\nvvec(sj)\n= vvec_textlocal(sj)\n+ vvec^_textnon-local(sj)\n- vvec^_textlocal(sj)\n+ vvec^(sj)","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"where the first term is computed using an analytical expression based on Taylor expansions, the second and third terms are estimated by numerical integration (using quadratures), and the fourth term is indirectly computed using (non-uniform) fast Fourier transforms.","category":"page"},{"location":"methods/Ewald/#Numerical-integration","page":"Ewald summation for Biot–Savart","title":"Numerical integration","text":"","category":"section"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"Both the short-range and long-range computations use quadrature rules to approximate line integrals using numerical integration. The general strategy that has been implemented is to perform integrals segment-by-segment, and to use a quadrature rule of few points for each segment.","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"To be more explicit, say that we have a single closed vortex line (for example the trefoil in the VFM page) and that we want to compute the short-range non-local velocity induced by the vortex on bms_i:","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"newcommandvvecbmv\nnewcommandsvecbms\nnewcommandsjsvec_i\nnewcommandsdiffsvec - sj\nnewcommandsdiffxsvec(ξ) - sj\nnewcommandddmathrmd\nnewcommandCcalmathcalC\nnewcommandCjCcal_i\nbeginalign*\nvvec^(sj)\n= fracΓ4π _Ccal  Cj g^(sdiff) frac(sdiff)  ddsvecsdiff^3\n\n= fracΓ4π\n  _j = 1^Nvphantom\n  _ξ_j^ξ_j + 1 g^(sdiffx) frac(sdiffx)  svec(ξ)sdiffx^3  dd ξ\n  quad j  i - 1 i\nendalign*","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"Here N is the number of discretisation points of the curve, and the prime over the summation symbol indicates that the indices j  i - 1 i (corresponding to the two segments in contact with bms_i) should be excluded. So the integral is split onto N - 2 line integrals. The next step is to approximate each of these integrals using a quadrature rule:","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"newcommandvvecbmv\nnewcommandsvecbms\nnewcommandsjsvec_i\nnewcommandsdiffsvec - sj\nnewcommandsdiffxsvec(ξ) - sj\nnewcommandsdiffmsvec(ξ_m) - sj\nnewcommandddmathrmd\nnewcommandCcalmathcalC\nnewcommandCjCcal_i\n\n_ξ_j^ξ_j + 1 f(ξ)  ddsvec(ξ)\n _m = 1^M w_m f(ξ_m)","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"where w_m and ξ_m  ξ_j ξ_j + 1 are appropriately-chosen quadrature weights and points, respectively. In practice, we use Gauss–Legendre quadratures with few (typically ~4) points per segment.","category":"page"},{"location":"methods/Ewald/#Ewald-parameters","page":"Ewald summation for Biot–Savart","title":"Parameter selection","text":"","category":"section"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"As detailed above, this method introduces a few parameters which must be tuned for accuracy and performance. In fact, most of these parameters are related and should not be treated independently. For instance, the physical- and Fourier-space cut-offs r_textcut and k_textmax are clearly related to the Ewald splitting parameter α. As described in Polanco (2024), these can be related by a unique non-dimensional parameter β = α r_textcut = k_textmax  2α controlling the accuracy of the method.","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"In practice, one recommended way of setting the parameters is as follows:","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"Start by setting the physical domain period L. It is convenient and standard practice to choose L = 2π, which means that the corresponding wavenumbers bmk in long-range computations will be integers (in general, k = 2πnL with n = 0  1  2 ldots). But in principle one can choose any positive value of L.\nSet the number of Fourier modes N in each direction. Choosing N also sets the maximum resolved wavenumber k_textmax = πNL as well as the physical grid spacing δ = LN associated to the long-range fields. The value of N should be tuned to have a good balance between the time spent on short-range and long-range computations.\nNow set the non-dimensional parameter β to the desired accuracy. For example, β = 35 roughly gives 10^-6 relative accuracy.\nFrom β and k_textmax, one obtains the remaining parameters α = k_textmax  2β and r_textcut = β  α.","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"For simplicity here we have assumed that the domain size L and the resolution N are the same in all directions, but things are easy to generalise to different L and N per direction. In all cases, one usually wants the physical grid spacing δ = LN (or equivalently the maximum resolved wavenumber k_textmax) to be the same in all directions.","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"note: Size of FFTs\nIt may also be a good idea to \"round\" the chosen value of N so that the FFTs performed in long-range computations have sizes described by powers of 2 or 3 (for which the FFT is most efficient). Note that, to reduce aliasing errors, the NUFFT oversamples the data from N to Ñ = σN  N, and this Ñ is the actual size of the performed FFTs. As an example, by default the NonuniformFFTsBackend in VortexPasta uses an oversampling of σ = 32. Therefore, choosing N = 85  23  128 leads to FFTs of size Ñ = 128 = 2^7, which is what we want.","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"Another parameter to choose is the size of the quadrature rules for numerical integration. Using Gauss–Legendre quadratures, integrals seem to converge quite fast using a small number of quadrature nodes per filament segment. Typically, using 3 nodes seems to be enough when using quintic splines to describe filaments.","category":"page"},{"location":"methods/Ewald/#Ewald-method-for-the-streamfunction","page":"Ewald summation for Biot–Savart","title":"Ewald method for the streamfunction","text":"","category":"section"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"As in the case of the velocity, the Biot–Savart integral for the streamfunction decays slowly with the distance r = bmx - bms, and its computation can be accelerated using Ewald summation. In fact, the Ewald summation method exposed above for the velocity is derived from that for the streamfunction, which is simpler and closer to the way the Ewald method is usually introduced in electrostatics (where the electrostatic potential is the analogue of the streamfunction).","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"In the case of the streamfunction, the idea of Ewald summation is to split the singular and slowly-decaying Green's function G(bmr) onto a smooth long-range component G^(bmr) and a short-range fast-decaying component G^(bmr). The standard way of doing this is via the identity:","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"G(bmr) = frac14πr\n= fracoperatornameerfc(αr)4πr + fracoperatornameerf(αr)4πr\n= G^(bmr) + G^(bmr)","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"where operatornameerf and operatornameerfc are respectively the error function and the complementary error function already introduced above, and α is the same Ewald splitting parameter introduced in that section.","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"This leads to modified Biot–Savart integrals for the short-range and long-range streamfunction. For example, the short-range integral is given by:","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"bmψ^(bmx) =\n(G^  bmω)(bmx) =\nfracΓ4π _mathcalC\nfracoperatornameerfc(α bmx - bms)bmx - bms  mathrmdbms","category":"page"},{"location":"methods/Ewald/","page":"Ewald summation for Biot–Savart","title":"Ewald summation for Biot–Savart","text":"Taking the curl of those integrals eventually leads to the g^(bmr) and g^(bmr) splitting functions that we used for the velocity.","category":"page"},{"location":"modules/Reconnections/#Reconnections","page":"Reconnections","title":"Reconnections","text":"","category":"section"},{"location":"modules/Reconnections/","page":"Reconnections","title":"Reconnections","text":"CurrentModule = VortexPasta.Reconnections\nCollapsedDocStrings = true","category":"page"},{"location":"modules/Reconnections/","page":"Reconnections","title":"Reconnections","text":"Reconnections","category":"page"},{"location":"modules/Reconnections/#VortexPasta.Reconnections","page":"Reconnections","title":"VortexPasta.Reconnections","text":"Reconnections\n\nModule for dealing with the reconnection of filaments.\n\n\n\n\n\n","category":"module"},{"location":"modules/Reconnections/","page":"Reconnections","title":"Reconnections","text":"Reconnections are generally performed by choosing a reconnection criterion and then calling reconnect!.","category":"page"},{"location":"modules/Reconnections/#Functions","page":"Reconnections","title":"Functions","text":"","category":"section"},{"location":"modules/Reconnections/","page":"Reconnections","title":"Reconnections","text":"init_cache\nreconnect!","category":"page"},{"location":"modules/Reconnections/#VortexPasta.Reconnections.init_cache","page":"Reconnections","title":"VortexPasta.Reconnections.init_cache","text":"Reconnections.init_cache(\n    crit::ReconnectionCriterion,\n    fs::AbstractVector{<:AbstractFilament},\n    Ls::NTuple{3, Real} = (Infinity(), Infinity(), Infinity()),\n) -> AbstractReconnectionCache\n\nInitialise reconnection cache.\n\nRequired arguments are a reconnection criterion crit and the domain dimensions (or periods) Ls.\n\nThe type of cache will vary depending on the inputs:\n\nif crit = NoReconnections(), then reconnections are disabled and this returns a NullReconnectionCache;\notherwise, it returns a ReconnectionCache.\n\nIn the second case, the detection of reconnection candidates can follow two different strategies:\n\nif the domain is infinite (default), a naive iteration across all filament segment pairs\n\nis performed;\n\nif the domain is periodic, an efficient cell lists algorithm is used (see the CellLists module).\n\n\n\n\n\n","category":"function"},{"location":"modules/Reconnections/#VortexPasta.Reconnections.reconnect!","page":"Reconnections","title":"VortexPasta.Reconnections.reconnect!","text":"reconnect!(\n    [callback::Function],\n    cache::AbstractReconnectionCache,\n    fs::AbstractVector{<:AbstractFilament},\n) -> NamedTuple\n\nPerform filament reconnections according to chosen criterion.\n\nNote that, when a filament self-reconnects, this creates new filaments, which are appended at the end of fs.\n\nMoreover, this function will remove reconnected filaments if their number of nodes is too small (typically  3, see check_nodes).\n\nReturns\n\nThis function returns a NamedTuple with fields:\n\nreconnection_count: number of reconnections;\nreconnection_length_loss: decrease of filament length due to reconnections. This is simply an estimate for the difference in filament length before and after a reconnection. It is unrelated to (and does not include) filament removal (see below). Uses the straight segment approximation;\nfilaments_removed_count: number of filaments removed after reconnection. This happens when a filament reconnects with itself, splitting into two new filaments, and one or both of these filaments have an insufficient number of discretisation nodes;\nfilaments_removed_length: length of removed filaments. We use a straight segment approximation (no quadratures) to estimate the filament lengths.\n\nCallback function\n\nOptionally, one may pass a callback which will be called whenever the vector of filaments fs is modified. Its signature must be the following:\n\ncallback(f::AbstractFilament, i::Int, mode::Symbol)\n\nwhere f is the modified filament, i is its index in fs, and mode is one of:\n\n:modified if the filament fs[i] was modified;\n:appended if the filament was appended at the end of fs (at index i);\n:removed if the filament previously located at index i was removed.\n\n\n\n\n\n","category":"function"},{"location":"modules/Reconnections/#Reconnection-criteria","page":"Reconnections","title":"Reconnection criteria","text":"","category":"section"},{"location":"modules/Reconnections/","page":"Reconnections","title":"Reconnections","text":"ReconnectionCriterion\nNoReconnections\nReconnectBasedOnDistance","category":"page"},{"location":"modules/Reconnections/#VortexPasta.Reconnections.ReconnectionCriterion","page":"Reconnections","title":"VortexPasta.Reconnections.ReconnectionCriterion","text":"ReconnectionCriterion\n\nAbstract type describing a criterion for filament reconnections.\n\nImplemented reconnection criteria include:\n\nNoReconnections: disables reconnections;\nReconnectBasedOnDistance: reconnects filament segments which are closer than a critical distance.\n\n\n\n\n\n","category":"type"},{"location":"modules/Reconnections/#VortexPasta.Reconnections.NoReconnections","page":"Reconnections","title":"VortexPasta.Reconnections.NoReconnections","text":"NoReconnections <: ReconnectionCriterion\n\nUsed to disable filament reconnections.\n\n\n\n\n\n","category":"type"},{"location":"modules/Reconnections/#VortexPasta.Reconnections.ReconnectBasedOnDistance","page":"Reconnections","title":"VortexPasta.Reconnections.ReconnectBasedOnDistance","text":"ReconnectBasedOnDistance <: ReconnectionCriterion\nReconnectBasedOnDistance(d_crit; decrease_length = true, cos_max = 0.97)\n\nReconnects filament segments which are at a distance d < d_crit.\n\nOptional keyword arguments\n\ndecrease_length: if true (default), a reconnection will only be performed if it will decrease the total filament length. Since, for vortices, the total energy is roughly related to the vortex length, this means that reconnections should always tend to dissipate energy.\ncos_max: allows to disable reconnections of nearly parallel segments. Two segments are considered to be \"nearly parallel\" if cos(θ) > cos_max. The default value cos_max = 0.97 disables reconnections when the angle between lines is θ  arccos(097)  14. Note that the angle θ is signed (it takes values in -1 1). Negative angles mean that the segments are antiparallel, and in this case reconnections are always performed.\n\n\n\n\n\n","category":"type"},{"location":"modules/Reconnections/#Internals","page":"Reconnections","title":"Internals","text":"","category":"section"},{"location":"modules/Reconnections/","page":"Reconnections","title":"Reconnections","text":"should_reconnect","category":"page"},{"location":"modules/Reconnections/#VortexPasta.Reconnections.should_reconnect","page":"Reconnections","title":"VortexPasta.Reconnections.should_reconnect","text":"should_reconnect(\n    c::ReconnectionCriterion,\n    fx::AbstractFilament, fy::AbstractFilament, i::Int, j::Int;\n    periods,\n) -> Union{Nothing, NamedTuple}\n\nCheck whether two filaments should reconnect according to the chosen criterion.\n\nChecks for a possible reconnection between filament segments fx[i:i+1] and fy[j:j+1].\n\nIf the filament segments should reconnect, this function returns a NamedTuple with reconnection information, which includes in particular all the fields returned by find_min_distance.\n\nOtherwise, returns nothing if the filament segments should not reconnect.\n\n\n\n\n\n","category":"function"},{"location":"#VortexPasta.jl","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"","category":"section"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"A vortex filament solver for the simulation of quantum vortex flows.","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"This solver implements the methods described in Polanco (2024) for the fast evaluation of Biot–Savart integrals in periodic domains.","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"Pages = [\"index.md\"]\nDepth = 2:3","category":"page"},{"location":"#Introduction","page":"VortexPasta.jl","title":"Introduction","text":"","category":"section"},{"location":"#Physical-context","page":"VortexPasta.jl","title":"Physical context","text":"","category":"section"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"Quantum vortices are one of the most important features of superfluids such as low-temperature liquid helium or Bose–Einstein condensates. These are topological defects – which in three dimensions take the form of spatial curves – where the velocity of the superfluid is singular. The main property of quantum vortices is that they have a quantised circulation. That is, they induce a rotating velocity field around them whose intensity is quantised in terms of the quantum of circulation κ = hm where h is Planck's constant and m is the mass of one boson (e.g. the mass of a ⁴He atom).","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"In the case of helium-4, superfluidity takes place at temperatures below about 2.17 K, and the thickness of quantum vortices is about 1 Å (10^-10 m). Their atomic-scale thickness justifies treating quantum vortices as infinitesimal lines when describing the macroscopic flow induced by them. This is precisely the idea of the vortex filament model (VFM) which is implemented in this package.","category":"page"},{"location":"#Numerical-considerations","page":"VortexPasta.jl","title":"Numerical considerations","text":"","category":"section"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"From a numerical standpoint, simulating large sets of quantum vortices using the VFM is expensive. Indeed, assuming that vortex lines are discretised by a set of N points in space, the VFM requires computing the velocity of each vortex point bms_i (for i  1 N) induced by the locations of all vortex points. Note that the influence of a vortex on the surrounding space decays relatively slowly with the distance r (the induced velocity typically decays as 1r), and thus one needs to account for all pair interactions – even over long distances. A naive implementation, where all such pair interactions are computed one by one, leads to a computational complexity of mathcalO(N^2), that is, the computational cost increases quickly with the number of discretisation points (or vortices). For this reason, simulating fully turbulent flows is prohibitively costly with naive methods.","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"The VortexPasta.jl solver provides an efficient and accurate implementation of the VFM (Polanco, 2024), specifically intended for vortex flows in periodic domains. Its efficiency comes from the use of a splitting technique derived from the Ewald summation method, which splits the Biot–Savart integral into a short-range and a long-range parts. This kind of methods is routinely used in the context of molecular dynamics simulations to compute electrostatic Coulomb interactions between point charges. In the modified short-range integral, pair interactions decay exponentially with r, which means that one can effectively ignore interactions beyond some cut-off distance r_textcut. Meanwhile, the long-range integral is smooth (non-singular) at r = 0, and thus can be indirectly computed using fast Fourier transforms (FFTs), leading to a complexity of mathcalO(N log N). Conveniently, the long-range velocity field is nothing but the velocity induced by a coarse-grained vorticity field, which enables a simple interpretation of the long-range component, as well as the use of tools and quantities commonly used for classical flows (such as energy spectra, …).","category":"page"},{"location":"#Installation","page":"VortexPasta.jl","title":"Installation","text":"","category":"section"},{"location":"#Installing-Julia","page":"VortexPasta.jl","title":"Installing Julia","text":"","category":"section"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"The easiest way of installing (and updating) Julia is using the official juliaup installer.","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"On Linux and Mac, one can install juliaup by executing in a terminal","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"curl -fsSL https://install.julialang.org | sh","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"This will automatically install the latest Julia release and make it available from your terminal using the julia command.","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"To get started with using Julia, the Modern Julia Workflows blog is a great source of practical information. See in particular the section on writing Julia code.","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"In particular, it is highly recommended to install the Revise.jl package in the default environment. This package keeps track of modifications of included code when working from a Julia session, which means that one doesn't need to re-include a Julia file each time it is modified. To install it, launch Julia in a terminal, enter package mode using ], and then:","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"(@v1.10) pkg> add Revise","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"Another very widely used package is OhMyREPL.jl, which adds syntax highlighting to the REPL among other nice things. It can be installed in the same way as Revise.jl.","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"One usually wants to load these packages every time a Julia session is started. This can be done automatically by creating a startup file in ~/.julia/config/startup.jl with the following content:","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"try\n    using Revise\n    using OhMyREPL\ncatch e\n    @warn \"Error importing Revise or OhMyREPL. Use `]add Revise OhMyREPL` to install them.\"\nend","category":"page"},{"location":"#Local-environments","page":"VortexPasta.jl","title":"Local environments","text":"","category":"section"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"Above, both packages have been installed in the default environment (@v1.X), which is convenient because we want to load these packages no matter which Julia project we're currently working on.","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"For more specific things (such as doing simulations using VortexPasta.jl), it is recommended to install things in a local environment, which allows (among other things) to avoid conflicts between package versions when working on different Julia projects.","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"To create a new local environment in the current folder, launch Julia using:[1]","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"julia --project=.","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"Packages will then be installed in this environment. For example, enter package mode using ] and install the GLMakie.jl package:","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"(simulation) pkg> add GLMakie","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"This will install the GLMakie package (for plotting) and all its dependencies. It will also precompile installed packages, which can take a few minutes (especially for GLMakie, which is a large package with many dependencies), but which makes loading the package faster when it is actually imported from a Julia session or script.","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"One can check that the project now contains a single package:","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"(simulation) pkg> status\nStatus `/path/to/simulation/Project.toml`\n  [e9467ef8] GLMakie v0.8.9","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"Moreover, the current directory now contains two new files, Project.toml and Manifest.toml, which describe the packages installed by local environment. The Project.toml file lists the packages that we have directly installed (so just GLMakie for now). The Manifest.toml file is much larger, as it also contains the list of all installed packages associated to the environment, including the direct and indirect dependencies of GLMakie, and the precise versions of the installed packages. This file is automatically generated and is very useful for reproducibility.","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"Once the new project has been created, one can simply start Julia using","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"julia --project","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"from the same directory (simulation in this example). (Note that, this time, we haven't told Julia where the project is located.) Julia will automatically detect the presence of the Project.toml file in the current directory and enable the local environment.","category":"page"},{"location":"#Installing-VortexPasta.jl","page":"VortexPasta.jl","title":"Installing VortexPasta.jl","text":"","category":"section"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"It is recommended to install VortexPasta.jl in a local environment, for example in the same environment as in the previous example (which already includes GLMakie).","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"To install it, one should first add the VortexRegistry package registry, which contains information on how to install VortexPasta.jl:","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"(simulation) pkg> registry add https://github.com/jipolanco/VortexRegistry.jl.git","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"warning: Warning\nIf this command asks for an SSH key location and then fails with a GitError, you may need to set the JULIA_PKG_USE_CLI_GIT environment variable to true. For instance, add the lineENV[\"JULIA_PKG_USE_CLI_GIT\"] = \"true\"to your ~/.julia/config/startup.jl file[2] and then restart Julia.","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"Now we can easily install VortexPasta.jl:","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"(simulation) pkg> add VortexPasta","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"As before, this will install all dependencies and precompile VortexPasta.jl and other installed packages. Now the status of the local environment should look something like:","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"(simulation) pkg> status\nStatus `~/Work/Projects/Vortices/Codes/VortexPasta/docs/simulation/Project.toml`\n  [e9467ef8] GLMakie v0.8.9\n  [3d0f1e53] VortexPasta v0.2.1","category":"page"},{"location":"#Installing-VortexPasta.jl-in-development-mode","page":"VortexPasta.jl","title":"Installing VortexPasta.jl in development mode","text":"","category":"section"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"The above procedure installs VortexPasta.jl in a read-only directory somewhere in ~/.julia. If, instead, we would like to make modifications to VortexPasta.jl, we should install it in \"development\" mode using dev (or develop) instead of add:","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"(simulation) pkg> dev VortexPasta","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"This will install the development version of VortexPasta.jl to ~/.julia/dev/VortexPasta. Any modifications to the code there will be visible when running scripts or code in the local environment.","category":"page"},{"location":"#Running-the-code","page":"VortexPasta.jl","title":"Running the code","text":"","category":"section"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"See the vortex ring tutorial for an example on how to prepare and run vortex filament simulations, from initialising a vortex filament with the wanted geometry, to computing its self-induced velocity, running simulations and saving the results for further analysis.","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"[1]: Alternatively, one can start Julia without the --project flag, and then ] activate . in package mode, as described in the official docs.","category":"page"},{"location":"","page":"VortexPasta.jl","title":"VortexPasta.jl","text":"[2]: Replace ~/.julia with $JULIA_DEPOT_PATH in case you have defined this environment variable.","category":"page"}]
}
