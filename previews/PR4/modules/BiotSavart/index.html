<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>BiotSavart · VortexPasta</title><meta name="title" content="BiotSavart · VortexPasta"/><meta property="og:title" content="BiotSavart · VortexPasta"/><meta property="twitter:title" content="BiotSavart · VortexPasta"/><meta name="description" content="Documentation for VortexPasta."/><meta property="og:description" content="Documentation for VortexPasta."/><meta property="twitter:description" content="Documentation for VortexPasta."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/fonts.css" rel="stylesheet" type="text/css"/><script src="../../assets/tomate.js"></script><script src="../../assets/sa.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">VortexPasta</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">VortexPasta.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/01-vortex_ring/">Vortex ring</a></li><li><a class="tocitem" href="../../tutorials/02-kelvin_waves/">Kelvin waves</a></li></ul></li><li><span class="tocitem">Explanations</span><ul><li><a class="tocitem" href="../../methods/VFM/">The vortex filament model</a></li><li><a class="tocitem" href="../../methods/Ewald/">Ewald summation for Biot–Savart</a></li></ul></li><li><span class="tocitem">Tips and tricks</span><ul><li><a class="tocitem" href="../../tips/parallelisation/">Parallelisation</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../PaddedArrays/">PaddedArrays</a></li><li><a class="tocitem" href="../PredefinedCurves/">PredefinedCurves</a></li><li><a class="tocitem" href="../CellLists/">CellLists</a></li><li><a class="tocitem" href="../BasicTypes/">BasicTypes</a></li><li><a class="tocitem" href="../Quadratures/">Quadratures</a></li><li><a class="tocitem" href="../Filaments/">Filaments</a></li><li><a class="tocitem" href="../FilamentIO/">FilamentIO</a></li><li><a class="tocitem" href="../FindNearbySegments/">FindNearbySegments</a></li><li class="is-active"><a class="tocitem" href>BiotSavart</a><ul class="internal"><li><a class="tocitem" href="#Biot–Savart-parameters"><span>Biot–Savart parameters</span></a></li><li><a class="tocitem" href="#Exported-functions"><span>Exported functions</span></a></li><li><a class="tocitem" href="#Other-convenience-functions"><span>Other convenience functions</span></a></li><li><a class="tocitem" href="#Short-range-interactions"><span>Short-range interactions</span></a></li><li><a class="tocitem" href="#Long-range-interactions"><span>Long-range interactions</span></a></li><li><a class="tocitem" href="#Internals-3"><span>Internals</span></a></li></ul></li><li><a class="tocitem" href="../Reconnections/">Reconnections</a></li><li><a class="tocitem" href="../Timestepping/">Timestepping</a></li><li><a class="tocitem" href="../Diagnostics/">Diagnostics</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>BiotSavart</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>BiotSavart</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jipolanco/VortexPasta.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jipolanco/VortexPasta.jl/blob/master/docs/src/modules/BiotSavart.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="BiotSavart"><a class="docs-heading-anchor" href="#BiotSavart">BiotSavart</a><a id="BiotSavart-1"></a><a class="docs-heading-anchor-permalink" href="#BiotSavart" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart" href="#VortexPasta.BiotSavart"><code>VortexPasta.BiotSavart</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">BiotSavart</code></pre><p>Module for estimation of Biot–Savart integrals along vortex filaments using fast Ewald splitting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/BiotSavart.jl#L1-L6">source</a></section></article><h2 id="Biot–Savart-parameters"><a class="docs-heading-anchor" href="#Biot–Savart-parameters">Biot–Savart parameters</a><a id="Biot–Savart-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Biot–Savart-parameters" title="Permalink"></a></h2><h3 id="Setting-the-parameters"><a class="docs-heading-anchor" href="#Setting-the-parameters">Setting the parameters</a><a id="Setting-the-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-the-parameters" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.ParamsBiotSavart" href="#VortexPasta.BiotSavart.ParamsBiotSavart"><code>VortexPasta.BiotSavart.ParamsBiotSavart</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParamsBiotSavart{T &lt;: AbstractFloat}</code></pre><p>Contains parameters for calculation of Biot–Savart integrals using fast Ewald splitting.</p><p>The type parameter <code>T</code> corresponds to the precision used in computations (typically <code>Float64</code> or <code>Float32</code>).</p><p><strong>Construction</strong></p><pre><code class="nohighlight hljs">ParamsBiotSavart([T = Float64]; Γ, a, α, Ls, Ns, optional_kws...)</code></pre><p>where the optional parameter <code>T</code> sets the numerical precision.</p><p>Mandatory and optional keyword arguments are detailed in the extended help below.</p><p><strong>Extended help</strong></p><p><strong>Mandatory keyword arguments</strong></p><ul><li><p><code>Γ::Real</code>: vortex circulation (assumed constant);</p></li><li><p><code>a::Real</code>: vortex core size (assumed constant);</p></li><li><p><code>α::Real</code>: Ewald splitting parameter (inverse length scale). One can set <code>α = Zero()</code> to efficiently disable long-range computations.</p></li><li><p><code>Ls::Union{Real, NTuple{3, Real}}</code>: size of unit cell (i.e. period in each direction). If a single value is passed (e.g. <code>Ls = 2π</code>), it is assumed that periods are the same in each direction.</p><p>One can set <code>Ls = Infinity()</code> to disable periodicity. This should be done in combination with <code>α = Zero()</code>.</p></li><li><p><code>Ns::Dims{3}</code>: dimensions of physical grid used for long-range interactions. This parameter is not required if <code>α = Zero()</code>.</p></li></ul><p><strong>Optional keyword arguments (and their defaults)</strong></p><p><strong>General</strong></p><ul><li><code>quadrature::StaticSizeQuadrature = GaussLegendre(3)</code>: quadrature rule for short- and long-range interactions. For example, if <code>quadrature = GaussLegendre(4)</code>, then 4 evaluations of the Biot–Savart integrand will be done for each filament segment.</li></ul><p><strong>Short-range interactions</strong></p><ul><li><p><code>backend_short::ShortRangeBackend</code>: backend used to compute short-range interactions. The default is <code>CellListsBackend(2)</code>, unless periodicity is disabled, in which case <code>NaiveShortRangeBackend()</code> is used. See <a href="#VortexPasta.BiotSavart.ShortRangeBackend"><code>ShortRangeBackend</code></a> for a list of possible backends;</p></li><li><p><code>rcut = 4√2 / α</code>: cutoff distance for computation of short-range interactions. For performance and practical reasons, the cutoff distance must be less than half the cell unit size in each direction, i.e. <code>rcut &lt; minimum(Ls) / 2</code>.</p></li></ul><p><strong>Long-range interactions</strong></p><ul><li><p><code>backend_long::LongRangeBackend = NonuniformFFTsBackend()</code>: backend used to compute long-range interactions. See <a href="#VortexPasta.BiotSavart.LongRangeBackend"><code>LongRangeBackend</code></a> for a list of possible backends;</p></li><li><p><code>longrange_truncate_spherical = false</code>: if <code>true</code>, perform a spherical truncation in Fourier space, discarding all wavenumbers such that <span>$|\bm{k}| &gt; k_{\text{max}}$</span>. This is not recommended as it leads to precision loss, and should be used for testing only (in particular, for verifying error estimates which assume this kind of truncation).</p></li></ul><p><strong>Local self-induced velocity</strong></p><ul><li><p><code>Δ = 0.25</code>: coefficient appearing in the local self-induced velocity (LIA term), which depends on the vorticity profile at the vortex core.</p><p>Some common values of <code>Δ</code> are:</p><ul><li><p><code>Δ = 0.25</code> for a constant vorticity profile (default);</p></li><li><p><code>Δ = 0.5</code> for a hollow vortex;</p></li><li><p><code>Δ ≈ 0.905 ≈ 0.558 + ln(2) / 2</code> for a Gaussian vorticity profile (taking <code>a</code> as the Gaussian standard deviation <code>σ</code>);</p></li><li><p><code>Δ ≈ 0.615</code> for a Gross–Pitaevskii vortex with healing length <code>a</code>.</p></li></ul><p>See Saffman (1992), sections 10.2–10.3 for the first three.</p></li><li><p><code>lia_segment_fraction = nothing</code>: can be used to indicate that the LIA term should be evaluated over a <em>fraction</em> of the two segments surrounding a node. In this case, it should be a real value in <span>$(0, 1]$</span>. The default (<code>nothing</code>) is equivalent to 1, and means that the LIA term is evaluated over the full segments. If smaller than 1, the velocity induced by the excluded part of the segments will be evaluated using the regular Biot–Savart law (using quadratures within each subsegment). This may improve accuracy, especially when the discretisation distance is relatively large. Since this means integrating near the singularity of the BS integral, this integral is by default estimated using adaptive quadratures (see <code>quadrature_near_singularity</code> below).</p></li><li><p><code>quadrature_near_singularity = AdaptiveTanhSinh(T; nlevels = 5)</code>: quadrature rule to be used when integrating near a singularity, in particular when <code>lia_segment_fraction</code> is enabled. By default an adaptive quadrature rule <a href="../Quadratures/#VortexPasta.Quadratures.AdaptiveTanhSinh"><code>AdaptiveTanhSinh</code></a> is used, which is generally accurate but can be costly. One can also pass a <a href="../Quadratures/#VortexPasta.Quadratures.StaticSizeQuadrature"><code>StaticSizeQuadrature</code></a> such as <a href="../Quadratures/#VortexPasta.Quadratures.GaussLegendre"><code>GaussLegendre</code></a>, but in that case accuracy is not guaranteed.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/params.jl#L155-L255">source</a></section></article><h3 id="Accessing-parameters"><a class="docs-heading-anchor" href="#Accessing-parameters">Accessing parameters</a><a id="Accessing-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-parameters" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.circulation" href="#VortexPasta.BiotSavart.circulation"><code>VortexPasta.BiotSavart.circulation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BiotSavart.circulation(p::ParamsBiotSavart) -&gt; Γ</code></pre><p>Return the circulation <code>Γ</code> associated to each vortex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/params.jl#L329-L333">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.periods" href="#VortexPasta.BiotSavart.periods"><code>VortexPasta.BiotSavart.periods</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BiotSavart.periods(p::ParamsBiotSavart) -&gt; (Lx, Ly, Lz)</code></pre><p>Return the domain periods in each direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/params.jl#L336-L340">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.domain_is_periodic" href="#VortexPasta.BiotSavart.domain_is_periodic"><code>VortexPasta.BiotSavart.domain_is_periodic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BiotSavart.domain_is_periodic(p::ParamsBiotSavart) -&gt; Bool
BiotSavart.domain_is_periodic(Ls::NTuple) -&gt; Bool</code></pre><p>Check whether the domain is periodic.</p><p>Returns <code>true</code> if the domain is periodic in <em>all</em> directions, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/params.jl#L343-L350">source</a></section></article><h2 id="Exported-functions"><a class="docs-heading-anchor" href="#Exported-functions">Exported functions</a><a id="Exported-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.init_cache" href="#VortexPasta.BiotSavart.init_cache"><code>VortexPasta.BiotSavart.init_cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">init_cache(
    p::ParamsBiotSavart, fs::AbstractVector{&lt;:AbstractFilament};
    timer = TimerOutput(&quot;BiotSavart&quot;),
) -&gt; BiotSavartCache</code></pre><p>Initialise caches for computing Biot–Savart integrals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/cache.jl#L35-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.velocity_on_nodes!" href="#VortexPasta.BiotSavart.velocity_on_nodes!"><code>VortexPasta.BiotSavart.velocity_on_nodes!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">velocity_on_nodes!(
    vs::AbstractVector{&lt;:AbstractVector{&lt;:Vec3}},
    cache::BiotSavartCache,
    fs::AbstractVector{&lt;:AbstractFilament},
) -&gt; vs</code></pre><p>Compute velocity induced by vortex filaments on filament nodes.</p><p>Velocities induced by vortex filaments <code>fs</code> are written to <code>vs</code>.</p><p>This is the same as calling <a href="#VortexPasta.BiotSavart.compute_on_nodes!"><code>compute_on_nodes!</code></a> when only the velocity is needed.</p><p>Usually, <code>fs</code> is a vector containing all the vortex filaments in the system. In that case, <code>vs</code> must be a vector of vectors, which will contain the velocities of all filament nodes. The length of <code>vs[i]</code> must be equal to the number of nodes in the filament <code>fs[i]</code>.</p><p>The vector of velocities where the output will be written may be initialised using one of the following lines (all are exactly equivalent):</p><pre><code class="language-julia hljs">vs = map(similar ∘ nodes, fs)
vs = [similar(nodes(f)) for f ∈ fs]
vs = similar.(nodes.(fs))</code></pre><p>which initialise a velocity vector for each node of each filament (see also <a href="../Filaments/#VortexPasta.Filaments.nodes"><code>nodes</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/BiotSavart.jl#L55-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.compute_on_nodes!" href="#VortexPasta.BiotSavart.compute_on_nodes!"><code>VortexPasta.BiotSavart.compute_on_nodes!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_on_nodes!(
    fields::NamedTuple{Names, NTuple{N, V}},
    cache::BiotSavartCache,
    fs::AbstractVector{&lt;:AbstractFilament};
    LIA = Val(true),
    shortrange = true,
    longrange = true,
    callback_vorticity = identity,
) where {Names, N, V &lt;: AbstractVector{&lt;:VectorOfVec}}</code></pre><p>Compute velocity and/or streamfunction on filament nodes.</p><p>The first argument contains one or more output fields to compute. It is usually of length 1 or 2, and can contain fields named <code>velocity</code> and <code>streamfunction</code>.</p><p>For example, to compute both velocity and streamfunction on the nodes of filaments <code>fs</code>:</p><pre><code class="language-julia hljs"># Initialise fields to compute (vectors of vectors)
vs = map(similar ∘ nodes, fs)  # one velocity vector per filament node
ψs = map(similar, vs)

# The first argument to `compute_on_nodes!` must have the following form.
# One can also choose to pass just one of the two fields.
fields = (;
    velocity = vs,
    streamfunction = ψs,
)

cache = BiotSavart.init_cache(...)
compute_on_nodes!(fields, cache, fs)</code></pre><p><strong>Extended help</strong></p><p><strong>Disabling local terms / computing <em>only</em> local terms</strong></p><p>One may disable computation of the locally-induced velocity and streamfunction (LIA term) by passing <code>LIA = Val(false)</code>. Conversely, one can pass <code>LIA = Val(:only)</code> to compute <em>only</em> the LIA term. This can be useful for splitting the induced filament velocities/streamfunctions onto local and non-local parts.</p><p><strong>Disabling short-range or long-range interactions</strong></p><p>It is also possible to disable the short-range or long-range component of Ewald splitting, if one only wants to compute one of the two components. To do this, pass either <code>shortrange = false</code> or <code>longrange = false</code>.</p><p>Note that the short-range component includes the local (LIA) term as well as the short-range correction term for long-range interactions. Therefore, setting <code>shortrange = false</code> disables both these terms.</p><p><strong>Accessing vorticity in Fourier space</strong></p><p>The computation of long-range quantities involves estimating the Fourier coefficients of the vorticity field associated to the vortex filaments. These coefficients are truncated to some maximum wavenumber <span>$k_{\text{max}}$</span> in each Cartesian direction. This information can be useful for other things, for instance computing energy spectra.</p><p>One can use the <code>callback_vorticity</code> argument to access the vorticity in Fourier space, before it is replaced by the coefficients of streamfunction and/or velocity. This argument should be a function <code>callback_vorticity(cache)</code> which takes a <a href="#VortexPasta.BiotSavart.LongRangeCache"><code>LongRangeCache</code></a>. The callback should not modify anything inside the cache, or otherwise the streamfunction and velocity computed by this function will likely be wrong. Of course, this callback will be ignored if long-range computations are disabled.</p><p>Note that, when the callback is called, the vorticity coefficients in <code>cache.common.uhat</code> don&#39;t have the right physical dimensions as they have not yet been multiplied by <span>$Γ/V$</span> (where <span>$V$</span> is the volume of a unit cell). Note that <span>$Γ/V$</span> is directly available in <code>cache.common.ewald_prefactor</code>. Besides, the vorticity coefficients at this stage have not yet been Gaussian-filtered according to Ewald&#39;s method.</p><p>An example of how to compute the (large-scale) kinetic energy associated to the Fourier-truncated vorticity field:</p><pre><code class="language-julia hljs">E_from_vorticity = Ref(0.0)  # &quot;global&quot; variable updated when calling compute_on_nodes!

function callback_vorticity(cache::LongRangeCache)
    (; wavenumbers, uhat, ewald_prefactor,) = cache.common
    with_hermitian_symmetry = wavenumbers[1][end] &gt; 0  # this depends on the long-range backend
    γ² = ewald_prefactor^2  # = (Γ/V)^2 [prefactor not included in the vorticity]
    E = 0.0
    for I ∈ CartesianIndices(uhat)
        k⃗ = map(getindex, wavenumbers, Tuple(I))
        kx = k⃗[1]
        factor = (!with_hermitian_symmetry || kx == 0) ? 0.5 : 1.0
        k² = sum(abs2, k⃗)
        if !iszero(k²)
            ω⃗ = uhat[I]  # Fourier coefficient of the vorticity
            E += γ² * factor * sum(abs2, ω⃗) / k²
        end
    end
    E_from_vorticity[] = E  # update value of &quot;global&quot; variable
    nothing
end

compute_on_nodes!(...; callback_vorticity)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/BiotSavart.jl#L224-L325">source</a></section></article><h2 id="Other-convenience-functions"><a class="docs-heading-anchor" href="#Other-convenience-functions">Other convenience functions</a><a id="Other-convenience-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-convenience-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.kelvin_wave_period" href="#VortexPasta.BiotSavart.kelvin_wave_period"><code>VortexPasta.BiotSavart.kelvin_wave_period</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BiotSavart.kelvin_wave_period(p::ParamsBiotSavart, λ::Real) -&gt; Real</code></pre><p>Return the period <span>$T(λ)$</span> associated to Kelvin waves of wavelength <span>$λ$</span>.</p><p>This can be convenient for setting the timestep <code>dt</code> associated to a filament discretisation distance <code>δ</code>. The timestep should typically be proportional to the period of the Kelvin waves of wavelength <code>δ</code>.</p><p>The Kelvin wave period is <span>$T(λ) = 2π/ω(k)$</span> where <span>$k = 2π/λ$</span> is the wavenumber associated to <span>$λ$</span> and <span>$ω(k)$</span> is the Kelvin wave dispersion relation:</p><p class="math-container">\[ω(k) = \frac{Γ k^2}{4π} \left[
  \ln\left( \frac{2}{k a} \right) - γ + \frac{1}{2} - Δ
\right]\]</p><p>where <span>$γ ≈ 0.5772$</span> is the Euler–Mascheroni constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/params.jl#L393-L412">source</a></section></article><h2 id="Short-range-interactions"><a class="docs-heading-anchor" href="#Short-range-interactions">Short-range interactions</a><a id="Short-range-interactions-1"></a><a class="docs-heading-anchor-permalink" href="#Short-range-interactions" title="Permalink"></a></h2><h3 id="Backends"><a class="docs-heading-anchor" href="#Backends">Backends</a><a id="Backends-1"></a><a class="docs-heading-anchor-permalink" href="#Backends" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.ShortRangeBackend" href="#VortexPasta.BiotSavart.ShortRangeBackend"><code>VortexPasta.BiotSavart.ShortRangeBackend</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShortRangeBackend</code></pre><p>Abstract type denoting the backend used for computing short-range interactions.</p><p><strong>Implemented backends</strong></p><ul><li><p><a href="#VortexPasta.BiotSavart.CellListsBackend"><code>CellListsBackend</code></a>: most efficient when the cutoff radius is much smaller than the domain size. Can only be used with periodic boundary conditions.</p></li><li><p><a href="#VortexPasta.BiotSavart.NaiveShortRangeBackend"><code>NaiveShortRangeBackend</code></a>: usually less efficient as it needs to compute distances between all pairs of locations.</p></li></ul><p><strong>Extended help</strong></p><p><strong>Implementation details</strong></p><p>A <code>BACKEND &lt;: ShortRangeBackend</code> must implement the function:</p><pre><code class="nohighlight hljs">init_cache_short(c::ParamsCommon, p::ParamsShortRange{&lt;:BACKEND}, fs::AbstractVector{&lt;:AbstractFilament}, to::TimerOutput)</code></pre><p>which should return a <a href="#VortexPasta.BiotSavart.ShortRangeCache"><code>ShortRangeCache</code></a>.</p><p>It may also implement the function <a href="#VortexPasta.BiotSavart.max_cutoff_distance"><code>max_cutoff_distance</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/types_shortrange.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.NaiveShortRangeBackend" href="#VortexPasta.BiotSavart.NaiveShortRangeBackend"><code>VortexPasta.BiotSavart.NaiveShortRangeBackend</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NaiveShortRangeBackend &lt;: ShortRangeBackend</code></pre><p>Naive computation of short-range interactions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/shortrange/naive.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.CellListsBackend" href="#VortexPasta.BiotSavart.CellListsBackend"><code>VortexPasta.BiotSavart.CellListsBackend</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CellListsBackend &lt;: ShortRangeBackend
CellListsBackend(nsubdiv::Int = 1)</code></pre><p>Compute short-range interactions using the cell lists algorithm.</p><p>This backend can be significantly faster than the <a href="#VortexPasta.BiotSavart.NaiveShortRangeBackend"><code>NaiveShortRangeBackend</code></a> when the cutoff distance <code>r_cut</code> is much smaller than the domain period <code>L</code> (roughly when <code>r_cut ≲ L / 10</code>).</p><p>Optionally, one can choose to subdivide each cell (of size <code>≈ r_cut</code>) onto <code>nsubdiv</code> subcells. In practice, a value of <code>2</code> or <code>3</code> can significantly improve performance compared to no subdivision (<code>1</code>).</p><p>Note that, with this backend, the cutoff distance must satisfy <code>r_cut ≤ M / (2M + 1) * L</code> where <code>M = nsubdiv</code>.</p><p>This backend does not support non-periodic domains.</p><p>See <a href="../CellLists/#VortexPasta.CellLists.PeriodicCellList"><code>PeriodicCellList</code></a> and <a href="https://en.wikipedia.org/wiki/Cell_lists">Wikipedia</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/shortrange/cell_lists.jl#L5-L25">source</a></section></article><h3 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.ShortRangeCache" href="#VortexPasta.BiotSavart.ShortRangeCache"><code>VortexPasta.BiotSavart.ShortRangeCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShortRangeCache</code></pre><p>Abstract type describing the storage of data required to compute short-range interactions.</p><p>The <a href="#VortexPasta.BiotSavart.init_cache_short"><code>init_cache_short</code></a> function returns a concrete instance of a <code>ShortRangeCache</code>.</p><p><strong>Interface</strong></p><p><strong>Fields</strong></p><p>The following fields must be included in a cache:</p><ul><li><p><code>params :: ParamsShortRange</code> parameters for short-range computations;</p></li><li><p><code>to :: TimerOutput</code> for measuring time spent on different functions.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/types_shortrange.jl#L48-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.max_cutoff_distance" href="#VortexPasta.BiotSavart.max_cutoff_distance"><code>VortexPasta.BiotSavart.max_cutoff_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">max_cutoff_distance(::ShortRangeBackend, L::Real) -&gt; r
max_cutoff_distance(::ShortRangeBackend, Ls::NTuple{3, Real}) -&gt; r</code></pre><p>Return the maximum cut-off distance <code>r_cut</code> allowed by the backend for a given domain period <code>L</code>.</p><p>This is usually close to <code>L/2</code>, but the actual value can depend on implementation details of the backend. For example, the <a href="#VortexPasta.BiotSavart.CellListsBackend"><code>CellListsBackend</code></a> requires a slightly smaller distance, in the range <code>L/3 ≤ r_max &lt; L/2</code> depending on the backend parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/types_shortrange.jl#L28-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.init_cache_short" href="#VortexPasta.BiotSavart.init_cache_short"><code>VortexPasta.BiotSavart.init_cache_short</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">init_cache_short(
    pc::ParamsCommon, p::ParamsShortRange,
    fs::AbstractVector{&lt;:AbstractFilament},
    to::TimerOutput,
) -&gt; ShortRangeCache</code></pre><p>Initialise the cache for the short-range backend defined in <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/shortrange/shortrange.jl#L9-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.process_point_charges!" href="#VortexPasta.BiotSavart.process_point_charges!"><code>VortexPasta.BiotSavart.process_point_charges!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">process_point_charges!(c::ShortRangeCache, data::PointData)</code></pre><p>Process list of point charges.</p><p>This is useful for short-range backends like <a href="#VortexPasta.BiotSavart.CellListsBackend"><code>CellListsBackend</code></a>, which needs to</p><p>Must be called after <a href="#VortexPasta.BiotSavart.add_point_charges!"><code>add_point_charges!</code></a> and before computing any short-range quantities (using <a href="#VortexPasta.BiotSavart.add_short_range_fields!"><code>add_short_range_fields!</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/shortrange/shortrange.jl#L20-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.add_short_range_fields!" href="#VortexPasta.BiotSavart.add_short_range_fields!"><code>VortexPasta.BiotSavart.add_short_range_fields!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_short_range_fields!(
    fields::NamedTuple{Names, NTuple{N, V}},
    cache::ShortRangeCache,
    f::AbstractFilament;
    LIA = Val(true),
)</code></pre><p>Compute short-range Biot-Savart integrals.</p><p>Adds the results onto <code>fields</code>. See <a href="#VortexPasta.BiotSavart.compute_on_nodes!"><code>compute_on_nodes!</code></a> for more details.</p><p>Setting <code>LIA = Val(false)</code> allows to disable computation of the localised induction approximation (LIA) term. In that case, that term should be computed separately using <a href="#VortexPasta.BiotSavart.local_self_induced"><code>local_self_induced</code></a>.</p><p>Before calling this function, one must first call <a href="#VortexPasta.BiotSavart.add_point_charges!"><code>add_point_charges!</code></a> and then <a href="#VortexPasta.BiotSavart.process_point_charges!"><code>process_point_charges!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/shortrange/shortrange.jl#L203-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.local_self_induced_velocity" href="#VortexPasta.BiotSavart.local_self_induced_velocity"><code>VortexPasta.BiotSavart.local_self_induced_velocity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">local_self_induced_velocity(
    f::AbstractFilament, i::Int, [prefactor::Real];
    a::Real, [Γ::Real],
    Δ = 0.25, quad = nothing, fit_circle = false,
    segment_fraction = nothing,
)</code></pre><p>Compute local self-induced velocity of filament node <code>f[i]</code>.</p><p>This corresponds to the LIA term (localised induction approximation).</p><p>This is the same as <code>local_self_induced(Velocity(), f, i, [prefactor]; kwargs...)</code>. See also <a href="#VortexPasta.BiotSavart.local_self_induced"><code>local_self_induced</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/shortrange/lia.jl#L5-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.local_self_induced" href="#VortexPasta.BiotSavart.local_self_induced"><code>VortexPasta.BiotSavart.local_self_induced</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">local_self_induced(
    q::OutputField, f::AbstractFilament, i::Int, [prefactor::Real];
    a::Real, Δ::Real = 0.25, segment_fraction = nothing, quad = nothing, [Γ],
)</code></pre><p>Compute localised induction approximation (LIA) term at node <code>f[i]</code>.</p><p>Possible output fields to be passed as first argument are <code>Velocity()</code> and <code>Streamfunction()</code>.</p><p>One must pass either the circulation <code>Γ</code> as a keyword argument, or a precomputed <code>prefactor</code> which is usually equal to <code>Γ / 4π</code> (both for velocity and streamfunction).</p><p><strong>Mandatory arguments</strong></p><ul><li><p>the vortex core size <code>a</code> as a keyword argument;</p></li><li><p>either the vortex circulation <code>Γ</code> as a keyword argument, or the precomputed prefactor <code>Γ / 4π</code> as a positional argument.</p></li></ul><p><strong>Optional arguments</strong></p><ul><li><p>the optional parameter <code>Δ</code> sets the effect of the vorticity profile (see <a href="#VortexPasta.BiotSavart.ParamsBiotSavart"><code>ParamsBiotSavart</code></a> for details);</p></li><li><p>the optional parameter <code>segment_fraction</code> can be used to indicate that the LIA term should only be computed over a fraction of the segments neighbouring the node <code>f[i]</code>. In that case, it should be a real number in <span>$(0, 1]$</span> (where 1 corresponds to integrating over the full segments, which the default);</p></li><li><p>a quadrature rule can be passed via <code>quad</code>, which can improve the estimation of the LIA term and the stability of the solver (even a 1-point quadrature rule can importantly improve stability!);</p></li><li><p>if <code>quad = nothing</code>, one may set <code>fit_circle = true</code> to estimate the binormal vector by fitting a circle passing through 3 neighbouring nodes (as done in Schwarz PRB 1985), instead of using local derivatives. For now, this is only implemented for <code>q = Velocity()</code>, and it may be removed in the future.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/shortrange/lia.jl#L27-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.nearby_charges" href="#VortexPasta.BiotSavart.nearby_charges"><code>VortexPasta.BiotSavart.nearby_charges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nearby_charges(c::ShortRangeCache, x⃗::Vec3)</code></pre><p>Return an iterator over the charges that are &quot;close&quot; to the location <code>x⃗</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/shortrange/shortrange.jl#L32-L36">source</a></section></article><h2 id="Long-range-interactions"><a class="docs-heading-anchor" href="#Long-range-interactions">Long-range interactions</a><a id="Long-range-interactions-1"></a><a class="docs-heading-anchor-permalink" href="#Long-range-interactions" title="Permalink"></a></h2><h3 id="Backends-2"><a class="docs-heading-anchor" href="#Backends-2">Backends</a><a class="docs-heading-anchor-permalink" href="#Backends-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.LongRangeBackend" href="#VortexPasta.BiotSavart.LongRangeBackend"><code>VortexPasta.BiotSavart.LongRangeBackend</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LongRangeBackend</code></pre><p>Abstract type denoting the backend to use for computing long-range interactions.</p><p><strong>Implemented backends</strong></p><ul><li><p><a href="#VortexPasta.BiotSavart.NonuniformFFTsBackend"><code>NonuniformFFTsBackend</code></a>: estimates long-range interactions via the non-uniform fast Fourier transform (NUFFT) using the <a href="https://github.com/jipolanco/NonuniformFFTs.jl">NonuniformFFTs.jl</a> package;</p></li><li><p><a href="#VortexPasta.BiotSavart.FINUFFTBackend"><code>FINUFFTBackend</code></a>: estimates long-range interactions via the NUFFT using the <a href="https://github.com/flatironinstitute/finufft">FINUFFT</a> library;</p></li><li><p><a href="#VortexPasta.BiotSavart.ExactSumBackend"><code>ExactSumBackend</code></a>: computes long-range interactions using exact Fourier sums. This is really inefficient and should only be used for testing.</p></li></ul><p><strong>Extended help</strong></p><p><strong>Implementation details</strong></p><p>The following functions must be implemented by a <code>BACKEND &lt;: LongRangeBackend</code>:</p><ul><li><p><code>init_cache_long_ewald(c::ParamsCommon, p::ParamsLongRange{&lt;:BACKEND}, to::TimerOutput) -&gt; LongRangeCache</code>.</p></li><li><p><a href="#VortexPasta.BiotSavart.expected_period"><code>expected_period</code></a> (optional),</p></li><li><p><a href="#VortexPasta.BiotSavart.folding_limits"><code>folding_limits</code></a> (optional).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/types_longrange.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.NonuniformFFTsBackend" href="#VortexPasta.BiotSavart.NonuniformFFTsBackend"><code>VortexPasta.BiotSavart.NonuniformFFTsBackend</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonuniformFFTsBackend &lt;: LongRangeBackend</code></pre><p>Compute long-range interactions using the <a href="https://github.com/jipolanco/NonuniformFFTs.jl">NonuniformFFTs.jl</a> package.</p><p>This backend may be faster than other NUFFT-based backends since it allows real valued non-uniform data, meaning that we can use real-to-complex FFTs to accelerate computations.</p><p>Computations are parallelised by default using threads.</p><p><strong>Optional arguments</strong></p><p>The signature of <code>NonuniformFFTsBackend</code> is:</p><pre><code class="nohighlight hljs">NonuniformFFTsBackend(; σ = 1.5, m = HalfSupport(4), kws...)</code></pre><p>where all arguments are passed to NonuniformFFTs.jl.</p><p>Some relevant options are:</p><ul><li><p><code>σ = 1.5</code>: upsampling factor, which must be larger than 1. Usual values are between 1.25 (smaller FFTs, less accurate) and 2.0 (larger FFTs, more accurate). Other values such as 1.5 (default) also work;</p></li><li><p><code>m = HalfSupport(4)</code>: the half-width of the NUFFT kernels. Larger means higher accuracy;</p></li><li><p><code>fftw_flags = FFTW.MEASURE</code>: flags passed to the FFTW planner.</p></li></ul><p>The default parameters (<code>σ = 1.5</code>, <code>m = HalfSupport(4)</code>) correspond to a relative NUFFT tolerance of <span>$∼10^{-6}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/longrange/nonuniformffts.jl#L6-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.FINUFFTBackend" href="#VortexPasta.BiotSavart.FINUFFTBackend"><code>VortexPasta.BiotSavart.FINUFFTBackend</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FINUFFTBackend &lt;: LongRangeBackend</code></pre><p>Compute long-range interactions using the <a href="https://github.com/ludvigak/FINUFFT.jl">FINUFFT.jl</a> package.</p><p>This package provides a Julia interface to the <a href="https://github.com/flatironinstitute/finufft">FINUFFT</a> C++ library, which enables efficient and accurate computation of non-uniform fast Fourier transforms (NUFFTs) based on an &quot;exponential of a semi-circle&quot; kernel.</p><p>Computations can be parallelised using threads.</p><p><strong>Optional arguments</strong></p><p>The signature of <code>FINUFFTBackend</code> is:</p><pre><code class="nohighlight hljs">FINUFFTBackend(; tol = 1.0e-6, kws...)</code></pre><p>where all arguments are passed to FINUFFT.</p><p>Some relevant options are:</p><ul><li><p><code>tol = 1.0e-6</code> tolerance in NUFFT computations;</p></li><li><p><code>upsampfac = 1.25</code> upsampling factor. Must be either 1.25 (usually faster) or 2.0 (required to exceed 9 digits of accuracy);</p></li><li><p><code>nthreads = Threads.nthreads()</code> number of threads to use. By default, all threads available to Julia are used;</p></li><li><p><code>fftw = FFTW.MEASURE</code> flags passed to the FFTW planner;</p></li><li><p><code>chkbnds = false</code> if <code>true</code>, check that non-uniform points are in <span>$[-3π, 3π)$</span>;</p></li></ul><p>Other options described in the <a href="https://finufft.readthedocs.io/en/latest/opts.html">FINUFFT docs</a> and not listed above are also accepted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/longrange/finufft.jl#L13-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.ExactSumBackend" href="#VortexPasta.BiotSavart.ExactSumBackend"><code>VortexPasta.BiotSavart.ExactSumBackend</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExactSumBackend &lt;: LongRangeBackend</code></pre><p>Compute long-range interactions &quot;exactly&quot; (up to filament discretisation errors) using sums of Fourier series across non-uniform points.</p><p>This should only be used for testing, as it is very slow and scales very badly with the number of non-uniform points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/longrange/exact_sum.jl#L7-L15">source</a></section></article><h3 id="Internals-2"><a class="docs-heading-anchor" href="#Internals-2">Internals</a><a class="docs-heading-anchor-permalink" href="#Internals-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.LongRangeCache" href="#VortexPasta.BiotSavart.LongRangeCache"><code>VortexPasta.BiotSavart.LongRangeCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LongRangeCache</code></pre><p>Abstract type describing the storage of data required to compute long-range interactions.</p><p>The <a href="#VortexPasta.BiotSavart.init_cache_long"><code>init_cache_long</code></a> function returns a concrete instance of a <code>LongRangeCache</code> (or <code>NullLongRangeCache()</code>, if long-range computations were disabled by setting <code>α = Zero()</code>).</p><p><strong>Useful fields</strong></p><p>Most useful fields of a <code>cache::LongRangeCache</code> are in the <code>cache.common</code> field. In particular, <code>cache.common</code> contains the fields:</p><ul><li><code>wavenumbers::NTuple{3, AbstractVector}</code>: Fourier wavenumbers in each direction;</li><li><code>uhat::StructArray{Vec3{Complex{T}}, 3}</code>: a full vector field in Fourier space;</li><li><code>pointdata::PointData</code>: data associated to vector charges applied on non-uniform points. These are available in <code>pointdata.charges</code> and <code>pointdata.points</code>;</li><li><code>ewald_prefactor::Real</code>: the quantity <span>$Γ / V$</span> where <span>$V$</span> is the volume of a periodic cell.</li></ul><p><strong>Extended help</strong></p><p><strong>Implementation details</strong></p><p><strong>Fields</strong></p><p>All caches must include a <code>common &lt;: LongRangeCacheCommon</code> field which contains common definitions for all backends.</p><p><strong>Functions</strong></p><p>The following functions must be implemented by a cache:</p><ul><li><p><a href="#VortexPasta.BiotSavart.transform_to_fourier!"><code>transform_to_fourier!</code></a>,</p></li><li><p><a href="#VortexPasta.BiotSavart.interpolate_to_physical!"><code>interpolate_to_physical!</code></a>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/types_longrange.jl#L62-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.NullLongRangeCache" href="#VortexPasta.BiotSavart.NullLongRangeCache"><code>VortexPasta.BiotSavart.NullLongRangeCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NullLongRangeCache &lt;: LongRangeCache</code></pre><p>Dummy cache type returned by <a href="#VortexPasta.BiotSavart.init_cache_long"><code>init_cache_long</code></a> when long-range computations are disabled.</p><p>This is the case when the Ewald splitting parameter <span>$α$</span> is set to <code>Zero()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/longrange/longrange.jl#L53-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.init_cache_long" href="#VortexPasta.BiotSavart.init_cache_long"><code>VortexPasta.BiotSavart.init_cache_long</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">init_cache_long(p::ParamsLongRange, pointdata::PointData, [to::TimerOutput]) -&gt; LongRangeCache</code></pre><p>Initialise the cache for the long-range backend defined in <code>p</code>.</p><p>Note that, if <code>pc.α === Zero()</code>, then long-range computations are disabled and this returns a <a href="#VortexPasta.BiotSavart.NullLongRangeCache"><code>NullLongRangeCache</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/longrange/longrange.jl#L65-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.expected_period" href="#VortexPasta.BiotSavart.expected_period"><code>VortexPasta.BiotSavart.expected_period</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expected_period(::LongRangeBackend) -&gt; Union{Nothing, Real}</code></pre><p>Domain period expected by the backend.</p><p>This is used for rescaling input coordinates to the requirements of the backend. For instance, FINUFFT assumes a period <span>$2π$</span>, and therefore coordinates are rescaled if the input data has a period different from <span>$2π$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/types_longrange.jl#L37-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.folding_limits" href="#VortexPasta.BiotSavart.folding_limits"><code>VortexPasta.BiotSavart.folding_limits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">folding_limits(::LongRangeBackend) -&gt; Union{Nothing, NTuple{2, Real}}</code></pre><p>Domain limits required by the backend.</p><p>This is used for folding input coordinates so that they are within the limits expected by the backend. For instance, FINUFFT requires coordinates to be in the <span>$[-3π, 3π]$</span> interval.</p><p>Note that, if a backend defines <code>folding_limits</code>, then it must also define <a href="#VortexPasta.BiotSavart.expected_period"><code>expected_period</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/types_longrange.jl#L48-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.set_num_points!" href="#VortexPasta.BiotSavart.set_num_points!"><code>VortexPasta.BiotSavart.set_num_points!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_num_points!(data::PointData, N::Integer)</code></pre><p>Set the total number of non-uniform points that the cache must hold.</p><p>This will reallocate space to make all points fit in the cache. It will also reset the contributions of previously-added charges.</p><p>Must be called before <a href="#VortexPasta.BiotSavart.add_point!"><code>add_point!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/pointdata.jl#L37-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.add_point_charges!" href="#VortexPasta.BiotSavart.add_point_charges!"><code>VortexPasta.BiotSavart.add_point_charges!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_point_charges!(data::PointData, fs::AbstractVector{&lt;:AbstractFilament}, quad::StaticSizeQuadrature)
add_point_charges!(cache::LongRangeCache, fs::AbstractVector{&lt;:AbstractFilament})</code></pre><p>Add vector charges at multiple non-uniform locations.</p><p>This can be used for both short-range and long-range computations.</p><p>In the case of long-range computations, this must be done before type-1 NUFFTs, to transform from non-uniform data in physical space to uniform data in Fourier space. It must be called before <a href="#VortexPasta.BiotSavart.compute_vorticity_fourier!"><code>compute_vorticity_fourier!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/pointdata.jl#L60-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.add_point!" href="#VortexPasta.BiotSavart.add_point!"><code>VortexPasta.BiotSavart.add_point!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_point!(data::PointData, X::Vec3, i::Int)</code></pre><p>Add an interpolation point for type-2 NUFFT.</p><p>This is used for type-2 NUFFTs, to transform (interpolate) from uniform data in Fourier space to non-uniform data in physical space.</p><p>The total number of locations must be first set via <a href="#VortexPasta.BiotSavart.set_num_points!"><code>set_num_points!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/pointdata.jl#L128-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.compute_vorticity_fourier!" href="#VortexPasta.BiotSavart.compute_vorticity_fourier!"><code>VortexPasta.BiotSavart.compute_vorticity_fourier!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_vorticity_fourier!(cache::LongRangeCache)</code></pre><p>Estimate vorticity in Fourier space.</p><p>The vorticity, written to <code>cache.common.uhat</code>, is estimated using some variant of non-uniform Fourier transforms (depending on the chosen backend).</p><p>Note that this function doesn&#39;t perform smoothing over the vorticity using the Ewald operator. Moreover, the resulting vorticity doesn&#39;t have the right dimensions, as it must be multiplied by <span>$Γ/V$</span> (where <span>$Γ$</span> is the circulation and <span>$V$</span> is the volume of a periodic cell) to have dimensions <span>$T^{-1}$</span>. In fact, this factor is included in the Ewald operator (see <a href="#VortexPasta.BiotSavart.to_smoothed_streamfunction!"><code>to_smoothed_streamfunction!</code></a> for details).</p><p>Must be called after <a href="#VortexPasta.BiotSavart.add_point_charges!"><code>add_point_charges!</code></a>.</p><p>After calling this function, one may want to use <a href="#VortexPasta.BiotSavart.to_smoothed_streamfunction!"><code>to_smoothed_streamfunction!</code></a> and/or <a href="#VortexPasta.BiotSavart.to_smoothed_velocity!"><code>to_smoothed_velocity!</code></a> to obtain the respective fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/longrange/longrange.jl#L297-L315">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.to_smoothed_streamfunction!" href="#VortexPasta.BiotSavart.to_smoothed_streamfunction!"><code>VortexPasta.BiotSavart.to_smoothed_streamfunction!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_smoothed_streamfunction!(cache::LongRangeCache)</code></pre><p>Convert Fourier-transformed vorticity field to coarse-grained streamfunction field in Fourier space.</p><p>This operation can be simply written as:</p><p class="math-container">\[\hat{\bm{ψ}}_{α}(\bm{k}) = ϕ_α(|\bm{k}|) \, \hat{\bm{ω}}(\bm{k})\]</p><p>where</p><p class="math-container">\[ϕ_α(k) = \frac{Γ}{V} \, \frac{e^{-k^2 / 4α^2}}{k^2}\]</p><p>is the Ewald operator. The effect of this operator is to:</p><ol><li>invert the Laplacian in <span>$-∇² \bm{ψ} = \bm{\omega}$</span>;</li><li>smoothen the fields according to the Ewald parameter <span>$α$</span> (an inverse length scale);</li><li>rescale values by the vortex circulation <span>$Γ$</span> and the volume <span>$V$</span> of a periodic cell so that the streamfunction has the right units (<span>$L^2 T^{-1}$</span>).</li></ol><p>This function should be called after <a href="#VortexPasta.BiotSavart.compute_vorticity_fourier!"><code>compute_vorticity_fourier!</code></a>. If one only needs the velocity and not the streamfunction, one can also directly call <a href="#VortexPasta.BiotSavart.to_smoothed_velocity!"><code>to_smoothed_velocity!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/longrange/longrange.jl#L117-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.to_smoothed_velocity!" href="#VortexPasta.BiotSavart.to_smoothed_velocity!"><code>VortexPasta.BiotSavart.to_smoothed_velocity!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_smoothed_velocity!(cache::LongRangeCache)</code></pre><p>Convert Fourier-transformed vorticity field to coarse-grained velocity field in Fourier space.</p><p>If called right after <a href="#VortexPasta.BiotSavart.compute_vorticity_fourier!"><code>compute_vorticity_fourier!</code></a>, this function performs the operation:</p><p class="math-container">\[\hat{\bm{v}}_{α}(\bm{k}) = i \bm{k} × ϕ_α(|\bm{k}|) \, \, \hat{\bm{ω}}(\bm{k}),\]</p><p>where <span>$ϕ_α$</span> is the Ewald operator defined in <a href="#VortexPasta.BiotSavart.to_smoothed_streamfunction!"><code>to_smoothed_streamfunction!</code></a>.</p><p>Optionally, if one is also interested in the streamfunction, one can call <a href="#VortexPasta.BiotSavart.to_smoothed_streamfunction!"><code>to_smoothed_streamfunction!</code></a> <em>before</em> this function. In that case, the cache already contains the smoothed streamfunction, and only the curl operator (<span>$i \bm{k} ×$</span>) is applied by this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/longrange/longrange.jl#L161-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.interpolate_to_physical!" href="#VortexPasta.BiotSavart.interpolate_to_physical!"><code>VortexPasta.BiotSavart.interpolate_to_physical!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interpolate_to_physical!(cache::LongRangeCache)</code></pre><p>Perform type-2 NUFFT to interpolate values in <code>cache.uhat</code> to non-uniform points in physical space.</p><p>Results are written to <code>cache.pointdata.charges</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/longrange/longrange.jl#L208-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.transform_to_fourier!" href="#VortexPasta.BiotSavart.transform_to_fourier!"><code>VortexPasta.BiotSavart.transform_to_fourier!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform_to_fourier!(cache::LongRangeCache)</code></pre><p>Transform stored non-uniform data to Fourier space.</p><p>This usually corresponds to a type-1 NUFFT.</p><p>Non-uniform data must be first added via <a href="#VortexPasta.BiotSavart.add_point_charges!"><code>add_point_charges!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/longrange/longrange.jl#L106-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.similar-Tuple{LongRangeCache, Tuple{Int64, Int64, Int64}}" href="#Base.similar-Tuple{LongRangeCache, Tuple{Int64, Int64, Int64}}"><code>Base.similar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.similar(cache::LongRangeCache, Ns::Dims{3}) -&gt; LongRangeCache</code></pre><p>Create a <a href="#VortexPasta.BiotSavart.LongRangeCache"><code>LongRangeCache</code></a> similar to an existent one, but possibly holding a different amount of wavenumbers in Fourier space.</p><p>In principle, the grid resolution <code>Ns</code> can be different from the original one (<code>cache.common.params.Ns</code>). This can be useful for computing high-resolution fields in Fourier space (e.g. for extending the data to higher wavenumbers than allowed by the original cache).</p><p>For convenience, point data already in <code>cache.common.pointdata</code> is copied to the new cache. This means that, if one already filled the original cache using <a href="#VortexPasta.BiotSavart.add_point_charges!"><code>add_point_charges!</code></a>, then one can directly call <a href="#VortexPasta.BiotSavart.transform_to_fourier!"><code>transform_to_fourier!</code></a> with the new cache to get the vorticity field in Fourier space at the wanted resolution <code>Ns</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/longrange/longrange.jl#L82-L97">source</a></section></article><h2 id="Internals-3"><a class="docs-heading-anchor" href="#Internals-3">Internals</a><a class="docs-heading-anchor-permalink" href="#Internals-3" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.BiotSavartCache" href="#VortexPasta.BiotSavart.BiotSavartCache"><code>VortexPasta.BiotSavart.BiotSavartCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BiotSavartCache</code></pre><p>Includes arrays and data required for computation of Biot–Savart integrals.</p><p><strong>Fields</strong></p><ul><li><p><code>pointdata</code>: contains vector values at points in space. This is used for both short-range and long-range computations;</p></li><li><p><code>shortrange</code>: cache associated to short-range computations;</p></li><li><p><code>longrange</code>: cache associated to long-range computations. It can be <code>NullLongRangeCache()</code> in case the Ewald parameter <code>α</code> was set to <code>Zero()</code>;</p></li><li><p><code>to</code>: a <code>TimerOutput</code> instance for measuring the time spent on different functions.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/cache.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.BiotSavart.background_vorticity_correction!" href="#VortexPasta.BiotSavart.background_vorticity_correction!"><code>VortexPasta.BiotSavart.background_vorticity_correction!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">background_vorticity_correction!(
    fields::NamedTuple, fs::AbstractVector{&lt;:AbstractFilament}, params::ParamsBiotSavart,
)</code></pre><p>Correct computed fields in case the mean filament vorticity is non-zero.</p><p>This ensures that results do not depend on the Ewald splitting parameter <span>$α$</span> when the filament &quot;charge&quot; is non-zero in a periodic domain.</p><p>In practice, as detailed below, this function only corrects the short-range streamfunction, as the velocity is not affected by the background vorticity, and long-range corrections are done implicitly in Fourier space.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function is automatically called by <a href="#VortexPasta.BiotSavart.compute_on_nodes!"><code>compute_on_nodes!</code></a> and should never be called manually. This documentation is only included for information purposes.</p></div></div><p><strong>Extended help</strong></p><p>The mean vorticity associated to the filaments is given by</p><p class="math-container">\[⟨ \bm{ω} ⟩ = -\frac{Γ}{V} ∮_{\mathcal{C}} \mathrm{d}\bm{s},\]</p><p>where <span>$V = L^3$</span> is the periodic domain volume.</p><p>This quantity is always zero when all filaments are closed. It can be non-zero if there are infinite unclosed filaments which are not compensated by oppositely-oriented infinite filaments.</p><p>When the mean filament vorticity is non-zero, one must compensate it by adding a uniform background vorticity <span>$\bm{ω}_{\text{back}} = -⟨ \bm{ω} ⟩$</span>, so that the total circulation around the volume is zero.</p><p>In practice, in the long-range component of Ewald summation, this compensation is done implicitly by setting the zero mode <span>$\hat{\bm{\omega}}(\bm{k} = \bm{0}) = \bm{0}$</span>. As for the short-range component, only the streamfunction needs to be corrected, while the velocity is not affected by the background vorticity.</p><p>The correction to the short-range streamfunction is given by</p><p class="math-container">\[\bm{ψ}^{&lt;}_{\text{back}}
= \frac{\bm{ω}_{\text{back}}}{4π} ∫_{\mathbb{R}^3} \frac{\operatorname{erfc}(α|\bm{r}|)}{|\bm{r}|} \, \mathrm{d}^3\bm{r}
= \frac{\bm{ω}_{\text{back}}}{4 α^2}\]</p><p>Therefore, this function simply adds this short-range correction to the streamfunction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/533e8ea7f9920e608e39ea0dd251856bb5881e9e/src/BiotSavart/BiotSavart.jl#L141-L193">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../FindNearbySegments/">« FindNearbySegments</a><a class="docs-footer-nextpage" href="../Reconnections/">Reconnections »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Monday 1 July 2024 12:02">Monday 1 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
