<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - lcov.info - src/Filaments/src/Filaments/utils.jl</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="title">LCOV - code coverage report</td></tr>
            <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

            <tr>
              <td width="100%">
                <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="10%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">src/Filaments/src/Filaments</a> - utils.jl</td>
            <td width="5%"></td>
            <td width="5%"></td>
            <td width="5%" class="headerCovTableHead">Coverage</td>
            <td width="5%" class="headerCovTableHead" title="Covered + Uncovered code">Total</td>
            <td width="5%" class="headerCovTableHead" title="Exercised code only">Hit</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">lcov.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntryMed">86.6&nbsp;%</td>
            <td class="headerCovTableEntry">97</td>
            <td class="headerCovTableEntry">84</td>
          </tr>
          <tr>
            <td class="headerItem">Test Date:</td>
            <td class="headerValue">2024-07-01 11:54:38</td>
            <td></td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
                  <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
                </table>
              </td>
            </tr>

            <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
          </table>

          <table cellpadding=0 cellspacing=0 border=0>
            <tr>
              <td><br></td>
            </tr>
            <tr>
              <td>
<pre class="sourceHeading">            Line data    Source code</pre>
<pre class="source">
<span id="L1"><span class="lineNum">       1</span>              : using ..BasicTypes: Infinity</span>
<span id="L2"><span class="lineNum">       2</span>              : </span>
<span id="L3"><span class="lineNum">       3</span>              : &quot;&quot;&quot;</span>
<span id="L4"><span class="lineNum">       4</span>              :     fold_periodic!(Xs::AbstractVector{&lt;:Vec3}, Ls::NTuple{3, Real}) -&gt; Bool</span>
<span id="L5"><span class="lineNum">       5</span>              : </span>
<span id="L6"><span class="lineNum">       6</span>              : Fold a set of coordinates onto the main unit cell.</span>
<span id="L7"><span class="lineNum">       7</span>              : </span>
<span id="L8"><span class="lineNum">       8</span>              : The idea is that the filament coordinates are (mainly) in the main unit cell, given by</span>
<span id="L9"><span class="lineNum">       9</span>              : ``[0, L₁] × [0, L₂] × [0, L₃]``, where ``Lᵢ`` is the period in each direction.</span>
<span id="L10"><span class="lineNum">      10</span>              : </span>
<span id="L11"><span class="lineNum">      11</span>              : This is nice for visualisations, and might also improve performance of the</span>
<span id="L12"><span class="lineNum">      12</span>              : folding required by long-range computations.</span>
<span id="L13"><span class="lineNum">      13</span>              : </span>
<span id="L14"><span class="lineNum">      14</span>              : To avoid creating discontinuities in the filament, what this function actually</span>
<span id="L15"><span class="lineNum">      15</span>              : does is to make sure that the *average* among all filament nodes is in the main</span>
<span id="L16"><span class="lineNum">      16</span>              : unit cell.</span>
<span id="L17"><span class="lineNum">      17</span>              : </span>
<span id="L18"><span class="lineNum">      18</span>              : Returns `true` if coordinates were modified, `false` otherwise.</span>
<span id="L19"><span class="lineNum">      19</span>              : In the first case, one may want to call [`update_coefficients!`](@ref) to update the curve</span>
<span id="L20"><span class="lineNum">      20</span>              : representation.</span>
<span id="L21"><span class="lineNum">      21</span>              : &quot;&quot;&quot;</span>
<span id="L22"><span class="lineNum">      22</span> <span class="tlaGNC tlaBgGNC">        7011 : function fold_periodic!(Xs::AbstractVector{&lt;:Vec3}, periods::NTuple{3, Real})</span></span>
<span id="L23"><span class="lineNum">      23</span> <span class="tlaGNC">        7011 :     Xmean = sum(Xs) ./ length(Xs)</span></span>
<span id="L24"><span class="lineNum">      24</span> <span class="tlaGNC">        7011 :     noffsets = map(_count_periodic_offsets, Xmean, periods)</span></span>
<span id="L25"><span class="lineNum">      25</span> <span class="tlaGNC">        7032 :     if all(==(0), noffsets)  # Xmean is already in the main unit cell</span></span>
<span id="L26"><span class="lineNum">      26</span> <span class="tlaGNC">        6990 :         return false</span></span>
<span id="L27"><span class="lineNum">      27</span>              :     end</span>
<span id="L28"><span class="lineNum">      28</span> <span class="tlaGNC">          21 :     δx⃗ = oftype(Xmean, noffsets .* periods)</span></span>
<span id="L29"><span class="lineNum">      29</span> <span class="tlaGNC">          42 :     for (i, x⃗) ∈ pairs(Xs)</span></span>
<span id="L30"><span class="lineNum">      30</span> <span class="tlaGNC">         532 :         Xs[i] = x⃗ + δx⃗</span></span>
<span id="L31"><span class="lineNum">      31</span> <span class="tlaGNC">         532 :     end</span></span>
<span id="L32"><span class="lineNum">      32</span> <span class="tlaUNC tlaBgUNC">           0 :     true</span></span>
<span id="L33"><span class="lineNum">      33</span>              : end</span>
<span id="L34"><span class="lineNum">      34</span>              : </span>
<span id="L35"><span class="lineNum">      35</span>              : &quot;&quot;&quot;</span>
<span id="L36"><span class="lineNum">      36</span>              :     fold_periodic!(f::AbstractFilament, Ls) -&gt; Bool</span>
<span id="L37"><span class="lineNum">      37</span>              : </span>
<span id="L38"><span class="lineNum">      38</span>              : Fold filament nodes onto the main unit cell.</span>
<span id="L39"><span class="lineNum">      39</span>              : </span>
<span id="L40"><span class="lineNum">      40</span>              : Returns `true` if coordinates were modified, `false` otherwise.</span>
<span id="L41"><span class="lineNum">      41</span>              : </span>
<span id="L42"><span class="lineNum">      42</span>              : If `true`, coefficients may need to be updated afterwards using [`update_coefficients!`](@ref).</span>
<span id="L43"><span class="lineNum">      43</span>              : &quot;&quot;&quot;</span>
<span id="L44"><span class="lineNum">      44</span> <span class="tlaGNC tlaBgGNC">        7011 : function fold_periodic!(f::AbstractFilament, periods::NTuple{3, Real})</span></span>
<span id="L45"><span class="lineNum">      45</span> <span class="tlaGNC">        7011 :     modified = fold_periodic!(nodes(f), periods) :: Bool</span></span>
<span id="L46"><span class="lineNum">      46</span> <span class="tlaGNC">        7011 :     if modified</span></span>
<span id="L47"><span class="lineNum">      47</span> <span class="tlaGNC">          21 :         pad_periodic!(nodes(f))</span></span>
<span id="L48"><span class="lineNum">      48</span>              :     end</span>
<span id="L49"><span class="lineNum">      49</span> <span class="tlaUNC tlaBgUNC">           0 :     modified</span></span>
<span id="L50"><span class="lineNum">      50</span>              : end</span>
<span id="L51"><span class="lineNum">      51</span>              : </span>
<span id="L52"><span class="lineNum">      52</span> <span class="tlaUNC">           0 : fold_periodic!(f, periods::Vec3) = fold_periodic!(f, Tuple(periods))</span></span>
<span id="L53"><span class="lineNum">      53</span>              : </span>
<span id="L54"><span class="lineNum">      54</span>              : # ======================================================================================== #</span>
<span id="L55"><span class="lineNum">      55</span>              : </span>
<span id="L56"><span class="lineNum">      56</span> <span class="tlaGNC tlaBgGNC">       21033 : function _count_periodic_offsets(x::Real, L::Real)</span></span>
<span id="L57"><span class="lineNum">      57</span> <span class="tlaGNC">       21033 :     offset = 0</span></span>
<span id="L58"><span class="lineNum">      58</span> <span class="tlaGNC">       21044 :     while x &lt; 0</span></span>
<span id="L59"><span class="lineNum">      59</span> <span class="tlaGNC">          11 :         x += L</span></span>
<span id="L60"><span class="lineNum">      60</span> <span class="tlaGNC">          11 :         offset += 1</span></span>
<span id="L61"><span class="lineNum">      61</span> <span class="tlaGNC">          11 :     end</span></span>
<span id="L62"><span class="lineNum">      62</span> <span class="tlaGNC">       21089 :     while x ≥ L</span></span>
<span id="L63"><span class="lineNum">      63</span> <span class="tlaGNC">          56 :         x -= L</span></span>
<span id="L64"><span class="lineNum">      64</span> <span class="tlaGNC">          56 :         offset -= 1</span></span>
<span id="L65"><span class="lineNum">      65</span> <span class="tlaGNC">          56 :     end</span></span>
<span id="L66"><span class="lineNum">      66</span> <span class="tlaUNC tlaBgUNC">           0 :     offset</span></span>
<span id="L67"><span class="lineNum">      67</span>              : end</span>
<span id="L68"><span class="lineNum">      68</span>              : </span>
<span id="L69"><span class="lineNum">      69</span> <span class="tlaUNC">           0 : _count_periodic_offsets(x::Real, ::Infinity) = 0</span></span>
<span id="L70"><span class="lineNum">      70</span>              : </span>
<span id="L71"><span class="lineNum">      71</span>              : # ======================================================================================== #</span>
<span id="L72"><span class="lineNum">      72</span>              : </span>
<span id="L73"><span class="lineNum">      73</span>              : # Return coordinate corresponding to x⃗ but in the main periodic cell.</span>
<span id="L74"><span class="lineNum">      74</span>              : # Here the periods are Ls = (Lx, Ly, Lz). If a component is `nothing`, then we do nothing in</span>
<span id="L75"><span class="lineNum">      75</span>              : # that direction (as if it was a non-periodic dimension).</span>
<span id="L76"><span class="lineNum">      76</span> <span class="tlaGNC tlaBgGNC">       22710 : to_main_periodic_cell(x⃗, Ls::Tuple) = oftype(x⃗, map(to_main_periodic_cell, x⃗, Ls))</span></span>
<span id="L77"><span class="lineNum">      77</span> <span class="tlaGNC">       19554 : to_main_periodic_cell(x, L::Nothing) = x  # don't do anything (non-periodic case)</span></span>
<span id="L78"><span class="lineNum">      78</span>              : </span>
<span id="L79"><span class="lineNum">      79</span> <span class="tlaGNC">        9996 : function to_main_periodic_cell(x::T, L::Real) where {T}</span></span>
<span id="L80"><span class="lineNum">      80</span> <span class="tlaGNC">        9996 :     while x ≥ L</span></span>
<span id="L81"><span class="lineNum">      81</span> <span class="tlaGNC">        1812 :         x -= L</span></span>
<span id="L82"><span class="lineNum">      82</span> <span class="tlaGNC">        1812 :     end</span></span>
<span id="L83"><span class="lineNum">      83</span> <span class="tlaGNC">       10098 :     while x &lt; 0</span></span>
<span id="L84"><span class="lineNum">      84</span> <span class="tlaGNC">         102 :         x += L</span></span>
<span id="L85"><span class="lineNum">      85</span> <span class="tlaGNC">         102 :     end</span></span>
<span id="L86"><span class="lineNum">      86</span> <span class="tlaGNC">        9996 :     x::T</span></span>
<span id="L87"><span class="lineNum">      87</span>              : end</span>
<span id="L88"><span class="lineNum">      88</span>              : </span>
<span id="L89"><span class="lineNum">      89</span>              : # ======================================================================================== #</span>
<span id="L90"><span class="lineNum">      90</span>              : </span>
<span id="L91"><span class="lineNum">      91</span>              : # Returns `true` if the distance between two points is larger than half the domain period in</span>
<span id="L92"><span class="lineNum">      92</span>              : # at least one direction. This is generally used to see if there is a periodic &quot;jump&quot;</span>
<span id="L93"><span class="lineNum">      93</span>              : # between two consecutive points of a filament (used for plots / VTK exports only).</span>
<span id="L94"><span class="lineNum">      94</span> <span class="tlaGNC">       31333 : is_jump(x⃗, x⃗_prev, Lhs::Tuple) = any(splat(is_jump), zip(x⃗, x⃗_prev, Lhs))</span></span>
<span id="L95"><span class="lineNum">      95</span> <span class="tlaGNC">       18609 : is_jump(x, x_prev, Lh::Nothing) = false</span></span>
<span id="L96"><span class="lineNum">      96</span> <span class="tlaGNC">        9578 : is_jump(x, x_prev, Lh::Real) = abs(x - x_prev) ≥ Lh</span></span>
<span id="L97"><span class="lineNum">      97</span>              : </span>
<span id="L98"><span class="lineNum">      98</span>              : # ======================================================================================== #</span>
<span id="L99"><span class="lineNum">      99</span>              : </span>
<span id="L100"><span class="lineNum">     100</span> <span class="tlaGNC">   232552678 : _find_knot_segment(ileft::Integer, tlims, ts, t) = (ileft, t)</span></span>
<span id="L101"><span class="lineNum">     101</span>              : </span>
<span id="L102"><span class="lineNum">     102</span> <span class="tlaGNC">        8367 : function _find_knot_segment(::Nothing, tlims, ts, t)</span></span>
<span id="L103"><span class="lineNum">     103</span> <span class="tlaGNC">        8367 :     ta, tb = tlims</span></span>
<span id="L104"><span class="lineNum">     104</span> <span class="tlaGNC">        8367 :     T = tb - ta</span></span>
<span id="L105"><span class="lineNum">     105</span>              :     # This enables evaluation outside of the knot limits.</span>
<span id="L106"><span class="lineNum">     106</span> <span class="tlaGNC">        8383 :     while t ≥ tb</span></span>
<span id="L107"><span class="lineNum">     107</span> <span class="tlaGNC">          16 :         t -= T</span></span>
<span id="L108"><span class="lineNum">     108</span> <span class="tlaGNC">          16 :     end</span></span>
<span id="L109"><span class="lineNum">     109</span> <span class="tlaGNC">        8367 :     while t &lt; ta</span></span>
<span id="L110"><span class="lineNum">     110</span> <span class="tlaUNC tlaBgUNC">           0 :         t += T</span></span>
<span id="L111"><span class="lineNum">     111</span> <span class="tlaUNC">           0 :     end</span></span>
<span id="L112"><span class="lineNum">     112</span> <span class="tlaGNC tlaBgGNC">        8367 :     i = searchsortedlast(ts, t) :: Int</span></span>
<span id="L113"><span class="lineNum">     113</span> <span class="tlaGNC">        8367 :     i, t</span></span>
<span id="L114"><span class="lineNum">     114</span>              : end</span>
<span id="L115"><span class="lineNum">     115</span>              : </span>
<span id="L116"><span class="lineNum">     116</span>              : # ======================================================================================== #</span>
<span id="L117"><span class="lineNum">     117</span>              : </span>
<span id="L118"><span class="lineNum">     118</span>              : &quot;&quot;&quot;</span>
<span id="L119"><span class="lineNum">     119</span>              :     close_filament!(f::ClosedFilament) -&gt; f</span>
<span id="L120"><span class="lineNum">     120</span>              : </span>
<span id="L121"><span class="lineNum">     121</span>              : Set the filamend endpoint based on its starting point and its end-to-end offset.</span>
<span id="L122"><span class="lineNum">     122</span>              : </span>
<span id="L123"><span class="lineNum">     123</span>              : This sets `f[end + 1] = f[begin] + Δ⃗` where `Δ⃗` is the end-to-end offset of the filament</span>
<span id="L124"><span class="lineNum">     124</span>              : (see [`end_to_end_offset`](@ref)).</span>
<span id="L125"><span class="lineNum">     125</span>              : </span>
<span id="L126"><span class="lineNum">     126</span>              : Calling this function is *not* needed if one has recently used</span>
<span id="L127"><span class="lineNum">     127</span>              : [`update_coefficients!`](@ref), which already closes the filaments.</span>
<span id="L128"><span class="lineNum">     128</span>              : This function should be used as a cheaper alternative to `update_coefficients!`, when one</span>
<span id="L129"><span class="lineNum">     129</span>              : only wants to close a filament (for instance to compute its length via</span>
<span id="L130"><span class="lineNum">     130</span>              : [`filament_length`](@ref)).</span>
<span id="L131"><span class="lineNum">     131</span>              : This function can also be used when the filament is no longer considered as &quot;valid&quot; by the</span>
<span id="L132"><span class="lineNum">     132</span>              : chosen discretisation method, which happens when the number of nodes falls below some</span>
<span id="L133"><span class="lineNum">     133</span>              : threshold (see [`check_nodes`](@ref)).</span>
<span id="L134"><span class="lineNum">     134</span>              : &quot;&quot;&quot;</span>
<span id="L135"><span class="lineNum">     135</span> <span class="tlaGNC">          30 : function close_filament!(f::ClosedFilament)</span></span>
<span id="L136"><span class="lineNum">     136</span> <span class="tlaGNC">          30 :     f[end + 1] = f[begin] + end_to_end_offset(f)</span></span>
<span id="L137"><span class="lineNum">     137</span> <span class="tlaUNC tlaBgUNC">           0 :     f</span></span>
<span id="L138"><span class="lineNum">     138</span>              : end</span>
<span id="L139"><span class="lineNum">     139</span>              : </span>
<span id="L140"><span class="lineNum">     140</span>              : # ======================================================================================== #</span>
<span id="L141"><span class="lineNum">     141</span>              : </span>
<span id="L142"><span class="lineNum">     142</span>              : &quot;&quot;&quot;</span>
<span id="L143"><span class="lineNum">     143</span>              :     filament_length(f::AbstractFilament; quad = nothing) -&gt; Real</span>
<span id="L144"><span class="lineNum">     144</span>              :     filament_length(fs::AbstractVector{&lt;:AbstractFilament}; quad = nothing) -&gt; Real</span>
<span id="L145"><span class="lineNum">     145</span>              : </span>
<span id="L146"><span class="lineNum">     146</span>              : Estimate the length of one or more filaments.</span>
<span id="L147"><span class="lineNum">     147</span>              : </span>
<span id="L148"><span class="lineNum">     148</span>              : By default, the filament length is estimated using a straight segment approximation, which</span>
<span id="L149"><span class="lineNum">     149</span>              : is fast but doesn't account for the actual curve geometry in-between discretisation points,</span>
<span id="L150"><span class="lineNum">     150</span>              : underestimating the actual length.</span>
<span id="L151"><span class="lineNum">     151</span>              : A quadrature rule may be optionally passed using `quad` (e.g. `quad = GaussLegendre(4)`)</span>
<span id="L152"><span class="lineNum">     152</span>              : to obtain a more accurate result.</span>
<span id="L153"><span class="lineNum">     153</span>              : </span>
<span id="L154"><span class="lineNum">     154</span>              : See also [`segment_length`](@ref), which is used by this function.</span>
<span id="L155"><span class="lineNum">     155</span>              : </span>
<span id="L156"><span class="lineNum">     156</span>              : # Requirements</span>
<span id="L157"><span class="lineNum">     157</span>              : </span>
<span id="L158"><span class="lineNum">     158</span>              : In the straight-segment implementation (`quad = nothing`), one needs the filaments to be</span>
<span id="L159"><span class="lineNum">     159</span>              : closed, i.e. `f[end + 1]` should be set to the right value.</span>
<span id="L160"><span class="lineNum">     160</span>              : This can be achieved either by [`update_coefficients!`](@ref) or [`close_filament!`](@ref).</span>
<span id="L161"><span class="lineNum">     161</span>              : </span>
<span id="L162"><span class="lineNum">     162</span>              : In the quadrature-based implementation (`quad &lt;: AbstractQuadrature`), the interpolation</span>
<span id="L163"><span class="lineNum">     163</span>              : coefficients must already have been computed via [`update_coefficients!`](@ref).</span>
<span id="L164"><span class="lineNum">     164</span>              : &quot;&quot;&quot;</span>
<span id="L165"><span class="lineNum">     165</span> <span class="tlaGNC tlaBgGNC">        1880 : function filament_length(f::AbstractFilament; quad = nothing)</span></span>
<span id="L166"><span class="lineNum">     166</span> <span class="tlaGNC">         940 :     T = number_type(f)</span></span>
<span id="L167"><span class="lineNum">     167</span> <span class="tlaGNC">         940 :     @assert T &lt;: AbstractFloat</span></span>
<span id="L168"><span class="lineNum">     168</span> <span class="tlaGNC">         940 :     L = zero(T)</span></span>
<span id="L169"><span class="lineNum">     169</span> <span class="tlaGNC">         940 :     for s ∈ segments(f)</span></span>
<span id="L170"><span class="lineNum">     170</span> <span class="tlaGNC">       30397 :         L += segment_length(s; quad)</span></span>
<span id="L171"><span class="lineNum">     171</span> <span class="tlaGNC">       30397 :     end</span></span>
<span id="L172"><span class="lineNum">     172</span> <span class="tlaUNC tlaBgUNC">           0 :     L</span></span>
<span id="L173"><span class="lineNum">     173</span>              : end</span>
<span id="L174"><span class="lineNum">     174</span>              : </span>
<span id="L175"><span class="lineNum">     175</span> <span class="tlaGNC tlaBgGNC">         862 : function filament_length(fs::AbstractVector{&lt;:AbstractFilament}; kws...)</span></span>
<span id="L176"><span class="lineNum">     176</span> <span class="tlaGNC">         431 :     T = number_type(fs)</span></span>
<span id="L177"><span class="lineNum">     177</span> <span class="tlaGNC">         431 :     @assert T &lt;: AbstractFloat</span></span>
<span id="L178"><span class="lineNum">     178</span> <span class="tlaGNC">         431 :     L = zero(T)</span></span>
<span id="L179"><span class="lineNum">     179</span> <span class="tlaGNC">         858 :     for f ∈ fs</span></span>
<span id="L180"><span class="lineNum">     180</span> <span class="tlaGNC">         936 :         L += filament_length(f; kws...)</span></span>
<span id="L181"><span class="lineNum">     181</span> <span class="tlaGNC">         936 :     end</span></span>
<span id="L182"><span class="lineNum">     182</span> <span class="tlaUNC tlaBgUNC">           0 :     L</span></span>
<span id="L183"><span class="lineNum">     183</span>              : end</span>
<span id="L184"><span class="lineNum">     184</span>              : </span>
<span id="L185"><span class="lineNum">     185</span>              : # ======================================================================================== #</span>
<span id="L186"><span class="lineNum">     186</span>              : </span>
<span id="L187"><span class="lineNum">     187</span>              : # TODO: move this to a separate &quot;misc&quot; module?</span>
<span id="L188"><span class="lineNum">     188</span>              : </span>
<span id="L189"><span class="lineNum">     189</span>              : &quot;&quot;&quot;</span>
<span id="L190"><span class="lineNum">     190</span>              :     number_type(x) -&gt; Type{&lt;:Number}</span>
<span id="L191"><span class="lineNum">     191</span>              : </span>
<span id="L192"><span class="lineNum">     192</span>              : Obtain the number type associated to a container `x`.</span>
<span id="L193"><span class="lineNum">     193</span>              : </span>
<span id="L194"><span class="lineNum">     194</span>              : This is expected to return a concrete type `T &lt;: Number`.</span>
<span id="L195"><span class="lineNum">     195</span>              : </span>
<span id="L196"><span class="lineNum">     196</span>              : This function can be useful when the actual number type is hidden behind many nested</span>
<span id="L197"><span class="lineNum">     197</span>              : array types.</span>
<span id="L198"><span class="lineNum">     198</span>              : </span>
<span id="L199"><span class="lineNum">     199</span>              : Some examples:</span>
<span id="L200"><span class="lineNum">     200</span>              : </span>
<span id="L201"><span class="lineNum">     201</span>              : - if `x` is a single `AbstractFilament{T}`, this returns `T`;</span>
<span id="L202"><span class="lineNum">     202</span>              : - if `x` is a vector or tuple of `AbstractFilament{T}`, this also returns `T`; </span>
<span id="L203"><span class="lineNum">     203</span>              : - if `x` is a vector of vectors of `SVector{3, T}`, this returns `T`.</span>
<span id="L204"><span class="lineNum">     204</span>              : </span>
<span id="L205"><span class="lineNum">     205</span>              : Note that, in the last two cases, this corresponds to `eltype(eltype(eltype(x)))`, which is</span>
<span id="L206"><span class="lineNum">     206</span>              : less readable and prone to errors.</span>
<span id="L207"><span class="lineNum">     207</span>              : &quot;&quot;&quot;</span>
<span id="L208"><span class="lineNum">     208</span> <span class="tlaGNC tlaBgGNC">       16713 : number_type(u) = eltype_nested(Number, u)</span></span>
<span id="L209"><span class="lineNum">     209</span>              : </span>
<span id="L210"><span class="lineNum">     210</span> <span class="tlaUNC tlaBgUNC">           0 : eltype_nested(::Type{X}, ::Type{T}) where {X, T} = error(lazy&quot;could not find elements of $X type from $T&quot;)</span></span>
<span id="L211"><span class="lineNum">     211</span> <span class="tlaGNC tlaBgGNC">       16713 : eltype_nested(::Type{X}, ::Type{T}) where {X, T &lt;: X} = T</span></span>
<span id="L212"><span class="lineNum">     212</span> <span class="tlaGNC">       54692 : eltype_nested(::Type{X}, ::Type{T}) where {X, T &lt;: AbstractArray} = (T &lt;: X) ? T : eltype_nested(X, eltype(T))</span></span>
<span id="L213"><span class="lineNum">     213</span> <span class="tlaUNC tlaBgUNC">           0 : eltype_nested(::Type{X}, ::Type{T}) where {X, T &lt;: NTuple} = (T &lt;: X) ? T : eltype_nested(X, eltype(T))</span></span>
<span id="L214"><span class="lineNum">     214</span> <span class="tlaGNC tlaBgGNC">       18879 : eltype_nested(::Type{X}, u::Any) where {X} = eltype_nested(X, typeof(u))</span></span>
<span id="L215"><span class="lineNum">     215</span>              : </span>
<span id="L216"><span class="lineNum">     216</span>              : # ======================================================================================== #</span>
<span id="L217"><span class="lineNum">     217</span>              : </span>
<span id="L218"><span class="lineNum">     218</span>              : # TESTING / EXPERIMENTAL</span>
<span id="L219"><span class="lineNum">     219</span>              : # This function may be removed in the future.</span>
<span id="L220"><span class="lineNum">     220</span>              : # The idea is to update the parametrisation of `f` to follow more closely the</span>
<span id="L221"><span class="lineNum">     221</span>              : # actual arc lengths of the filament. Not sure if it's worth it...</span>
<span id="L222"><span class="lineNum">     222</span> <span class="tlaGNC">           8 : function recompute_parametrisation!(f::ClosedFilament, quad::AbstractQuadrature)</span></span>
<span id="L223"><span class="lineNum">     223</span> <span class="tlaGNC">           8 :     m = interpolation_method(f)</span></span>
<span id="L224"><span class="lineNum">     224</span> <span class="tlaGNC">           8 :     _recompute_parametrisation!(m, f, quad)</span></span>
<span id="L225"><span class="lineNum">     225</span>              : end</span>
<span id="L226"><span class="lineNum">     226</span>              : </span>
<span id="L227"><span class="lineNum">     227</span>              : # In the case of straight segments (linear interpolation), the parametrisation</span>
<span id="L228"><span class="lineNum">     228</span>              : # cannot be improved from its initial estimation.</span>
<span id="L229"><span class="lineNum">     229</span> <span class="tlaGNC">           1 : _recompute_parametrisation!(::HermiteInterpolation{0}, f::AbstractFilament, quad) = f</span></span>
<span id="L230"><span class="lineNum">     230</span>              : </span>
<span id="L231"><span class="lineNum">     231</span> <span class="tlaGNC">           7 : function _recompute_parametrisation!(::Any, f::AbstractFilament, quad)</span></span>
<span id="L232"><span class="lineNum">     232</span> <span class="tlaGNC">           7 :     (; ts,) = f</span></span>
<span id="L233"><span class="lineNum">     233</span> <span class="tlaGNC">           7 :     @assert npad(ts) ≥ 1</span></span>
<span id="L234"><span class="lineNum">     234</span> <span class="tlaGNC">           7 :     tnext = ts[begin]</span></span>
<span id="L235"><span class="lineNum">     235</span> <span class="tlaGNC">           7 :     for i ∈ eachindex(ts)</span></span>
<span id="L236"><span class="lineNum">     236</span>              :         # Estimate arc length from ts[i] to ts[i + 1]</span>
<span id="L237"><span class="lineNum">     237</span> <span class="tlaGNC">         171 :         ℓ = integrate(f, i, quad) do f, i, ζ</span></span>
<span id="L238"><span class="lineNum">     238</span> <span class="tlaGNC">         684 :             norm(f(i, ζ, Derivative(1)))  # = ∂X/∂t</span></span>
<span id="L239"><span class="lineNum">     239</span>              :         end</span>
<span id="L240"><span class="lineNum">     240</span> <span class="tlaGNC">         171 :         @assert ℓ ≥ ts[i + 1] - ts[i]</span></span>
<span id="L241"><span class="lineNum">     241</span> <span class="tlaGNC">         171 :         ts[i] = tnext</span></span>
<span id="L242"><span class="lineNum">     242</span> <span class="tlaGNC">         171 :         tnext += ℓ  # this will be the new value of ts[i + 1], but we can't update it yet...</span></span>
<span id="L243"><span class="lineNum">     243</span> <span class="tlaGNC">         335 :     end</span></span>
<span id="L244"><span class="lineNum">     244</span> <span class="tlaGNC">           7 :     L = tnext - ts[begin]  # full length of the filament</span></span>
<span id="L245"><span class="lineNum">     245</span> <span class="tlaGNC">          24 :     pad_periodic!(ts, L)</span></span>
<span id="L246"><span class="lineNum">     246</span> <span class="tlaGNC">           7 :     _update_coefficients_only!(f)</span></span>
<span id="L247"><span class="lineNum">     247</span> <span class="tlaUNC tlaBgUNC">           0 :     f</span></span>
<span id="L248"><span class="lineNum">     248</span>              : end</span>
        </pre>
              </td>
            </tr>
          </table>
          <br>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
            <tr><td class="versionInfo">Generated by: <a href="https://github.com//linux-test-project/lcov" target="_parent">LCOV version 2.0-1</a></td></tr>
          </table>
          <br>

</body>
</html>
