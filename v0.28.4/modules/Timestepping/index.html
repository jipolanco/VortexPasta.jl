<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Timestepping · VortexPasta</title><meta name="title" content="Timestepping · VortexPasta"/><meta property="og:title" content="Timestepping · VortexPasta"/><meta property="twitter:title" content="Timestepping · VortexPasta"/><meta name="description" content="Documentation for VortexPasta."/><meta property="og:description" content="Documentation for VortexPasta."/><meta property="twitter:description" content="Documentation for VortexPasta."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/fonts.css" rel="stylesheet" type="text/css"/><script src="../../assets/sa.js" data-collect-dnt="true" async></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">VortexPasta</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">VortexPasta.jl</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/01-vortex_ring/">Vortex ring</a></li><li><a class="tocitem" href="../../tutorials/02-kelvin_waves/">Kelvin waves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Explanations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../methods/VFM/">The vortex filament model</a></li><li><a class="tocitem" href="../../methods/Ewald/">Ewald summation for Biot–Savart</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Tips and tricks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tips/parallelisation/">Parallelisation and clusters</a></li><li><a class="tocitem" href="../../tips/gpu/">GPU usage</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../PaddedArrays/">PaddedArrays</a></li><li><a class="tocitem" href="../PredefinedCurves/">PredefinedCurves</a></li><li><a class="tocitem" href="../CellLists/">CellLists</a></li><li><a class="tocitem" href="../Quadratures/">Quadratures</a></li><li><a class="tocitem" href="../Filaments/">Filaments</a></li><li><a class="tocitem" href="../FilamentIO/">FilamentIO</a></li><li><a class="tocitem" href="../FindNearbySegments/">FindNearbySegments</a></li><li><a class="tocitem" href="../Constants/">Constants</a></li><li><a class="tocitem" href="../BiotSavart/">BiotSavart</a></li><li><a class="tocitem" href="../SyntheticFields/">SyntheticFields</a></li><li><a class="tocitem" href="../Forcing/">Forcing</a></li><li><a class="tocitem" href="../Containers/">Containers</a></li><li><a class="tocitem" href="../Reconnections/">Reconnections</a></li><li class="is-active"><a class="tocitem" href>Timestepping</a><ul class="internal"><li><a class="tocitem" href="#Setting-up-a-simulation"><span>Setting-up a simulation</span></a></li><li><a class="tocitem" href="#Running-a-simulation"><span>Running a simulation</span></a></li><li><a class="tocitem" href="#Restarting-a-simulation"><span>Restarting a simulation</span></a></li><li><a class="tocitem" href="#Temporal-schemes"><span>Temporal schemes</span></a></li><li><a class="tocitem" href="#Adaptivity"><span>Adaptivity criteria</span></a></li><li><a class="tocitem" href="#Injecting-filaments-during-a-simulation"><span>Injecting filaments during a simulation</span></a></li><li><a class="tocitem" href="#Diagnostics"><span>Diagnostics</span></a></li><li><a class="tocitem" href="#Internals"><span>Internals</span></a></li></ul></li><li><a class="tocitem" href="../Diagnostics/">Diagnostics</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href>Timestepping</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Timestepping</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jipolanco/VortexPasta.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jipolanco/VortexPasta.jl/blob/master/docs/src/modules/Timestepping.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Timestepping"><a class="docs-heading-anchor" href="#Timestepping">Timestepping</a><a id="Timestepping-1"></a><a class="docs-heading-anchor-permalink" href="#Timestepping" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping" href="#VortexPasta.Timestepping"><code>VortexPasta.Timestepping</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Timestepping</code></pre><p>Module defining timestepping solvers for vortex filament simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/Timestepping.jl#L1-L5">source</a></section></article><h2 id="Setting-up-a-simulation"><a class="docs-heading-anchor" href="#Setting-up-a-simulation">Setting-up a simulation</a><a id="Setting-up-a-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-a-simulation" title="Permalink"></a></h2><p>The usual way of setting-up a simulation is to first create a <a href="#VortexPasta.Timestepping.VortexFilamentProblem"><code>VortexFilamentProblem</code></a> and then to call <a href="#CommonSolve.init"><code>init</code></a> to initialise a <a href="#VortexPasta.Timestepping.VortexFilamentSolver"><code>VortexFilamentSolver</code></a>:</p><pre><code class="language-julia hljs">using VortexPasta.Filaments
using VortexPasta.BiotSavart
using VortexPasta.Timestepping

fs = [Filaments.init(...) for n ∈ 1:10]          # initialise a set of filaments
params = ParamsBiotSavart(...)                   # set Biot-Savart parameters
tspan = (tmin, tmax)                             # set start and end time of simulation
prob = VortexFilamentProblem(fs, tspan, params)  # create problem
iter = init(prob, RK4(); dt = 0.01, ...)         # initialise VortexFilamentSolver</code></pre><hr/><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.VortexFilamentProblem" href="#VortexPasta.Timestepping.VortexFilamentProblem"><code>VortexPasta.Timestepping.VortexFilamentProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VortexFilamentProblem(fs::AbstractVector{&lt;:AbstractFilament}, tsim::Real, p::ParamsBiotSavart)
VortexFilamentProblem(fs::AbstractVector{&lt;:AbstractFilament}, tspan::NTuple{2,Real}, p::ParamsBiotSavart)
VortexFilamentProblem(checkpoint::LoadedCheckpoint, tsim::Real, p::ParamsBiotSavart)</code></pre><p>Define a vortex filament problem.</p><p>There are basically two ways of defining a problem:</p><ol><li><p>from scratch, from a new set of vortex filaments <code>fs</code>;</p></li><li><p>from a previous simulation, from a simulation state (<code>checkpoint</code>) returned from <a href="#VortexPasta.Timestepping.load_checkpoint"><code>load_checkpoint</code></a>.</p></li></ol><p><strong>Possible arguments</strong></p><ul><li><p><code>fs</code>: initial vortex positions;</p></li><li><p><code>checkpoint</code>: a simulation state returned from <a href="#VortexPasta.Timestepping.load_checkpoint"><code>load_checkpoint</code></a>;</p></li><li><p><code>tsim</code>: total simulation time;</p></li><li><p><code>tspan = (t_begin, t_end)</code>: time span;</p></li><li><p><code>p</code>: Biot–Savart parameters (see <a href="../BiotSavart/#VortexPasta.BiotSavart.ParamsBiotSavart"><code>ParamsBiotSavart</code></a>).</p></li></ul><p>See <a href="#CommonSolve.init"><code>init</code></a> for initialising a solver from a <code>VortexFilamentProblem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/problem.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CommonSolve.init" href="#CommonSolve.init"><code>CommonSolve.init</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init(prob::VortexFilamentProblem, scheme::TemporalScheme; dt::Real, kws...) -&gt; VortexFilamentSolver</code></pre><p>Initialise vortex filament problem.</p><p>Returns a <a href="#VortexPasta.Timestepping.VortexFilamentSolver"><code>VortexFilamentSolver</code></a> which can be advanced in time using either <a href="#CommonSolve.step!"><code>step!</code></a> or <a href="#CommonSolve.solve!"><code>solve!</code></a>.</p><p><strong>Mandatory positional arguments</strong></p><ul><li><p><code>prob</code>: a <a href="#VortexPasta.Timestepping.VortexFilamentProblem"><code>VortexFilamentProblem</code></a> containing the problem definition.</p></li><li><p><code>scheme</code>: a timestepping scheme (see <a href="#VortexPasta.Timestepping.TemporalScheme"><code>TemporalScheme</code></a>).</p></li></ul><p><strong>Mandatory keyword arguments</strong></p><ul><li><code>dt::Real</code>: the simulation timestep.</li></ul><p><strong>Optional keyword arguments</strong></p><ul><li><p><code>alias_u0 = false</code>: if <code>true</code>, the solver is allowed to modify the initial vortex filaments.</p></li><li><p><code>refinement = NoRefinement()</code>: criterion used for adaptive refinement of vortex filaments. See <a href="../Filaments/#VortexPasta.Filaments.RefinementCriterion"><code>RefinementCriterion</code></a> for a list of possible criteria.</p></li><li><p><code>reconnect = NoReconnections()</code>: criterion used to perform vortex reconnections. See <a href="../Reconnections/#VortexPasta.Reconnections.ReconnectionCriterion"><code>ReconnectionCriterion</code></a> for a list of possible criteria.</p></li><li><p><code>adaptivity = NoAdaptivity()</code>: criterion used for adaptively setting the timestep <code>dt</code>. See <a href="#VortexPasta.Timestepping.AdaptivityCriterion"><code>AdaptivityCriterion</code></a> for a list of possible criteria.</p></li><li><p><code>dtmin = 0.0</code>: minimum <code>dt</code> for adaptive timestepping. If <code>dt &lt; dtmin</code>, the solver is stopped with an error.</p></li><li><p><code>fast_term = LocalTerm()</code>: for IMEX and multirate schemes, this determines what is meant by &quot;fast&quot; and &quot;slow&quot; dynamics. This can either be <a href="#VortexPasta.Timestepping.LocalTerm"><code>LocalTerm</code></a> or <a href="#VortexPasta.Timestepping.ShortRangeTerm"><code>ShortRangeTerm</code></a>.</p></li><li><p><code>LIA = false</code>: if <code>true</code>, only use the local induction approximation (LIA) to advance vortex filaments, ignoring all non-local interactions. Note that reconnections may still be enabled.</p></li><li><p><code>fold_periodic = true</code>: if <code>true</code> (default), vortices will be recentred onto the main unit cell when using periodic boundary conditions. It may be convenient to disable this for visualisation purposes. This setting doesn&#39;t affect the results (velocity of each filament, reconnections, …), besides possible spatial translations of the filaments proportional to the domain period.</p></li><li><p><code>callback</code>: a function to be called at the end of each timestep. Its signature must be <code>callback(iter::VortexFilamentSolver)</code>. <strong>Filaments should not be modified</strong> by this function. In that case use <code>affect!</code> instead. See notes below for more details.</p></li><li><p><code>affect!</code>: similar to <code>callback</code>, but allows to modify filaments and other quantities at the end of each timestep. Its signature must be <code>affect!(iter::VortexFilamentSolver)</code>. See notes below for more details.</p></li><li><p><code>affect_t!</code>: similar to <code>affect!</code>, but allows to modify filaments and other quantities <em>within a timestep</em> (e.g. within each Runge–Kutta substep). Its signature must be <code>affect_t!(iter::VortexFilamentSolver, time::Real)</code>. See notes below for more details.</p></li><li><p><code>timer = TimerOutput(&quot;VortexFilament&quot;)</code>: an optional <code>TimerOutput</code> for recording the time spent on different functions.</p></li><li><p><code>external_velocity</code> / <code>external_streamfunction</code>: allows to add an external velocity field to &quot;force&quot; the filaments. See &quot;Adding an external velocity&quot; below for more details.</p></li><li><p><code>stretching_velocity</code>: allows to add an external &quot;stretching&quot; velocity to the filaments. This can be considered as an external energy (or length) injection mechanism. However, it can also lead to spurious Kelvin waves. See &quot;Adding a stretching velocity&quot; below for more details.</p></li><li><p><code>forcing</code>: adds an extra term to the vortex velocities representing a forcing term which generally injects energy (but it can also dissipate). See the <a href="../Forcing/#Forcing"><code>Forcing</code></a> module for different options.</p></li><li><p><code>dissipation</code>: adds an extra term to the vortex velocities representing a dissipation term which generally dissipates energy. See the <a href="../Forcing/#Forcing"><code>Forcing</code></a> module for different options.</p></li></ul><p><strong>Extended help</strong></p><p><strong>Difference between <code>callback</code>, <code>affect!</code> and <code>affect_t!</code></strong></p><p>The difference between the <code>callback(iter)</code> and <code>affect!(iter)</code> functions is the time at which they are called:</p><ul><li><p>the <code>affect!</code> function is called <em>before</em> performing Biot-Savart computations from the latest filament positions. In other words, the fields in <code>iter.quantities</code> are not synchronised with <code>iter.fs</code>, and it generally makes no sense to access them. Things like energy estimates will be incorrect if done in <code>affect!</code>. On the other hand, the <code>affect!</code> function <strong>allows to modify <code>iter.fs</code></strong> before Biot–Savart computations are performed. In particular, to inject new filaments, call <a href="#VortexPasta.Timestepping.inject_filament!"><code>inject_filament!</code></a> from within the <code>affect!</code> function.</p></li><li><p>the <code>callback</code> function is called <em>after</em> performing Biot-Savart computations. This means that the fields in <code>iter.quantities</code> have been computed from the latest filament positions. However, one <strong>must not modify <code>iter.fs</code></strong>, or otherwise the velocity <code>iter.vs</code> (which will be used at the next timestep) will no longer correspond to the filament positions.</p></li></ul><p>In addition, one can also set an <code>affect_t!(iter, t)</code> function which can be used to modify the state of the solver in a fine-grained manner, e.g. at each Runge–Kutta substep. Note that this function must take an additional argument <code>t</code> (the current time) as a second argument. This may be used, for instance, to apply a forcing which varies in time.</p><p><strong>Forcing / energy injection methods</strong></p><p>There are multiple implemented methods for affecting and injecting energy onto the vortex system. These methods can represent different physical mechanisms (or in fact be quite unphysical), and some of them can make more sense than others when simulating e.g. zero-temperature superfluids.</p><p><strong>Adding an external velocity</strong></p><p>One can set the <strong><code>external_velocity</code></strong> keyword argument to impose an external velocity field <span>$\bm{v}_{\text{f}}(\bm{x}, t)$</span>. In this case, the total velocity at a point <span>$\bm{x}$</span> (which can be on a vortex filament) will be</p><p class="math-container">\[\bm{v}(\bm{x}) = \bm{v}_{\text{BS}}(\bm{x}) + \bm{v}_{\text{f}}(\bm{x})\]</p><p>where <span>$\bm{v}_{\text{BS}}$</span> is the velocity obtained from the Biot–Savart law.</p><p>This can be a way of applying an external forcing (and injecting energy) to the vortex system.</p><p>The external velocity should be given as a function, which should have the signature <code>v_ext(x⃗::Vec3, t::Real) -&gt; Vec3</code>. The function should return a <code>Vec3</code> with the velocity at the location <code>x⃗</code> and time <code>t</code>. For example, to impose a constant sinusoidal forcing in the <span>$x$</span> direction which varies along <span>$z$</span>, the <code>external_velocity</code> keyword argument could look like:</p><pre><code class="nohighlight hljs">external_velocity = (x⃗, t) -&gt; Vec3(0.1 * sin(2 * x⃗.z), 0, 0)</code></pre><p>One usually wants the external velocity to be divergence-free, to preserve the incompressibility of the flow.</p><p><strong>Notes on energy estimation</strong></p><p>When setting an external velocity <span>$\bm{v}_{\text{f}}(\bm{x}, t)$</span>, one may also want to impose an external streamfunction field <span>$\bm{ψ}_{\text{f}}(\bm{x}, t)$</span> via the <strong><code>external_streamfunction</code></strong> keyword argument. Such a field plays no role in the dynamics, but it allows to include the kinetic energy associated to the external velocity field when calling <a href="../Diagnostics/#VortexPasta.Diagnostics.kinetic_energy_from_streamfunction"><code>Diagnostics.kinetic_energy_from_streamfunction</code></a>. If provided, the external streamfunction should satisfy <span>$\bm{v}_{\text{f}} = \bm{∇} × \bm{ψ}_{\text{f}}$</span>.</p><p>More precisely, when applying an external velocity field, the total kinetic energy is</p><p class="math-container">\[\begin{align*}
    E &amp;= \frac{1}{2V} ∫ |\bm{v}_{\text{BS}} + \bm{v}_{\text{f}}|^2 \, \mathrm{d}^3\bm{x}
    \\
    &amp;= \frac{1}{2V} \left[
    Γ ∮_{\mathcal{C}} \left( \bm{ψ}_{\text{BS}} + 2 \bm{ψ}_{\text{f}} \right) ⋅ \mathrm{d}\bm{s}
    +
    ∫ |\bm{v}_{\text{f}}|^2 \, \mathrm{d}^3\bm{x}
    \right],
\end{align*}\]</p><p>where <span>$\bm{ψ}_{\text{BS}}$</span> is the streamfunction obtained from the Biot-Savart law. Accordingly, when passing <code>external_streamfunction</code>, the streamfunction values attached to vortex filaments (in <code>iter.ψs</code>) will actually contain <span>$\bm{ψ}_{\text{BS}} + 2 \bm{ψ}_{\text{f}}$</span> (note the factor 2) to enable the computation of the full kinetic energy. Moreover, calling <a href="../Diagnostics/#VortexPasta.Diagnostics.kinetic_energy_from_streamfunction"><code>Diagnostics.kinetic_energy_from_streamfunction</code></a> with a <a href="#VortexPasta.Timestepping.VortexFilamentSolver"><code>VortexFilamentSolver</code></a> will automatically include an estimation of the kinetic energy of the external velocity field (the volume integral above).</p><div class="admonition is-info" id="Note-a99ff84ecfc4d6a9"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a99ff84ecfc4d6a9" title="Permalink"></a></header><div class="admonition-body"><p>Whether this total kinetic energy is of any physical interest is a different question, so it can be reasonable to ignore the <code>external_streamfunction</code> parameter in order to obtain the energy associated to <span>$\bm{v}_{\text{BS}}$</span> only.</p></div></div><p><strong>Adding a stretching velocity</strong></p><p>One can set the <strong><code>stretching_velocity</code></strong> keyword argument to impose a stretching velocity <span>$\bm{v}_\text{L}(ξ, t)$</span> on filament locations <span>$\bm{s}(ξ, t)$</span>. This velocity will be parallel (and generally opposite) to the curvature vector <span>$\bm{s}&#39;&#39; = ρ \bm{N}$</span>, where <span>$ρ$</span> is the curvature and <span>$\bm{N}$</span> the unit normal.</p><p>More precisely, the <code>stretching_velocity</code> parameter allows to set a filament velocity of the form</p><p class="math-container">\[\bm{v}_{\text{L}}(ξ) = -v_{\text{L}}[ρ(ξ)] \, \bm{N}(ξ)\]</p><p>where <span>$v_{\text{L}}$</span> is a velocity magnitude which can optionally depend on the local curvature value <span>$ρ$</span>. The <code>stretching_velocity</code> parameter should therefore be a function <code>v(ρ::Real) -&gt; Real</code>.</p><p>Note that <span>$\bm{v} ⋅ \bm{s}&#39;&#39;$</span> can be roughly interpreted as a local stretching rate (this is actually true for the integrated quantity, see <a href="../Diagnostics/#VortexPasta.Diagnostics.stretching_rate"><code>Diagnostics.stretching_rate</code></a>). Therefore, one may want <span>$v_{\text{L}}$</span> to be inversely proportional to the local curvature <span>$ρ$</span>, so that the local stretching rate is approximately independent of the filament location <span>$ξ$</span>. To achieve this, one may set</p><pre><code class="language-julia hljs">stretching_velocity = ρ -&gt; min(γ / ρ, v_max)</code></pre><p>where <code>γ</code> is a constant (units <span>$T^{-1}$</span>) setting the stretching magnitude, and <code>v_max</code> is a maximum stretching velocity used to avoid very large velocities in low-curvature regions. One could do something fancier and replace the <code>min</code> with a smooth regularisation such as</p><pre><code class="language-julia hljs">stretching_velocity = ρ -&gt; -expm1(-ρ / ρ₀) * (γ / ρ)  # note: expm1(x) = exp(x) - 1</code></pre><p>for some small curvature <span>$ρ₀$</span>. The maximum allowed velocity will then be <code>vmax = γ / ρ₀</code>.</p><p><strong>Forcing via a normal fluid</strong></p><p>Alternatively to the above approaches, one may impose a &quot;normal&quot; fluid velocity field to modify, via a mutual friction force, the velocity of the vortex filaments. To do this, one first needs to construct a <a href="../Forcing/#VortexPasta.Forcing.NormalFluidForcing"><code>NormalFluidForcing</code></a> (see that link for definitions and examples) representing a normal fluid velocity field. Then, the obtained object should be passed as the optional <code>forcing</code> argument.</p><p>In principle, this method can be combined with the previous ones. The normal fluid forcing will be applied <em>after</em> all the other forcing methods. In other words, the vortex velocity <span>$\bm{v}_{\text{s}}$</span> used to compute the mutual friction velocity includes all the other contributions (i.e. external and stretching velocities).</p><p>There is also a <a href="../Forcing/#VortexPasta.Forcing.FourierBandForcing"><code>FourierBandForcing</code></a> type which behaves similarly to <code>NormalFluidForcing</code> but is more localised in scale space, as it uses a band-pass filtered version of the superfluid velocity induced by the vortices.</p><p><strong>Injecting filaments over time</strong></p><p>Another way of injecting energy is simply by adding vortices to the simulation from time to time. This can be achieved by using an <code>affect!</code> function. See <a href="#VortexPasta.Timestepping.inject_filament!"><code>inject_filament!</code></a> for some more details.</p><p><strong>Energy minimisation mode</strong></p><p>It is also possible to run the simulation in &quot;energy minimisation&quot; mode, which can be useful for finding a minimal energy state from a given initial condition. In this mode, filaments will be advected not using the Biot–Savart velocity <span>$\bm{v}_{\text{s}}$</span>, but using the velocity <span>$-\bm{s}&#39; × \bm{v}_{\text{s}}$</span> where <span>$\bm{s}&#39;$</span> is the local unit tangent vector.</p><p>This is because the functional derivative of the energy (per unit mass) with respect to the vortex positions is:</p><pre><code class="language-julia hljs">\frac{δE}{δ\bm{s}} = Γ \bm{s}&#39; × \bm{v}_{\text{s}}</code></pre><p>In principle, the simulation should converge to a state that (locally) minimises the kinetic energy. In some cases, e.g. when one starts with a single closed vortex, this is simply a state where all vortices have disappeared.</p><p>Pass <code>mode = MinimalEnergy()</code> to enable this mode. Forcing should be disabled to run in this mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/Timestepping.jl#L377-L630">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.VortexFilamentSolver" href="#VortexPasta.Timestepping.VortexFilamentSolver"><code>VortexPasta.Timestepping.VortexFilamentSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VortexFilamentSolver</code></pre><p>Contains the instantaneous state of a vortex filament simulation.</p><p>Must be constructed using <a href="#CommonSolve.init"><code>init</code></a>.</p><p><strong>Included fields</strong></p><p>Some useful fields included in a <code>VortexFilamentSolver</code> are:</p><ul><li><p><code>prob</code>: associated <a href="#VortexPasta.Timestepping.VortexFilamentProblem"><code>VortexFilamentProblem</code></a> (including Biot–Savart parameters);</p></li><li><p><code>fs</code>: current state of vortex filaments in the system;</p></li><li><p><code>quantities</code>: a <code>NamedTuple</code> containing data on filament nodes at the current simulation timestep. See <strong>Physical quantities</strong> below for more details.</p></li><li><p><code>time</code>: a <a href="#VortexPasta.Timestepping.TimeInfo"><code>TimeInfo</code></a> object containing information such as the current time and timestep;</p></li><li><p><code>stats</code>: a <a href="#VortexPasta.Timestepping.SimulationStats"><code>SimulationStats</code></a> object containing information such as the total number of reconnections since the beginning of the simulation;</p></li><li><p><code>to</code>: a <code>TimerOutput</code>, which records the time spent on different functions;</p></li><li><p><code>cache_bs</code>: the Biot–Savart cache, which contains data from short- and long-range computations.</p></li></ul><p><strong>Physical quantities</strong></p><p>The <code>quantities</code> field is a <code>NamedTuple</code> containing instantaneous data on filament nodes. For example, <code>quantities.vs</code> is the self-induced vortex velocity. To get the velocity of filament <code>i</code> at node <code>j</code>, one can do <code>quantities.vs[i][j]</code>. Moreover, these quantities are often interpolable, which means that one can do <code>quantities.vs[i](j, 0.5)</code> to get the velocity in-between two nodes.</p><p>For convenience, if one has a <code>VortexFilamentSolver</code> <code>iter</code>, the shortcut <code>iter.vs</code> is equivalent to <code>iter.quantities.vs</code> (this also applies to all other quantities).</p><p><strong>List of quantities</strong></p><ul><li><p><code>vs</code>: self-induced vortex velocity (due to Biot–Savart law). If enabled, this also includes the contribution of an <code>external_velocity</code> (see <a href="#CommonSolve.init"><code>init</code></a>).</p></li><li><p><code>ψs</code>: self-induced streamfunction on vortices. This is useful for estimating the kinetic energy associated to the induced velocity field. If enabled, this also includes the contribution of an <code>external_streamfunction</code> (see <a href="#CommonSolve.init"><code>init</code></a>).</p></li></ul><p>If a normal fluid is present (e.g. by passing <code>forcing = NormalFluidForcing(...)</code> to <a href="#CommonSolve.init"><code>init</code></a>), then the following quantities are also available:</p><ul><li><p><code>vL</code>: actual filament velocity after mutual friction due to normal fluid (see <a href="../Forcing/#VortexPasta.Forcing.NormalFluidForcing"><code>NormalFluidForcing</code></a>).</p></li><li><p><code>vn</code>: normal fluid velocity at vortex locations.</p></li><li><p><code>tangents</code>: unit tangents <span>$\bm{s}&#39;$</span> at vortex locations.</p></li></ul><p>For convenience, if there is no normal fluid, then <code>vL</code> is defined as an alias of <code>vs</code> (they&#39;re the same object).</p><p>If <code>forcing = FourierBandForcingBS(...)</code> is passed (see <a href="../Forcing/#VortexPasta.Forcing.FourierBandForcingBS"><code>FourierBandForcingBS</code></a>), then the <code>vf</code> field contains the forcing term. Similarly, if <code>dissipation = SmallScaleDissipationBS(...)</code> (see <a href="../Forcing/#VortexPasta.Forcing.SmallScaleDissipationBS"><code>SmallScaleDissipationBS</code></a>), then the <code>vdiss</code> field contains the dissipation term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/Timestepping.jl#L155-L220">source</a></section></article><h2 id="Running-a-simulation"><a class="docs-heading-anchor" href="#Running-a-simulation">Running a simulation</a><a id="Running-a-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Running-a-simulation" title="Permalink"></a></h2><p>There are basically two ways of running a simulation:</p><ol><li><p>either by calling <a href="#CommonSolve.solve!"><code>solve!(iter)</code></a>, which will run the full simulation up to the final time <code>tmax</code>;</p></li><li><p>or by repeatedly calling <a href="#CommonSolve.step!"><code>step!(iter)</code></a> (for example inside a <code>for</code> loop) to advance the simulation one timestep at a time.</p></li></ol><p>The second option can seem to be more convenient as it allows to do things like running analyses or saving snapshots at intermediate stages of the simulation. However, those things are also easy to do with the first option, by passing a <code>callback</code> to the <a href="#CommonSolve.init"><code>init</code></a> function. See <a href="../../tutorials/01-vortex_ring/#tutorial-vortex-ring-simulation-state">this section</a> of the vortex ring tutorial for examples.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CommonSolve.solve!" href="#CommonSolve.solve!"><code>CommonSolve.solve!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve!(iter::VortexFilamentSolver)</code></pre><p>Advance vortex filament solver to the ending time.</p><p>See also <a href="#CommonSolve.step!"><code>step!</code></a> for advancing one step at a time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/Timestepping.jl#L895-L901">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CommonSolve.step!" href="#CommonSolve.step!"><code>CommonSolve.step!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">step!(iter::VortexFilamentSolver) -&gt; SimulationStatus</code></pre><p>Advance solver by a single timestep.</p><p>Returns a <code>SimulationStatus</code>. Currently, this can be:</p><ul><li><code>SUCCESS</code>,</li><li><code>NO_VORTICES_LEFT</code>: all vortices have been removed from the system; the simulation should be stopped.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/Timestepping.jl#L931-L941">source</a></section></article><h2 id="Restarting-a-simulation"><a class="docs-heading-anchor" href="#Restarting-a-simulation">Restarting a simulation</a><a id="Restarting-a-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Restarting-a-simulation" title="Permalink"></a></h2><p>One can write the current state of a simulation to disk using the <a href="#VortexPasta.Timestepping.save_checkpoint"><code>save_checkpoint</code></a> function. A simulation can then be restarted from that state using <a href="#VortexPasta.Timestepping.load_checkpoint"><code>load_checkpoint</code></a>.</p><p>The <code>save_checkpoint</code> function is built on top of <a href="../FilamentIO/#VortexPasta.FilamentIO.write_vtkhdf"><code>FilamentIO.write_vtkhdf</code></a>: it writes filament locations and optionally other data which can be visualised in ParaView, but also writes additional data such as solver parameters and the current state of the solver (time, timestep, ...).</p><p>The <a href="#VortexPasta.Timestepping.load_checkpoint"><code>load_checkpoint</code></a> function can be used to load a checkpoint to restart a simulation from that point.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.save_checkpoint" href="#VortexPasta.Timestepping.save_checkpoint"><code>VortexPasta.Timestepping.save_checkpoint</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">save_checkpoint([f::Function], filename, iter::VortexFilamentSolver; kwargs...)</code></pre><p>Save checkpoint to VTKHDF file (usually with <code>.vtkhdf</code> extension).</p><p>A checkpoint file is a VTKHDF file containing the current state of the solver. This includes things like vortex locations, the current time and timestep, and solver parameters. The file can be opened using ParaView allowing to visualise the current state (vortex locations and optionally other quantities).</p><p>In fact it is a VTKHDF file saved using <a href="../FilamentIO/#VortexPasta.FilamentIO.write_vtkhdf"><code>FilamentIO.write_vtkhdf</code></a> which contains extra information allowing to restart a simulation from a checkpoint while preserving continuity as much as possible.</p><p>To ease visualisations, filaments are folded onto the periodic box by default, which differs from the default behaviour of <a href="../FilamentIO/#VortexPasta.FilamentIO.write_vtkhdf"><code>FilamentIO.write_vtkhdf</code></a>. In particular, this means that filaments may be broken down into multiple elements. One can pass <code>periods = nothing</code> to disable this behaviour.</p><p>Keyword arguments are passed to <a href="../FilamentIO/#VortexPasta.FilamentIO.write_vtkhdf"><code>FilamentIO.write_vtkhdf</code></a>.</p><p><strong>Saving velocity and other quantities</strong></p><p>One can save other quantities for visualisation by passing an optional <code>f</code> function (usually via a <code>do</code> block, as in the example below). See <a href="../FilamentIO/#VortexPasta.FilamentIO.write_vtkhdf"><code>FilamentIO.write_vtkhdf</code></a> and the examples below for more details.</p><p><strong>Examples</strong></p><p>Run simulation and save checkpoint at the end:</p><pre><code class="language-julia hljs">prob = VortexFilamentProblem(...)
iter = init(prob, RK4(); ...)
solve!(iter)
filename = &quot;filaments_$(iter.nstep).vtkhdf&quot;
save_checkpoint(filename, iter) do io
    io[&quot;velocity_s&quot;] = iter.vs  # save superfluid velocity on vortices for visualisation
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/checkpoint.jl#L3-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.load_checkpoint" href="#VortexPasta.Timestepping.load_checkpoint"><code>VortexPasta.Timestepping.load_checkpoint</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load_checkpoint(filename, T, method::DiscretisationMethod) -&gt; LoadedCheckpoint</code></pre><p>Load simulation state previously written by <a href="#VortexPasta.Timestepping.save_checkpoint"><code>save_checkpoint</code></a>.</p><p>The resulting checkpoint can be used to construct a <a href="#VortexPasta.Timestepping.VortexFilamentProblem"><code>VortexFilamentProblem</code></a>.</p><p><strong>Examples</strong></p><p>Restart simulation from checkpoint:</p><pre><code class="language-julia hljs">p = BiotSavartParams(...)
checkpoint = load_checkpoint(&quot;filaments_1234.vtkhdf&quot;, Float64, CubicSplineMethod())
tsim = 2.0  # total simulation time
prob = VortexFilamentProblem(checkpoint, tsim, p)
iter = init(prob, RK4(); ...)
solve!(iter)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/checkpoint.jl#L97-L116">source</a></section></article><h2 id="Temporal-schemes"><a class="docs-heading-anchor" href="#Temporal-schemes">Temporal schemes</a><a id="Temporal-schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Temporal-schemes" title="Permalink"></a></h2><p>The following timesteppers are available. When possible, names are the same as those used by <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/">DifferentialEquations.jl solvers</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.TemporalScheme" href="#VortexPasta.Timestepping.TemporalScheme"><code>VortexPasta.Timestepping.TemporalScheme</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TemporalScheme</code></pre><p>Abstract type representing a timestepping scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/timesteppers/timesteppers.jl#L3-L7">source</a></section></article><h3 id="Explicit-Runge–Kutta-schemes"><a class="docs-heading-anchor" href="#Explicit-Runge–Kutta-schemes">Explicit Runge–Kutta schemes</a><a id="Explicit-Runge–Kutta-schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Explicit-Runge–Kutta-schemes" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.ExplicitScheme" href="#VortexPasta.Timestepping.ExplicitScheme"><code>VortexPasta.Timestepping.ExplicitScheme</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExplicitScheme &lt;: TemporalScheme</code></pre><p>Abstract type defining an explicit temporal scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/timesteppers/explicit/explicit.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.Euler" href="#VortexPasta.Timestepping.Euler"><code>VortexPasta.Timestepping.Euler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Euler &lt;: ExplicitScheme</code></pre><p>Standard first-order Euler scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/timesteppers/explicit/Euler.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.Midpoint" href="#VortexPasta.Timestepping.Midpoint"><code>VortexPasta.Timestepping.Midpoint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Midpoint &lt;: ExplicitScheme</code></pre><p>Second-order, two-stage explicit midpoint method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/timesteppers/explicit/midpoint.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.RK4" href="#VortexPasta.Timestepping.RK4"><code>VortexPasta.Timestepping.RK4</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RK4 &lt;: ExplicitScheme</code></pre><p>Classic 4-stage Runge–Kutta method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/timesteppers/explicit/RK4.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.SSPRK33" href="#VortexPasta.Timestepping.SSPRK33"><code>VortexPasta.Timestepping.SSPRK33</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SSPRK33 &lt;: ExplicitScheme</code></pre><p>Three-stage, third-order strong stability preserving (SSP) method.</p><p>See <a href="https://en.wikipedia.org/wiki/List_of_Runge%E2%80%93Kutta_methods#Third-order_Strong_Stability_Preserving_Runge-Kutta_(SSPRK3)">Wikipedia</a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/timesteppers/explicit/SSPRK33.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.DP5" href="#VortexPasta.Timestepping.DP5"><code>VortexPasta.Timestepping.DP5</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DP5 &lt;: ExplicitScheme</code></pre><p>Dormand–Prince embedded 4/5 Runge–Kutta method.</p><p>For now, the implementation is <strong>experimental</strong> and can be further optimised.</p><p>See <a href="https://en.wikipedia.org/wiki/Dormand%E2%80%93Prince_method">Wikipedia</a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/timesteppers/explicit/DP5.jl#L3-L11">source</a></section></article><h3 id="Implicit-explicit-Runge–Kutta-(IMEX-RK)-schemes"><a class="docs-heading-anchor" href="#Implicit-explicit-Runge–Kutta-(IMEX-RK)-schemes">Implicit-explicit Runge–Kutta (IMEX-RK) schemes</a><a id="Implicit-explicit-Runge–Kutta-(IMEX-RK)-schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Implicit-explicit-Runge–Kutta-(IMEX-RK)-schemes" title="Permalink"></a></h3><p>The following schemes treat local interactions implicitly and non-local interactions explicitly. This should hopefully allow for larger timesteps than fully explicit schemes.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.ImplicitExplicitScheme" href="#VortexPasta.Timestepping.ImplicitExplicitScheme"><code>VortexPasta.Timestepping.ImplicitExplicitScheme</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ImplicitExplicitScheme &lt;: TemporalScheme</code></pre><p>Abstract type defining an implicit-explicit (a.k.a. IMEX) temporal scheme.</p><p>The defined IMEX schemes treat the localised induction approximation (LIA) term as implicit. This may allow to increase the timestep, as it is the LIA term which imposes a small timestep in VFM simulations. Moreover, since this term is quite cheap to compute (compared to non-local interactions), treating it implicitly is not very expensive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/timesteppers/imex/imex.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.IMEXEuler" href="#VortexPasta.Timestepping.IMEXEuler"><code>VortexPasta.Timestepping.IMEXEuler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IMEXEuler &lt;: ImplicitExplicitScheme</code></pre><p>Forward-backward Euler scheme.</p><p>This is the (1,2,1) scheme in the notation of Ascher et al. (1997).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/timesteppers/imex/Euler.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.Ascher343" href="#VortexPasta.Timestepping.Ascher343"><code>VortexPasta.Timestepping.Ascher343</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Ascher343 &lt;: ImplicitExplicitScheme</code></pre><p>3rd order, 4 stage IMEX Runge–Kutta scheme by Ascher et al. (Appl. Numer. Math., 1997).</p><p>⚠ This scheme may be removed in the future as it behaves very similarly to <a href="#VortexPasta.Timestepping.KenCarp3"><code>KenCarp3</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/timesteppers/imex/Ascher343.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.KenCarp3" href="#VortexPasta.Timestepping.KenCarp3"><code>VortexPasta.Timestepping.KenCarp3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KenCarp3 &lt;: ImplicitExplicitScheme</code></pre><p>3rd order, 4 stage IMEX Runge–Kutta scheme by Kennedy &amp; Carpenter (Appl. Numer. Math., 2003).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/timesteppers/imex/KenCarp3.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.KenCarp4" href="#VortexPasta.Timestepping.KenCarp4"><code>VortexPasta.Timestepping.KenCarp4</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KenCarp4 &lt;: ImplicitExplicitScheme</code></pre><p>4th order, 6 stage IMEX Runge–Kutta scheme by Kennedy &amp; Carpenter (Appl. Numer. Math., 2003).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/timesteppers/imex/KenCarp4.jl#L3-L7">source</a></section></article><h3 id="Splitting-schemes"><a class="docs-heading-anchor" href="#Splitting-schemes">Splitting schemes</a><a id="Splitting-schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Splitting-schemes" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.SplittingScheme" href="#VortexPasta.Timestepping.SplittingScheme"><code>VortexPasta.Timestepping.SplittingScheme</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SplittingScheme &lt;: TemporalScheme</code></pre><p>Abstract type defining a splitting scheme (such as Strang splitting).</p><p>Like IMEX (<a href="#VortexPasta.Timestepping.ImplicitExplicitScheme"><code>ImplicitExplicitScheme</code></a>) and multirate (<a href="#VortexPasta.Timestepping.MultirateScheme"><code>MultirateScheme</code></a>) schemes, the idea is to split the Biot–Savart integral into two terms, respectively governing the &quot;fast&quot; dynamics (usually the local term) and the &quot;slow&quot; dynamics (non-local interactions).</p><p>The evolution due to both terms is approximated using some kind of Runge–Kutta scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/timesteppers/split/split.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.Strang" href="#VortexPasta.Timestepping.Strang"><code>VortexPasta.Timestepping.Strang</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Strang([fast = RK4()], [slow = Midpoint()]; nsubsteps::Int = 1) &lt;: SplittingScheme</code></pre><p>2nd order Strang splitting scheme.</p><p>Uses one scheme for advancing the &quot;fast&quot; terms (assumed to be cheap to compute as well), and possibly a different scheme for the &quot;slow&quot; (and expensive) terms. By default these schemes are respectively taken to be <a href="#VortexPasta.Timestepping.RK4"><code>RK4</code></a> and the 2nd order <a href="#VortexPasta.Timestepping.Midpoint"><code>Midpoint</code></a> method.</p><p>By default, according to Strang splitting, the fast term is advanced with a timestep of <code>dt/2</code> (twice in a full timestep). One can pass <code>nsubsteps</code> to use even smaller timesteps for the fast term.</p><p>See <a href="#VortexPasta.Timestepping.SplittingScheme"><code>SplittingScheme</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/timesteppers/split/strang.jl#L3-L17">source</a></section></article><h3 id="Multirate-Runge–Kutta-schemes"><a class="docs-heading-anchor" href="#Multirate-Runge–Kutta-schemes">Multirate Runge–Kutta schemes</a><a id="Multirate-Runge–Kutta-schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Multirate-Runge–Kutta-schemes" title="Permalink"></a></h3><p>These schemes are completely explicit, but use different timesteps (and different RK schemes) for the slow and fast dynamics. They are represented by an <em>outer</em> scheme of order <span>$n$</span> with a &quot;large&quot; timestep <span>$Δt$</span> for the slowly evolving terms (which are also expensive to compute), coupled to an <em>inner</em> scheme (typically of order <span>$n - 1$</span>) with a &quot;small&quot; timestep <span>$Δt/M$</span>. The implemented schemes are those described in <a href="https://doi.org/10.1137/18M1205492">Sandu, SIAM J. Numer. Anal. 57 (2019)</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.MultirateScheme" href="#VortexPasta.Timestepping.MultirateScheme"><code>VortexPasta.Timestepping.MultirateScheme</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MultirateScheme &lt;: TemporalScheme</code></pre><p>Abstract type defining a multirate scheme.</p><p>The idea is to treat different terms of the evolution equations with different timesteps (and possibly different integration schemes). Concretely, the fast dynamics is integrated with a smaller timestep (and a different <em>inner</em> scheme) than the slowly-evolving motions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/timesteppers/multirate/multirate.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.MultirateMidpoint" href="#VortexPasta.Timestepping.MultirateMidpoint"><code>VortexPasta.Timestepping.MultirateMidpoint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MultirateMidpoint([inner = Euler()], M::Int) &lt;: MultirateScheme</code></pre><p>2nd order, two-stage multirate infinitesimal, generalised additive Runge–Kutta (MRI-GARK) scheme.</p><p>Uses the explicit RK scheme <code>inner</code> for the fast component (by default a 1st order Euler scheme), with <code>M</code> inner steps for each outer RK stage.</p><p>This is the MRI-GARK-ERK22a method from Sandu, SIAM J. Numer. Anal. 57 (2019).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/timesteppers/multirate/midpoint.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.SanduMRI33a" href="#VortexPasta.Timestepping.SanduMRI33a"><code>VortexPasta.Timestepping.SanduMRI33a</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SanduMRI33a([inner = Midpoint()], M::Int) &lt;: MultirateScheme</code></pre><p>3rd order, 3-stage multirate infinitesimal, generalised additive Runge–Kutta (MRI-GARK) scheme.</p><p>Uses the explicit RK scheme <code>inner</code> for the fast component (by default a 2nd order midpoint scheme), with <code>M</code> inner steps for each outer RK stage.</p><p>This is the MRI-GARK-ERK33a method from Sandu, SIAM J. Numer. Anal. 57 (2019).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/timesteppers/multirate/MRI-GARK-ERK33a.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.SanduMRI45a" href="#VortexPasta.Timestepping.SanduMRI45a"><code>VortexPasta.Timestepping.SanduMRI45a</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SanduMRI45a([inner = SSPRK33()], M::Int) &lt;: MultirateScheme</code></pre><p>4th order, 5-stage multirate infinitesimal, generalised additive Runge–Kutta (MRI-GARK) scheme.</p><p>Uses the explicit RK scheme <code>inner</code> for the fast component, with <code>M</code> inner steps for each outer RK stage.</p><p>This is the MRI-GARK-ERK45 method from Sandu, SIAM J. Numer. Anal. 57 (2019).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/timesteppers/multirate/MRI-GARK-ERK45a.jl#L3-L12">source</a></section></article><h3 id="Implicit-schemes"><a class="docs-heading-anchor" href="#Implicit-schemes">Implicit schemes</a><a id="Implicit-schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Implicit-schemes" title="Permalink"></a></h3><p>These implicit schemes are mainly meant to be used as inner schemes when using multirate methods.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.ImplicitScheme" href="#VortexPasta.Timestepping.ImplicitScheme"><code>VortexPasta.Timestepping.ImplicitScheme</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ImplicitScheme &lt;: TemporalScheme</code></pre><p>Abstract type representing an implicit (possibly multi-stage) scheme.</p><p>These kinds of schemes are mainly meant to be used as inner schemes (for resolving fast-evolving dynamics which are also cheap to compute) when using <a href="#VortexPasta.Timestepping.MultirateScheme"><code>MultirateScheme</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/timesteppers/implicit/implicit.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.CrankNicolson" href="#VortexPasta.Timestepping.CrankNicolson"><code>VortexPasta.Timestepping.CrankNicolson</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CrankNicolson() &lt;: ImplicitScheme</code></pre><p>2nd order Crank–Nicolson implicit scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/timesteppers/implicit/CrankNicolson.jl#L3-L7">source</a></section></article><h3 id="Setting-the-fast-term"><a class="docs-heading-anchor" href="#Setting-the-fast-term">Setting the fast term</a><a id="Setting-the-fast-term-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-the-fast-term" title="Permalink"></a></h3><p>The splitting between fast and slow terms in IMEX and multirate schemes can be done in two different ways. One may either choose to identify the fast term with the local (LIA) term in Biot–Savart, or with the short-range component of Ewald summation.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.LocalTerm" href="#VortexPasta.Timestepping.LocalTerm"><code>VortexPasta.Timestepping.LocalTerm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LocalTerm &lt;: FastBiotSavartTerm</code></pre><p>Identifies fast dynamics with the <strong>local (LIA) term</strong> associated to the desingularisation of the Biot–Savart integral.</p><p>This is useful for split timestepping schemes like IMEX or multirate methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/Timestepping.jl#L145-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.ShortRangeTerm" href="#VortexPasta.Timestepping.ShortRangeTerm"><code>VortexPasta.Timestepping.ShortRangeTerm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ShortRangeTerm &lt;: FastBiotSavartTerm</code></pre><p>Identifies fast dynamics with the <strong>short-range component</strong> of Ewald splitting.</p><p>This is only useful for split timestepping schemes like IMEX or multirate methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/Timestepping.jl#L136-L142">source</a></section></article><h2 id="Adaptivity"><a class="docs-heading-anchor" href="#Adaptivity">Adaptivity criteria</a><a id="Adaptivity-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptivity" title="Permalink"></a></h2><p>A detailed below, a few temporal adaptivity criteria are available which can be used as the <code>adaptivity</code> argument of <a href="#CommonSolve.init"><code>init</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.AdaptivityCriterion" href="#VortexPasta.Timestepping.AdaptivityCriterion"><code>VortexPasta.Timestepping.AdaptivityCriterion</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdaptivityCriterion</code></pre><p>Abstract type representing a temporal adaptivity criterion.</p><p>Implemented adaptivity criteria are:</p><ul><li><p><a href="#VortexPasta.Timestepping.NoAdaptivity"><code>NoAdaptivity</code></a>: disables time adaptivity;</p></li><li><p><a href="#VortexPasta.Timestepping.AdaptBasedOnSegmentLength"><code>AdaptBasedOnSegmentLength</code></a>: determines the timestep <span>$Δt$</span> based on the minimum distance <span>$ℓ_{\min}$</span> between two filament nodes (<span>$Δt ∝ ℓ_{\min}^{-2}$</span>);</p></li><li><p><a href="#VortexPasta.Timestepping.AdaptBasedOnVelocity"><code>AdaptBasedOnVelocity</code></a>: determines the timestep <span>$Δt$</span> based on the maximum velocity <span>$v_{\max}$</span> of filament nodes and on a predefined distance <span>$δ$</span> (<span>$Δt = δ / v_{\max}$</span>).</p></li></ul><p><strong>Combining multiple criteria</strong></p><p>Adaptivity criteria can be combined using <code>|</code>. Example:</p><pre><code class="nohighlight hljs">adaptivity = AdaptBasedOnSegmentLength(1.4) | AdaptBasedOnVelocity(0.01)</code></pre><p>As expected, the timestep <span>$Δt$</span> will be chosen so that it satisfies both criteria.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/adaptivity.jl#L8-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.NoAdaptivity" href="#VortexPasta.Timestepping.NoAdaptivity"><code>VortexPasta.Timestepping.NoAdaptivity</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoAdaptivity &lt;: AdaptivityCriterion
NoAdaptivity()</code></pre><p>Disable temporal adaptivity, leaving the timestep <span>$Δt$</span> constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/adaptivity.jl#L49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.AdaptBasedOnSegmentLength" href="#VortexPasta.Timestepping.AdaptBasedOnSegmentLength"><code>VortexPasta.Timestepping.AdaptBasedOnSegmentLength</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdaptBasedOnSegmentLength &lt;: AdaptivityCriterion
AdaptBasedOnSegmentLength(γ::Float64)</code></pre><p>Adapt timestep <span>$Δt$</span> based on the minimum distance <span>$δ$</span> between two filament nodes.</p><p>More precisely, the timestep is set to <span>$Δt = γ \, T_{\text{KW}}(δ)$</span>, where <span>$γ$</span> is a dimensionless factor to be chosen, and:</p><p class="math-container">\[T_{\text{KW}}(λ) = \frac{2 λ^2}{Γ} {\left[
    \ln\left( \frac{λ}{πa} \right) + \frac{1}{2} - (Δ + γ)
\right]}^{-1}\]</p><p>is the period of a Kelvin wave of wavelength <span>$λ$</span>. See <a href="../BiotSavart/#VortexPasta.BiotSavart.ParamsBiotSavart"><code>ParamsBiotSavart</code></a> for the definitions of the vortex parameters <span>$Γ$</span>, <span>$a$</span> and <span>$Δ$</span>.</p><p>This criterion is somewhat analogous to the CFL condition in grid-based computations, and <span>$γ$</span> is the analogous of the maximum CFL number to be allowed. As such, the right value of <span>$γ$</span> will depend on the chosen temporal scheme.</p><p>For example, the <a href="#VortexPasta.Timestepping.RK4"><code>RK4</code></a> scheme seems to require <span>$γ ≈ 1$</span> to remain stable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/adaptivity.jl#L59-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.AdaptBasedOnVelocity" href="#VortexPasta.Timestepping.AdaptBasedOnVelocity"><code>VortexPasta.Timestepping.AdaptBasedOnVelocity</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdaptBasedOnVelocity &lt;: AdaptivityCriterion
AdaptBasedOnVelocity(δ_crit::Float64; safety_factor = 0.8)</code></pre><p>Adapt timestep <span>$Δt$</span> based on the maximum velocity <span>$v_{\max}$</span> of filament nodes.</p><p>The objective is that the resulting maximum displacement <span>$δ_{\max} = v_{\max} Δt$</span> stays below the given critical displacement <code>δ_crit</code>.</p><p>One application of this criterion is to ensure that reconnections happen in-between two solver iterations (that is, to avoid that two filaments cross each other without reconnecting). In this case, <span>$δ$</span> should be proportional to the chosen distance below which reconnections are performed.</p><p><strong>Implementation details</strong></p><p>This criterion is used in two ways:</p><ol><li><p>A priori, to decide the <span>$Δt$</span> to be used in the next iteration given the velocities of filament nodes at the start of the iteration (at time <span>$t$</span>). This ensures <span>$Δt ≤ δ_{\text{crit}} / v_{\max}$</span> where <span>$v_{\max}$</span> is computed at the start of the iteration.</p></li><li><p>A posteriori, after the actual node displacements <span>$δ$</span> from time <span>$t$</span> to time <span>$t + Δt$</span> have been computed (e.g. using some Runge–Kutta scheme). If some <span>$δ$</span> is larger than <span>$δ_{\text{crit}}$</span>, then the iteration is recomputed after halving the timestep (<span>$Δt → Δt/2$</span>). In this case, the original displacements are thrown away (rejected). This process can be eventually repeated until the criterion is satisfied.</p></li></ol><p><strong>Optional safety factor</strong></p><p>The optional <code>safety_factor</code> should be <code>≤1</code>, which will further reduce the timestep chosen a priori in step 1. This is to try to avoid too many rejected timesteps in step 2, e.g. in case the actual advection velocity is larger than the velocity at the beginning of the timestep.</p><p><strong>In combination with other criteria</strong></p><p>In principle, using this criterion can lead to an infinite timestep when the velocities are zero. For this reason, it&#39;s a good idea to combine this criterion with the <a href="#VortexPasta.Timestepping.AdaptBasedOnSegmentLength"><code>AdaptBasedOnSegmentLength</code></a> or the <a href="#VortexPasta.Timestepping.MaximumTimestep"><code>MaximumTimestep</code></a> criterion. For example:</p><pre><code class="nohighlight hljs">adaptivity = AdaptBasedOnVelocity(2.0) | AdaptBasedOnSegmentLength(0.9)
adaptivity = AdaptBasedOnVelocity(2.0) | MaximumTimestep(0.01)</code></pre><p>In fact, the second option is done automatically in <a href="#CommonSolve.init"><code>init</code></a> if only an <code>AdaptBasedOnVelocity</code> is passed. In that case, the maximum timestep is taken to be the <code>dt</code> passed to <code>init</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/adaptivity.jl#L109-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.MaximumTimestep" href="#VortexPasta.Timestepping.MaximumTimestep"><code>VortexPasta.Timestepping.MaximumTimestep</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MaximumTimestep &lt;: AdaptivityCriterion
MaximumTimestep(Δt_max::Float64)</code></pre><p>Criterion ensuring that the timestep will be kept below a maximal value <code>Δt_max</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/adaptivity.jl#L186-L191">source</a></section></article><h2 id="Injecting-filaments-during-a-simulation"><a class="docs-heading-anchor" href="#Injecting-filaments-during-a-simulation">Injecting filaments during a simulation</a><a id="Injecting-filaments-during-a-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Injecting-filaments-during-a-simulation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.inject_filament!" href="#VortexPasta.Timestepping.inject_filament!"><code>VortexPasta.Timestepping.inject_filament!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inject_filament!(iter::VortexFilamentSolver, f::AbstractFilament)</code></pre><p>Inject a filament onto a simulation.</p><p>This function <strong>must</strong> be called from within the <code>affect!</code> function attached to the solver (see <a href="#CommonSolve.init"><code>init</code></a> for details). Otherwise, the solver will likely use garbage values for the velocity of the injected filament, leading to wrong results or worse.</p><p><strong>Basic usage</strong></p><p>A very simplified (and incomplete) example of how to inject filaments during a simulation:</p><pre><code class="language-julia hljs"># Define function that will be called after each simulation timestep
function my_affect!(iter::VortexFilamentSolver)
    f = Filaments.init(...)  # create new filament
    inject_filament!(iter, f)
    return nothing
end

# Initialise and run simulation
prob = VortexFilamentProblem(...)
iter = init(prob, RK4(); affect! = my_affect!, etc...)
solve!(iter)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/Timestepping.jl#L1073-L1099">source</a></section></article><h2 id="Diagnostics"><a class="docs-heading-anchor" href="#Diagnostics">Diagnostics</a><a id="Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Diagnostics" title="Permalink"></a></h2><p>All diagnostics documented in the <a href="../Diagnostics/#VortexPasta.Diagnostics">Diagnostics</a> page can be conveniently computed using an instantaneous simulation state <code>iter</code> (of type <a href="#VortexPasta.Timestepping.VortexFilamentSolver"><code>VortexFilamentSolver</code></a>). See that page for more details.</p><h2 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.TemporalSchemeCache" href="#VortexPasta.Timestepping.TemporalSchemeCache"><code>VortexPasta.Timestepping.TemporalSchemeCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TemporalSchemeCache{Scheme &lt;: TemporalScheme}</code></pre><p>Contains buffers needed by a temporal scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/timesteppers/timesteppers.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.TimeInfo" href="#VortexPasta.Timestepping.TimeInfo"><code>VortexPasta.Timestepping.TimeInfo</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TimeInfo</code></pre><p>Contains information on the current time and timestep of a solver.</p><p>Some useful fields are:</p><ul><li><p><code>t::Float64</code>: current time;</p></li><li><p><code>dt::Float64</code>: timestep to be used in next iteration;</p></li><li><p><code>dt_prev::Float64</code> : timestep used in the last performed iteration;</p></li><li><p><code>nstep::Int</code>: number of timesteps performed until now;</p></li><li><p><code>nrejected::Int</code>: number of rejected iterations.</p></li></ul><p>When using the <a href="#VortexPasta.Timestepping.AdaptBasedOnVelocity"><code>AdaptBasedOnVelocity</code></a> criterion, an iteration can be rejected if the actual filament displacement is too large compared to what is imposed by the criterion. In that case, the iteration will be recomputed with a smaller timestep (<code>dt → dt/2</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/Timestepping.jl#L90-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.SimulationStats" href="#VortexPasta.Timestepping.SimulationStats"><code>VortexPasta.Timestepping.SimulationStats</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimulationStats{T &lt;: AbstractFloat}</code></pre><p>Contains accumulated statistics of different events occurring since the beginning of a simulation.</p><p><strong>Available fields</strong></p><ul><li><p><code>reconnection_count::Int</code>: <strong>total number of reconnections</strong>;</p></li><li><p><code>reconnection_length_loss::T</code>: accumulated <strong>decrease of filament length due to reconnections</strong>. This is estimated from each reconnection event as the difference between the local vortex lengths before and after the reconnection, using the straight segment approximation.</p></li><li><p><code>filaments_removed_count::Int</code>: <strong>total number of removed filaments</strong> (this generally happens when the number of discretisation points becomes too small for the spatial discretisation to work);</p></li><li><p><code>filaments_removed_length::T</code>: <strong>total length of removed filaments</strong>. Note that this length is estimated using a straight segment approximation (no quadratures). This is because filaments are removed when they can no longer be represented using a continuous interpolation function.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/simulation_stats.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VortexPasta.Timestepping.maximum_displacement" href="#VortexPasta.Timestepping.maximum_displacement"><code>VortexPasta.Timestepping.maximum_displacement</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">maximum_displacement(::AdaptivityCriterion) -&gt; Float64</code></pre><p>Return the maximum node displacement <span>$δ_{\text{crit}}$</span> allowed by the adaptivity criterion.</p><p>More precisely, <span>$δ_{\text{crit}}$</span> controls the maximum displacement of a filament node during a single timestep of duration <span>$Δt$</span>.</p><p>This function is mainly relevant when using the <a href="#VortexPasta.Timestepping.AdaptBasedOnVelocity"><code>AdaptBasedOnVelocity</code></a> criterion. For other criteria this returns <code>Inf</code>, meaning that they don&#39;t limit the maximum allowed displacement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jipolanco/VortexPasta.jl/blob/d64a785c81c27cdfc454aa47c5c23989e5c73dfa/src/Timestepping/adaptivity.jl#L33-L44">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Reconnections/">« Reconnections</a><a class="docs-footer-nextpage" href="../Diagnostics/">Diagnostics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Friday 27 June 2025 13:30">Friday 27 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
