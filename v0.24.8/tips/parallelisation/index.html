<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parallelisation · VortexPasta</title><meta name="title" content="Parallelisation · VortexPasta"/><meta property="og:title" content="Parallelisation · VortexPasta"/><meta property="twitter:title" content="Parallelisation · VortexPasta"/><meta name="description" content="Documentation for VortexPasta."/><meta property="og:description" content="Documentation for VortexPasta."/><meta property="twitter:description" content="Documentation for VortexPasta."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/fonts.css" rel="stylesheet" type="text/css"/><script src="../../assets/tomate.js"></script><script src="../../assets/sa.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">VortexPasta</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">VortexPasta.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/01-vortex_ring/">Vortex ring</a></li><li><a class="tocitem" href="../../tutorials/02-kelvin_waves/">Kelvin waves</a></li></ul></li><li><span class="tocitem">Explanations</span><ul><li><a class="tocitem" href="../../methods/VFM/">The vortex filament model</a></li><li><a class="tocitem" href="../../methods/Ewald/">Ewald summation for Biot–Savart</a></li></ul></li><li><span class="tocitem">Tips and tricks</span><ul><li class="is-active"><a class="tocitem" href>Parallelisation</a><ul class="internal"><li><a class="tocitem" href="#Starting-Julia-with-multiple-threads"><span>Starting Julia with multiple threads</span></a></li><li><a class="tocitem" href="#Pinning-threads"><span>Pinning threads</span></a></li><li><a class="tocitem" href="#slurm-job"><span>Running SLURM jobs</span></a></li><li><a class="tocitem" href="#Using-MKL-FFT-routines"><span>Using MKL FFT routines</span></a></li></ul></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../../modules/PaddedArrays/">PaddedArrays</a></li><li><a class="tocitem" href="../../modules/PredefinedCurves/">PredefinedCurves</a></li><li><a class="tocitem" href="../../modules/CellLists/">CellLists</a></li><li><a class="tocitem" href="../../modules/Quadratures/">Quadratures</a></li><li><a class="tocitem" href="../../modules/Filaments/">Filaments</a></li><li><a class="tocitem" href="../../modules/FilamentIO/">FilamentIO</a></li><li><a class="tocitem" href="../../modules/FindNearbySegments/">FindNearbySegments</a></li><li><a class="tocitem" href="../../modules/Constants/">Constants</a></li><li><a class="tocitem" href="../../modules/BiotSavart/">BiotSavart</a></li><li><a class="tocitem" href="../../modules/Containers/">Containers</a></li><li><a class="tocitem" href="../../modules/Reconnections/">Reconnections</a></li><li><a class="tocitem" href="../../modules/Timestepping/">Timestepping</a></li><li><a class="tocitem" href="../../modules/Diagnostics/">Diagnostics</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tips and tricks</a></li><li class="is-active"><a href>Parallelisation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parallelisation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jipolanco/VortexPasta.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jipolanco/VortexPasta.jl/blob/master/docs/src/tips/parallelisation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Parallelisation"><a class="docs-heading-anchor" href="#Parallelisation">Parallelisation</a><a id="Parallelisation-1"></a><a class="docs-heading-anchor-permalink" href="#Parallelisation" title="Permalink"></a></h1><p>VortexPasta.jl can take advantage of thread-based CPU parallelisation (equivalent to OpenMP). In particular, it can be run on a single node of a computing cluster.</p><h2 id="Starting-Julia-with-multiple-threads"><a class="docs-heading-anchor" href="#Starting-Julia-with-multiple-threads">Starting Julia with multiple threads</a><a id="Starting-Julia-with-multiple-threads-1"></a><a class="docs-heading-anchor-permalink" href="#Starting-Julia-with-multiple-threads" title="Permalink"></a></h2><p>There are <a href="https://docs.julialang.org/en/v1/manual/multi-threading/">a few ways</a> of starting Julia with multiple threads:</p><ol><li><p>either via the <a href="https://docs.julialang.org/en/v1/manual/environment-variables/#JULIA_NUM_THREADS"><code>JULIA_NUM_THREADS</code></a> environment variable,</p></li><li><p>or via the <code>-t / --threads</code> command-line option.</p></li></ol><p>If both are used, the second takes precedence.</p><p>The command-line flag can be used in two ways:</p><pre><code class="language-bash hljs">$ julia -t 8     # start Julia with 8 threads
$ julia -t auto  # start Julia with the number of CPUs available to this Julia process</code></pre><p>The second option can be useful in particular when running <a href="#slurm-job">SLURM jobs</a>, as Julia will use the number of CPUs associated to the SLURM allocation.</p><h2 id="Pinning-threads"><a class="docs-heading-anchor" href="#Pinning-threads">Pinning threads</a><a id="Pinning-threads-1"></a><a class="docs-heading-anchor-permalink" href="#Pinning-threads" title="Permalink"></a></h2><p>When Julia is started with multiple threads, it can (and often does) assign more than one thread to the same CPU, even when the requested number of threads is smaller or equal to the total number of CPUs. This is clearly suboptimal.</p><p>The <a href="https://github.com/carstenbauer/ThreadPinning.jl">ThreadPinning.jl</a> package solves this issue. The easiest way to use it by putting <a href="https://carstenbauer.github.io/ThreadPinning.jl/stable/examples/ex_pinning_julia_threads/#pinthreads">the following lines</a> at the top of your Julia script:</p><pre><code class="language-julia hljs">using ThreadPinning
pinthreads(:cores)</code></pre><p>Note that this should be changed <a href="#Pinning-SLURM-threads">when using SLURM</a>.</p><p>One can then check that threads are correctly pinned to separate CPUs using <a href="https://carstenbauer.github.io/ThreadPinning.jl/stable/examples/ex_pinning_julia_threads/#threadinfo_example"><code>threadinfo</code></a>.</p><h2 id="slurm-job"><a class="docs-heading-anchor" href="#slurm-job">Running SLURM jobs</a><a id="slurm-job-1"></a><a class="docs-heading-anchor-permalink" href="#slurm-job" title="Permalink"></a></h2><h3 id="slurm-submitting-jobs"><a class="docs-heading-anchor" href="#slurm-submitting-jobs">Submitting jobs</a><a id="slurm-submitting-jobs-1"></a><a class="docs-heading-anchor-permalink" href="#slurm-submitting-jobs" title="Permalink"></a></h3><p>Here is a sample SLURM script for running a simulation on which can be submitted using <code>sbatch</code>:</p><pre><code class="language-bash hljs">#!/bin/bash

#SBATCH --job-name=&quot;JOB_NAME&quot;
#SBATCH --partition=PARTITION_NAME_ON_CLUSTER
#SBATCH --time=1:00:00
#SBATCH --distribution=block:block
#SBATCH --nodes=1
#SBATCH --ntasks=1
#SBATCH --hint=nomultithread
#SBATCH --cpus-per-task=32
#SBATCH --exclusive
#SBATCH --mem=120G
#SBATCH --threads-per-core=1

echo &quot; - SLURM_JOB_ID = $SLURM_JOB_ID&quot;
echo &quot; - SLURM_JOB_NODELIST = $SLURM_JOB_NODELIST&quot;
echo &quot; - SLURM_TASKS_PER_NODE = $SLURM_TASKS_PER_NODE&quot;
echo &quot; - SLURM_CPUS_PER_TASK = $SLURM_CPUS_PER_TASK&quot;

srun --cpu-bind=verbose,cores julia -t auto --heap-size-hint=100G --project=. script.jl</code></pre><p>Here the number of threads is set via the <code>--cpus-per-task</code> option.</p><p>Some other notes:</p><ul><li><p>the <code>--exclusive</code> flag is optional; it is recommended if one wants to use a full node (i.e. if the number of requested CPUs corresponds to the total number of CPUs on a node);</p></li><li><p>above, we passed the <code>--heap-size-hint=100G</code> option to the <code>julia</code> command. This may help avoid out of memory errors, by telling Julia&#39;s garbage collector that the total used memory should stay below the specified value. Just to be sure, we also explicitly requested a (slightly larger) amount of memory to SLURM using the <code>--mem</code> option;</p></li><li><p>the <code>--hint=nomultithread</code> option tells SLURM to avoid using hyperthreading, which is generally not good for performance.</p></li></ul><h3 id="Pinning-SLURM-threads"><a class="docs-heading-anchor" href="#Pinning-SLURM-threads">Pinning SLURM threads</a><a id="Pinning-SLURM-threads-1"></a><a class="docs-heading-anchor-permalink" href="#Pinning-SLURM-threads" title="Permalink"></a></h3><p>As mentioned <a href="#Pinning-threads">above</a>, it is a good idea to pin Julia threads to the CPUs available to the Julia process.</p><p>When using SLURM, one can achieve this by using the <code>:affinitymask</code> criterion in ThreadPinning&#39;s <a href="https://carstenbauer.github.io/ThreadPinning.jl/stable/refs/api_pinning/#ThreadPinning.pinthreads"><code>pinthreads</code></a>:</p><pre><code class="language-julia hljs">using ThreadPinning
pinthreads(:affinitymask)</code></pre><p>It can be convenient to have a Julia script which does the Right Thing (TM) depending on whether it runs within a SLURM job or not. To achieve this, one can do:</p><pre><code class="language-julia hljs">using ThreadPinning

if haskey(ENV, &quot;SLURM_JOB_ID&quot;)
    pinthreads(:affinitymask)
else
    pinthreads(:cores)
end</code></pre><h2 id="Using-MKL-FFT-routines"><a class="docs-heading-anchor" href="#Using-MKL-FFT-routines">Using MKL FFT routines</a><a id="Using-MKL-FFT-routines-1"></a><a class="docs-heading-anchor-permalink" href="#Using-MKL-FFT-routines" title="Permalink"></a></h2><p>The default <a href="../../modules/BiotSavart/#VortexPasta.BiotSavart.NonuniformFFTsBackend"><code>NonuniformFFTsBackend</code></a> in VortexPasta.jl computes threaded FFTs using the <a href="https://github.com/JuliaMath/FFTW.jl">FFTW.jl</a> package, which by default wraps the FFTW libraries written in C. However, FFTW.jl has an <a href="https://github.com/JuliaMath/FFTW.jl/issues/236">unresolved issue</a> which can be encountered (somewhat randomly) when computing FFTs using a large number of threads.</p><h3 id="Switching-to-MKL-in-FFTW.jl"><a class="docs-heading-anchor" href="#Switching-to-MKL-in-FFTW.jl">Switching to MKL in FFTW.jl</a><a id="Switching-to-MKL-in-FFTW.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Switching-to-MKL-in-FFTW.jl" title="Permalink"></a></h3><p>One workaround is to switch to the FFT implementation in Intel&#39;s MKL libraries, which don&#39;t seem to display this issue. The FFTW.jl package makes it easy to <a href="https://github.com/JuliaMath/FFTW.jl?tab=readme-ov-file#mkl">switch</a> to the MKL implementation via their <a href="https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-fortran/2023-0/fftw3-interface-to-onemkl.html">FFTW interface</a>.</p><p>One simply needs to do:</p><pre><code class="language-julia hljs">using FFTW
FFTW.set_provider!(&quot;mkl&quot;)</code></pre><p>and restart Julia. This will create (or update) a <code>LocalPreferences.toml</code> file next to the <code>Project.toml</code> file associated to the active Julia project.</p><h3 id="Correctly-using-threads-with-MKL"><a class="docs-heading-anchor" href="#Correctly-using-threads-with-MKL">Correctly using threads with MKL</a><a id="Correctly-using-threads-with-MKL-1"></a><a class="docs-heading-anchor-permalink" href="#Correctly-using-threads-with-MKL" title="Permalink"></a></h3><p>The above change is not enough if one wants MKL&#39;s FFTs to be efficient when using threads. One also needs to set the following environment variables (for example in a <a href="#slurm-submitting-jobs">SLURM script</a>):</p><pre><code class="language-bash hljs">export MKL_NUM_THREADS=$SLURM_CPUS_PER_TASK      # on SLURM
export MKL_NUM_THREADS=$NUMBER_OF_JULIA_THREADS  # in general
export MKL_DYNAMIC=false</code></pre><p>The <code>MKL_DYNAMIC=false</code> option tells MKL <a href="https://carstenbauer.github.io/ThreadPinning.jl/stable/examples/ex_blas/#Intel-MKL">not to mess around with thread pinning</a>.</p><p>Secondly, one also needs to add:</p><pre><code class="language-julia hljs">using MKL</code></pre><p>at the start of the Julia script to be run (one may need to <code>]add MKL</code> first). Failing to do this can really degrade performance.</p><p>Note that one can also set the environment variables directly in the Julia script. Including <a href="#Pinning-SLURM-threads">thread pinning</a>, the beginning of the Julia script could look like:</p><pre><code class="language-julia hljs">using MKL
using ThreadPinning

ENV[&quot;MKL_NUM_THREADS&quot;] = Threads.nthreads()  # same as number of Julia threads
ENV[&quot;MKL_DYNAMIC&quot;] = false

if haskey(ENV, &quot;SLURM_JOB_ID&quot;)
    pinthreads(:affinitymask)
else
    pinthreads(:cores)
end

# Tell threadinfo to give us information about BLAS (and MKL) and optionally about the SLURM set-up.
threadinfo(blas = true, hints = true, slurm = haskey(ENV, &quot;SLURM_JOB_ID&quot;))</code></pre><p>Note that, with the <code>hints = true</code> option, ThreadPinning will complain about our choice of using <code>MKL_NUM_THREADS = number_of_julia_threads</code>. This warning can be ignored, since FFTs are executed from a single Julia thread and it&#39;s therefore what we want.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../methods/Ewald/">« Ewald summation for Biot–Savart</a><a class="docs-footer-nextpage" href="../../modules/PaddedArrays/">PaddedArrays »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 14 November 2024 16:05">Thursday 14 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
