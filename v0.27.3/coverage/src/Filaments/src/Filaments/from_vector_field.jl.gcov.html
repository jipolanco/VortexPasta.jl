<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - lcov.info - src/Filaments/src/Filaments/from_vector_field.jl</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="title">LCOV - code coverage report</td></tr>
            <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

            <tr>
              <td width="100%">
                <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="10%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">src/Filaments/src/Filaments</a> - from_vector_field.jl</td>
            <td width="5%"></td>
            <td width="5%"></td>
            <td width="5%" class="headerCovTableHead">Coverage</td>
            <td width="5%" class="headerCovTableHead" title="Covered + Uncovered code">Total</td>
            <td width="5%" class="headerCovTableHead" title="Exercised code only">Hit</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">lcov.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntryHi">96.1&nbsp;%</td>
            <td class="headerCovTableEntry">77</td>
            <td class="headerCovTableEntry">74</td>
          </tr>
          <tr>
            <td class="headerItem">Test Date:</td>
            <td class="headerValue">2025-05-23 08:54:30</td>
            <td></td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
                  <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
                </table>
              </td>
            </tr>

            <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
          </table>

          <table cellpadding=0 cellspacing=0 border=0>
            <tr>
              <td><br></td>
            </tr>
            <tr>
              <td>
<pre class="sourceHeading">            Line data    Source code</pre>
<pre class="source">
<span id="L1"><span class="lineNum">       1</span>              : using LinearAlgebra: normalize, norm</span>
<span id="L2"><span class="lineNum">       2</span>              : using ForwardDiff: ForwardDiff</span>
<span id="L3"><span class="lineNum">       3</span>              : </span>
<span id="L4"><span class="lineNum">       4</span>              : using ..Constants: Infinity</span>
<span id="L5"><span class="lineNum">       5</span>              : </span>
<span id="L6"><span class="lineNum">       6</span>              : @doc raw&quot;&quot;&quot;</span>
<span id="L7"><span class="lineNum">       7</span>              :     Filaments.from_vector_field(</span>
<span id="L8"><span class="lineNum">       8</span>              :         ClosedFilament, ωf::Function, s⃗₀, dτ, method::DiscretisationMethod;</span>
<span id="L9"><span class="lineNum">       9</span>              :         max_steps = 1000, nsubsteps = 1, redistribute = true,</span>
<span id="L10"><span class="lineNum">      10</span>              :     ) -&gt; ClosedFilament</span>
<span id="L11"><span class="lineNum">      11</span>              : </span>
<span id="L12"><span class="lineNum">      12</span>              : Initialise closed filament from vector field.</span>
<span id="L13"><span class="lineNum">      13</span>              : </span>
<span id="L14"><span class="lineNum">      14</span>              : Here `ωf` is a function ``\bm{ω}(\bm{x})`` which takes a 3D vector `x⃗` and returns a</span>
<span id="L15"><span class="lineNum">      15</span>              : vector value `ω⃗`.</span>
<span id="L16"><span class="lineNum">      16</span>              : A filament will be created such that, for each point ``\bm{s}`` on the filament, the tangent</span>
<span id="L17"><span class="lineNum">      17</span>              : vector ``\bm{s}'`` is parallel to the vector field at that point, ``\bm{ω}(\bm{s})``.</span>
<span id="L18"><span class="lineNum">      18</span>              : The field should be such that lines constructed this way are closed.</span>
<span id="L19"><span class="lineNum">      19</span>              : </span>
<span id="L20"><span class="lineNum">      20</span>              : A possible application of this function is for constructing a filament which approximates</span>
<span id="L21"><span class="lineNum">      21</span>              : **vortex lines** from a vorticity field ``\bm{ω}(\bm{x})``, which are precisely defined in this way.</span>
<span id="L22"><span class="lineNum">      22</span>              : In that case, if one actually knows the **velocity field** ``\bm{v}(\bm{x})`` -- such that</span>
<span id="L23"><span class="lineNum">      23</span>              : ``\bm{ω} = \bm{\nabla} × \bm{v}`` -- and one is too lazy to analytically derive the</span>
<span id="L24"><span class="lineNum">      24</span>              : corresponding vorticity field, one can pass `ωf = Filaments.curl(vf)` (see</span>
<span id="L25"><span class="lineNum">      25</span>              : [`curl`](@ref)) where `vf` is a function defining the velocity field.</span>
<span id="L26"><span class="lineNum">      26</span>              : </span>
<span id="L27"><span class="lineNum">      27</span>              : One may use [`Filaments.distance_to_field`](@ref) to verify the result of this function.</span>
<span id="L28"><span class="lineNum">      28</span>              : </span>
<span id="L29"><span class="lineNum">      29</span>              : ## Positional arguments</span>
<span id="L30"><span class="lineNum">      30</span>              : </span>
<span id="L31"><span class="lineNum">      31</span>              : - `ωf::Function`: function taking a 3D coordinate `x⃗` and returning a vector value `ω⃗`;</span>
<span id="L32"><span class="lineNum">      32</span>              : </span>
<span id="L33"><span class="lineNum">      33</span>              : - `s⃗₀::Vec3`: location where to start iterating.</span>
<span id="L34"><span class="lineNum">      34</span>              :    This point is guaranteed to be in the generated filament;</span>
<span id="L35"><span class="lineNum">      35</span>              : </span>
<span id="L36"><span class="lineNum">      36</span>              : - `dτ::Real`: approximately distance between filament nodes. Determines the number of nodes</span>
<span id="L37"><span class="lineNum">      37</span>              :   in the resulting filament. The value of `dτ/nsubsteps` should be small enough to</span>
<span id="L38"><span class="lineNum">      38</span>              :   converge and so that the discretised lines are properly closed (see below for details);</span>
<span id="L39"><span class="lineNum">      39</span>              : </span>
<span id="L40"><span class="lineNum">      40</span>              : - `method::DiscretisationMethod`: discretisation method to use (e.g.</span>
<span id="L41"><span class="lineNum">      41</span>              :   [`QuinticSplineMethod()`](@ref QuinticSplineMethod)).</span>
<span id="L42"><span class="lineNum">      42</span>              : </span>
<span id="L43"><span class="lineNum">      43</span>              : ## Optional keyword arguments</span>
<span id="L44"><span class="lineNum">      44</span>              : </span>
<span id="L45"><span class="lineNum">      45</span>              : - `max_steps::Int = 1000`: maximum number of steps before we stop iterating. This is also</span>
<span id="L46"><span class="lineNum">      46</span>              :   the maximum possible length of the returned filament;</span>
<span id="L47"><span class="lineNum">      47</span>              : </span>
<span id="L48"><span class="lineNum">      48</span>              : - `nsubsteps::Int = 1`: number of solver substeps to perform for each spatial increment `dτ`.</span>
<span id="L49"><span class="lineNum">      49</span>              :   Larger values may be used to improve accuracy;</span>
<span id="L50"><span class="lineNum">      50</span>              : </span>
<span id="L51"><span class="lineNum">      51</span>              : - `periods = (Lx, Ly, Lz)`: domain dimensions in the case of a periodic domain. This may be</span>
<span id="L52"><span class="lineNum">      52</span>              :   used to close a curve if it crosses the domain one or more times. By default this is</span>
<span id="L53"><span class="lineNum">      53</span>              :   `nothing`, meaning that domain periodicity is not taken into account.</span>
<span id="L54"><span class="lineNum">      54</span>              : </span>
<span id="L55"><span class="lineNum">      55</span>              : - `redistribute = true`: if `true` (default), [`redistribute_nodes!`](@ref) is called at the end</span>
<span id="L56"><span class="lineNum">      56</span>              :   to make sure that nodes are approximately distributed in a uniform way along the filament.</span>
<span id="L57"><span class="lineNum">      57</span>              : </span>
<span id="L58"><span class="lineNum">      58</span>              : # Extended help</span>
<span id="L59"><span class="lineNum">      59</span>              : </span>
<span id="L60"><span class="lineNum">      60</span>              : ## Example</span>
<span id="L61"><span class="lineNum">      61</span>              : </span>
<span id="L62"><span class="lineNum">      62</span>              : Generate a single filament aligned with the Taylor–Green vorticity field.</span>
<span id="L63"><span class="lineNum">      63</span>              : </span>
<span id="L64"><span class="lineNum">      64</span>              : For convenience, we work with the Taylor–Green **_velocity_** field, and the vorticity is</span>
<span id="L65"><span class="lineNum">      65</span>              : obtained via automatic differentiation (but we could directly work with the analytical</span>
<span id="L66"><span class="lineNum">      66</span>              : vorticity instead).</span>
<span id="L67"><span class="lineNum">      67</span>              : </span>
<span id="L68"><span class="lineNum">      68</span>              : ```jldoctest; filter = r&quot;\#\d+ (\(generic function with 1 method\))&quot; =&gt; s&quot;\1&quot;</span>
<span id="L69"><span class="lineNum">      69</span>              : julia&gt; function taylor_green_velocity(x⃗::Vec3)</span>
<span id="L70"><span class="lineNum">      70</span>              :            x, y, z = x⃗</span>
<span id="L71"><span class="lineNum">      71</span>              :            Vec3(</span>
<span id="L72"><span class="lineNum">      72</span>              :                cos(x) * sin(y) * cos(z),</span>
<span id="L73"><span class="lineNum">      73</span>              :                -sin(x) * cos(y) * cos(z),</span>
<span id="L74"><span class="lineNum">      74</span>              :                0,</span>
<span id="L75"><span class="lineNum">      75</span>              :            )</span>
<span id="L76"><span class="lineNum">      76</span>              :        end</span>
<span id="L77"><span class="lineNum">      77</span>              : taylor_green_velocity (generic function with 1 method)</span>
<span id="L78"><span class="lineNum">      78</span>              : </span>
<span id="L79"><span class="lineNum">      79</span>              : julia&gt; ωf = Filaments.curl(taylor_green_velocity)  # vorticity field (via automatic differentiation)</span>
<span id="L80"><span class="lineNum">      80</span>              : #60 (generic function with 1 method)</span>
<span id="L81"><span class="lineNum">      81</span>              : </span>
<span id="L82"><span class="lineNum">      82</span>              : julia&gt; s⃗₀ = Vec3(0.1, 1.8, 0.42);  # starting point for creating the filament</span>
<span id="L83"><span class="lineNum">      83</span>              : </span>
<span id="L84"><span class="lineNum">      84</span>              : julia&gt; dτ = 0.1;  # pseudo time-step (has units of length; determines line resolution)</span>
<span id="L85"><span class="lineNum">      85</span>              : </span>
<span id="L86"><span class="lineNum">      86</span>              : julia&gt; nsubsteps = 4;  # this is just to ensure convergence (should be larger for larger dτ)</span>
<span id="L87"><span class="lineNum">      87</span>              : </span>
<span id="L88"><span class="lineNum">      88</span>              : julia&gt; f = Filaments.from_vector_field(ClosedFilament, ωf, s⃗₀, dτ, QuinticSplineMethod(); nsubsteps);</span>
<span id="L89"><span class="lineNum">      89</span>              : </span>
<span id="L90"><span class="lineNum">      90</span>              : julia&gt; summary(f)</span>
<span id="L91"><span class="lineNum">      91</span>              : &quot;29-element ClosedFilament{SVector{3, Float64}, QuinticSplineMethod}&quot;</span>
<span id="L92"><span class="lineNum">      92</span>              : </span>
<span id="L93"><span class="lineNum">      93</span>              : julia&gt; Filaments.distance_to_field(ωf, f)  # check that we're close to the actual vortex line</span>
<span id="L94"><span class="lineNum">      94</span>              : 3.9561046185765664e-5</span>
<span id="L95"><span class="lineNum">      95</span>              : ```</span>
<span id="L96"><span class="lineNum">      96</span>              : </span>
<span id="L97"><span class="lineNum">      97</span>              : ## Implementation details</span>
<span id="L98"><span class="lineNum">      98</span>              : </span>
<span id="L99"><span class="lineNum">      99</span>              : The filament is generated by numerically solving the ODE:</span>
<span id="L100"><span class="lineNum">     100</span>              : </span>
<span id="L101"><span class="lineNum">     101</span>              : ```math</span>
<span id="L102"><span class="lineNum">     102</span>              : \frac{\mathrm{d}\bm{s}(τ)}{\mathrm{d}τ} = \hat{\bm{ω}}(\bm{s}), \quad \bm{s}(0) = \bm{s}_0,</span>
<span id="L103"><span class="lineNum">     103</span>              : ```</span>
<span id="L104"><span class="lineNum">     104</span>              : </span>
<span id="L105"><span class="lineNum">     105</span>              : where ``τ`` denotes a &quot;pseudo-time&quot; (which actually has units of a length) and</span>
<span id="L106"><span class="lineNum">     106</span>              : ``\hat{\bm{ω}} = \bm{ω} / |\bm{ω}|`` is a unitary vector aligned with the vector field.</span>
<span id="L107"><span class="lineNum">     107</span>              : The ODE is solved numerically using a standard 4th order Runge–Kutta scheme.</span>
<span id="L108"><span class="lineNum">     108</span>              : </span>
<span id="L109"><span class="lineNum">     109</span>              : In this context, the ``dτ`` argument is actually the &quot;timestep&quot; used when solving this ODE.</span>
<span id="L110"><span class="lineNum">     110</span>              : It must be small enough so that the curve is accurately tracked.</span>
<span id="L111"><span class="lineNum">     111</span>              : </span>
<span id="L112"><span class="lineNum">     112</span>              : Note that the curve will be automatically closed (and the ODE stopped) if we reach an</span>
<span id="L113"><span class="lineNum">     113</span>              : ``\bm{s}(τ)`` which is sufficiently close (closer than ``dτ/2``) to the starting point</span>
<span id="L114"><span class="lineNum">     114</span>              : ``\bm{s}_0``.</span>
<span id="L115"><span class="lineNum">     115</span>              : If that never happens, we stop after we have performed `max_steps` solver iterations.</span>
<span id="L116"><span class="lineNum">     116</span>              : &quot;&quot;&quot;</span>
<span id="L117"><span class="lineNum">     117</span> <span class="tlaGNC tlaBgGNC">          24 : function from_vector_field(</span></span>
<span id="L118"><span class="lineNum">     118</span>              :         ::Type{ClosedFilament}, vecfield::F, s⃗₀::Vec3, dτ, method::DiscretisationMethod;</span>
<span id="L119"><span class="lineNum">     119</span>              :         redistribute = true, kws...,</span>
<span id="L120"><span class="lineNum">     120</span>              :     ) where {F &lt;: Function}</span>
<span id="L121"><span class="lineNum">     121</span> <span class="tlaGNC">          12 :     xs = [s⃗₀]</span></span>
<span id="L122"><span class="lineNum">     122</span> <span class="tlaGNC">          12 :     offset = _from_vector_field!(vecfield, xs, dτ; kws...)</span></span>
<span id="L123"><span class="lineNum">     123</span> <span class="tlaGNC">          12 :     f = Filaments.init(ClosedFilament, xs, method; offset)</span></span>
<span id="L124"><span class="lineNum">     124</span> <span class="tlaGNC">          12 :     if redistribute</span></span>
<span id="L125"><span class="lineNum">     125</span> <span class="tlaGNC">          12 :         redistribute_nodes!(f)</span></span>
<span id="L126"><span class="lineNum">     126</span>              :     else</span>
<span id="L127"><span class="lineNum">     127</span> <span class="tlaUNC tlaBgUNC">           0 :         update_coefficients!(f)</span></span>
<span id="L128"><span class="lineNum">     128</span>              :     end</span>
<span id="L129"><span class="lineNum">     129</span> <span class="tlaGNC tlaBgGNC">          12 :     f</span></span>
<span id="L130"><span class="lineNum">     130</span>              : end</span>
<span id="L131"><span class="lineNum">     131</span>              : </span>
<span id="L132"><span class="lineNum">     132</span> <span class="tlaGNC">          24 : function _from_vector_field!(</span></span>
<span id="L133"><span class="lineNum">     133</span>              :         vecfield::F, xs, dτ;</span>
<span id="L134"><span class="lineNum">     134</span>              :         nsubsteps = 1,</span>
<span id="L135"><span class="lineNum">     135</span>              :         max_steps = 1000,</span>
<span id="L136"><span class="lineNum">     136</span>              :         periods = nothing,  # domain period (used to decide whether to close the curve)</span>
<span id="L137"><span class="lineNum">     137</span>              :     ) where {F &lt;: Function}</span>
<span id="L138"><span class="lineNum">     138</span> <span class="tlaGNC">       11052 :     f(x) = normalize(vecfield(x))</span></span>
<span id="L139"><span class="lineNum">     139</span> <span class="tlaGNC">          12 :     xinit = first(xs)</span></span>
<span id="L140"><span class="lineNum">     140</span> <span class="tlaGNC">          48 :     Ls = periods === nothing ? ntuple(_ -&gt; Infinity(), Val(length(xinit))) : periods</span></span>
<span id="L141"><span class="lineNum">     141</span> <span class="tlaGNC">          48 :     Lhs = map(L -&gt; L / 2, Ls)  # half periods</span></span>
<span id="L142"><span class="lineNum">     142</span> <span class="tlaGNC">          12 :     r²_crit = (dτ / 2)^2  # squared end-to-end critical distance to stop iterating</span></span>
<span id="L143"><span class="lineNum">     143</span> <span class="tlaGNC">          12 :     r²_prev = zero(eltype(xinit))</span></span>
<span id="L144"><span class="lineNum">     144</span> <span class="tlaGNC">          12 :     r²_pprev = r²_prev</span></span>
<span id="L145"><span class="lineNum">     145</span> <span class="tlaGNC">          12 :     dt_solver = dτ / nsubsteps</span></span>
<span id="L146"><span class="lineNum">     146</span> <span class="tlaGNC">          12 :     for _ ∈ 2:max_steps</span></span>
<span id="L147"><span class="lineNum">     147</span> <span class="tlaGNC">         552 :         xnew = last(xs)</span></span>
<span id="L148"><span class="lineNum">     148</span> <span class="tlaGNC">         552 :         for _ ∈ 1:nsubsteps</span></span>
<span id="L149"><span class="lineNum">     149</span> <span class="tlaGNC">        2760 :             v = advancement_velocity_RK4(f, xnew, dt_solver)</span></span>
<span id="L150"><span class="lineNum">     150</span> <span class="tlaGNC">        2760 :             xnew = xnew + v * dt_solver</span></span>
<span id="L151"><span class="lineNum">     151</span> <span class="tlaGNC">        4968 :         end</span></span>
<span id="L152"><span class="lineNum">     152</span> <span class="tlaGNC">         552 :         r⃗ = xnew - xinit</span></span>
<span id="L153"><span class="lineNum">     153</span> <span class="tlaGNC">         552 :         r⃗ₚ = deperiodise_separation(r⃗, Ls, Lhs)</span></span>
<span id="L154"><span class="lineNum">     154</span> <span class="tlaGNC">         552 :         r² = sum(abs2, r⃗ₚ)</span></span>
<span id="L155"><span class="lineNum">     155</span>              :         # Stop if the point (n - 1) is closer to the starting point than both the points</span>
<span id="L156"><span class="lineNum">     156</span>              :         # (n - 2) and n. Note that we discard the point n.</span>
<span id="L157"><span class="lineNum">     157</span> <span class="tlaGNC">         552 :         if r²_prev &lt; min(r², r²_pprev, r²_crit)</span></span>
<span id="L158"><span class="lineNum">     158</span> <span class="tlaGNC">          12 :             break</span></span>
<span id="L159"><span class="lineNum">     159</span>              :         end</span>
<span id="L160"><span class="lineNum">     160</span> <span class="tlaGNC">         540 :         r²_prev, r²_pprev = r², r²_prev</span></span>
<span id="L161"><span class="lineNum">     161</span> <span class="tlaGNC">         540 :         push!(xs, xnew)</span></span>
<span id="L162"><span class="lineNum">     162</span> <span class="tlaGNC">         540 :     end</span></span>
<span id="L163"><span class="lineNum">     163</span> <span class="tlaGNC">          12 :     length(xs) == max_steps &amp;&amp;</span></span>
<span id="L164"><span class="lineNum">     164</span>              :         @warn &quot;Reached maximum number of steps. The curve may not be properly closed.&quot; max_steps dτ nsubsteps</span>
<span id="L165"><span class="lineNum">     165</span> <span class="tlaGNC">          12 :     p⃗ = xs[end] - xinit  # should be roughly a multiple of the period</span></span>
<span id="L166"><span class="lineNum">     166</span> <span class="tlaGNC">          12 :     if periods === nothing</span></span>
<span id="L167"><span class="lineNum">     167</span> <span class="tlaGNC">          12 :         offset = zero(p⃗)</span></span>
<span id="L168"><span class="lineNum">     168</span>              :     else</span>
<span id="L169"><span class="lineNum">     169</span> <span class="tlaUNC tlaBgUNC">           0 :         ps = round.(Int, p⃗ ./ Ls)</span></span>
<span id="L170"><span class="lineNum">     170</span> <span class="tlaUNC">           0 :         offset = ps .* periods</span></span>
<span id="L171"><span class="lineNum">     171</span>              :     end</span>
<span id="L172"><span class="lineNum">     172</span>              :     # Remove the last point if it went too far to avoid curve weirdness (basically, having</span>
<span id="L173"><span class="lineNum">     173</span>              :     # to go &quot;backwards&quot; to close the curve, generating huge unphysical curvatures).</span>
<span id="L174"><span class="lineNum">     174</span>              :     #</span>
<span id="L175"><span class="lineNum">     175</span>              :     # Two possible geometrical criteria:</span>
<span id="L176"><span class="lineNum">     176</span>              :     #</span>
<span id="L177"><span class="lineNum">     177</span>              :     # 1. If (xs[1] - xs[N]) ⋅ (xs[N] - xs[N - 1]) &lt; 0, it basically means that the tangent</span>
<span id="L178"><span class="lineNum">     178</span>              :     #    vector abruptly changed orientation. However, this can actually be &quot;physical&quot; if</span>
<span id="L179"><span class="lineNum">     179</span>              :     #    xs[N] is right on a cusp.</span>
<span id="L180"><span class="lineNum">     180</span>              :     #</span>
<span id="L181"><span class="lineNum">     181</span>              :     # 2. If norm(xs[2] - xs[N]) &lt; norm(xs[2] - xs[1]), meaning that the last point is closer</span>
<span id="L182"><span class="lineNum">     182</span>              :     #    to point 2 than point 1.</span>
<span id="L183"><span class="lineNum">     183</span>              :     #</span>
<span id="L184"><span class="lineNum">     184</span>              :     # We require both criteria to be satisfied to remove point xs[N].</span>
<span id="L185"><span class="lineNum">     185</span> <span class="tlaGNC tlaBgGNC">          12 :     xclose_1 = xs[begin + 0] + offset  # account for possible offset: xs[N + 1] - xs[1] = offset</span></span>
<span id="L186"><span class="lineNum">     186</span> <span class="tlaGNC">          12 :     xclose_2 = xs[begin + 1] + offset</span></span>
<span id="L187"><span class="lineNum">     187</span> <span class="tlaGNC">          12 :     crit1 = (xclose_1 - xs[end]) ⋅ (xs[end] - xs[end - 1]) &lt; 0</span></span>
<span id="L188"><span class="lineNum">     188</span> <span class="tlaGNC">          12 :     crit2 = sum(abs2, xclose_2 - xs[end]) &lt; sum(abs2, xclose_2 - xclose_1)</span></span>
<span id="L189"><span class="lineNum">     189</span> <span class="tlaGNC">          12 :     if crit1 &amp;&amp; crit2</span></span>
<span id="L190"><span class="lineNum">     190</span> <span class="tlaGNC">          12 :         pop!(xs)</span></span>
<span id="L191"><span class="lineNum">     191</span>              :     end</span>
<span id="L192"><span class="lineNum">     192</span> <span class="tlaGNC">          12 :     offset</span></span>
<span id="L193"><span class="lineNum">     193</span>              : end</span>
<span id="L194"><span class="lineNum">     194</span>              : </span>
<span id="L195"><span class="lineNum">     195</span>              : # Obtain &quot;velocity&quot; of advancement using standard RK4 scheme.</span>
<span id="L196"><span class="lineNum">     196</span> <span class="tlaGNC">        2760 : function advancement_velocity_RK4(f::F, xbase, dt) where {F}</span></span>
<span id="L197"><span class="lineNum">     197</span> <span class="tlaGNC">        2760 :     v1 = f(xbase)</span></span>
<span id="L198"><span class="lineNum">     198</span> <span class="tlaGNC">        2760 :     v2 = f(xbase + v1 * dt/2)</span></span>
<span id="L199"><span class="lineNum">     199</span> <span class="tlaGNC">        2760 :     v3 = f(xbase + v2 * dt/2)</span></span>
<span id="L200"><span class="lineNum">     200</span> <span class="tlaGNC">        2760 :     v4 = f(xbase + v3 * dt)</span></span>
<span id="L201"><span class="lineNum">     201</span> <span class="tlaGNC">        2760 :     (v1 + 2v2 + 2v3 + v4) ./ 6</span></span>
<span id="L202"><span class="lineNum">     202</span>              : end</span>
<span id="L203"><span class="lineNum">     203</span>              : </span>
<span id="L204"><span class="lineNum">     204</span>              : &quot;&quot;&quot;</span>
<span id="L205"><span class="lineNum">     205</span>              :     Filaments.distance_to_field(ωf::Function, f::AbstractFilament) -&gt; Real</span>
<span id="L206"><span class="lineNum">     206</span>              : </span>
<span id="L207"><span class="lineNum">     207</span>              : Return an estimate of the normalised &quot;distance&quot; between a filament and a target vector field.</span>
<span id="L208"><span class="lineNum">     208</span>              : </span>
<span id="L209"><span class="lineNum">     209</span>              : This function is meant to be used to verify the result of [`Filaments.from_vector_field`](@ref),</span>
<span id="L210"><span class="lineNum">     210</span>              : more specifically to verify that the filament is everywhere tangent to the objective vector</span>
<span id="L211"><span class="lineNum">     211</span>              : field.</span>
<span id="L212"><span class="lineNum">     212</span>              : </span>
<span id="L213"><span class="lineNum">     213</span>              : Returns 0 if the filament is perfectly tangent to the vector field at all discretisation</span>
<span id="L214"><span class="lineNum">     214</span>              : points.</span>
<span id="L215"><span class="lineNum">     215</span>              : </span>
<span id="L216"><span class="lineNum">     216</span>              : See [`Filaments.from_vector_field`](@ref) for more details.</span>
<span id="L217"><span class="lineNum">     217</span>              : &quot;&quot;&quot;</span>
<span id="L218"><span class="lineNum">     218</span> <span class="tlaGNC">          12 : function distance_to_field(vecfield::F, f::AbstractFilament) where {F}</span></span>
<span id="L219"><span class="lineNum">     219</span> <span class="tlaGNC">          12 :     T = eltype(eltype(f))  # e.g. Float64</span></span>
<span id="L220"><span class="lineNum">     220</span> <span class="tlaGNC">          12 :     res::T = zero(T)</span></span>
<span id="L221"><span class="lineNum">     221</span> <span class="tlaGNC">          12 :     L::T = zero(T)  # estimated total line length</span></span>
<span id="L222"><span class="lineNum">     222</span> <span class="tlaGNC">          12 :     ts = knots(f)</span></span>
<span id="L223"><span class="lineNum">     223</span> <span class="tlaGNC">          12 :     @inbounds for i ∈ eachindex(f)</span></span>
<span id="L224"><span class="lineNum">     224</span> <span class="tlaGNC">         540 :         s⃗ = f[i]</span></span>
<span id="L225"><span class="lineNum">     225</span> <span class="tlaGNC">         540 :         s⃗′ = f[i, Derivative(1)]</span></span>
<span id="L226"><span class="lineNum">     226</span> <span class="tlaGNC">         540 :         dt = (ts[i + 1] - ts[i - 1]) / 2</span></span>
<span id="L227"><span class="lineNum">     227</span> <span class="tlaGNC">         540 :         ω⃗ = vecfield(s⃗)</span></span>
<span id="L228"><span class="lineNum">     228</span> <span class="tlaGNC">         540 :         uv = s⃗′ ⋅ ω⃗</span></span>
<span id="L229"><span class="lineNum">     229</span> <span class="tlaGNC">         540 :         uu = sum(abs2, s⃗′)  # units: [L²T⁻²] where T is the parametrisation unit</span></span>
<span id="L230"><span class="lineNum">     230</span> <span class="tlaGNC">         540 :         vv = sum(abs2, ω⃗)</span></span>
<span id="L231"><span class="lineNum">     231</span>              :         # This is basically the squared Gram–Schmidt projection.</span>
<span id="L232"><span class="lineNum">     232</span>              :         # It is 0 if both vectors are perfectly aligned.</span>
<span id="L233"><span class="lineNum">     233</span> <span class="tlaGNC">         540 :         err² = uu - uv^2 / vv   # units: [L²T⁻²]</span></span>
<span id="L234"><span class="lineNum">     234</span> <span class="tlaGNC">         540 :         err² = max(err², zero(err²))  # avoid tiny negative values</span></span>
<span id="L235"><span class="lineNum">     235</span> <span class="tlaGNC">         540 :         res += sqrt(err²) * dt  # units: [L] (length)</span></span>
<span id="L236"><span class="lineNum">     236</span> <span class="tlaGNC">         540 :         L += norm(s⃗′) * dt</span></span>
<span id="L237"><span class="lineNum">     237</span> <span class="tlaGNC">        1068 :     end</span></span>
<span id="L238"><span class="lineNum">     238</span> <span class="tlaGNC">          12 :     res / L  # normalise by the estimated total line length</span></span>
<span id="L239"><span class="lineNum">     239</span>              : end</span>
<span id="L240"><span class="lineNum">     240</span>              : </span>
<span id="L241"><span class="lineNum">     241</span>              : ## ================================================================================ ##</span>
<span id="L242"><span class="lineNum">     242</span>              : </span>
<span id="L243"><span class="lineNum">     243</span>              : # Returns gradient of vector function f: ℝ³ ↦ ℝ³</span>
<span id="L244"><span class="lineNum">     244</span> <span class="tlaGNC">        5803 : function vector_gradient(f::F, x⃗::Vec3) where {F &lt;: Function}</span></span>
<span id="L245"><span class="lineNum">     245</span> <span class="tlaGNC">        5804 :     ∇s = ntuple(Val(3)) do i</span></span>
<span id="L246"><span class="lineNum">     246</span>              :         # Gradient of i-th vector component.</span>
<span id="L247"><span class="lineNum">     247</span> <span class="tlaGNC">       34824 :         ForwardDiff.gradient(x -&gt; f(x)[i], x⃗)</span></span>
<span id="L248"><span class="lineNum">     248</span>              :     end</span>
<span id="L249"><span class="lineNum">     249</span> <span class="tlaGNC">        5803 :     hcat(∇s...)  # gradient tensor (Aᵢⱼ = ∂ᵢfⱼ)</span></span>
<span id="L250"><span class="lineNum">     250</span>              : end</span>
<span id="L251"><span class="lineNum">     251</span>              : </span>
<span id="L252"><span class="lineNum">     252</span>              : @doc raw&quot;&quot;&quot;</span>
<span id="L253"><span class="lineNum">     253</span>              :     Filaments.curl(vf::Function) -&gt; Function</span>
<span id="L254"><span class="lineNum">     254</span>              :     Filaments.curl(vf::Function, x⃗::Vec3) -&gt; Vec3</span>
<span id="L255"><span class="lineNum">     255</span>              : </span>
<span id="L256"><span class="lineNum">     256</span>              : Return curl of a vector-valued field, ``\bm{ω}(\bm{x}) = \bm{∇} × \bm{v}(\bm{x})``.</span>
<span id="L257"><span class="lineNum">     257</span>              : </span>
<span id="L258"><span class="lineNum">     258</span>              : Here `vf` is a function ``\bm{v}(\bm{x})`` which takes a 3D vector `x⃗` and returns a</span>
<span id="L259"><span class="lineNum">     259</span>              : vector value `v⃗`.</span>
<span id="L260"><span class="lineNum">     260</span>              : </span>
<span id="L261"><span class="lineNum">     261</span>              : The curl of `vf` is obtained via automatic differentiation using ForwardDiff.jl.</span>
<span id="L262"><span class="lineNum">     262</span>              : </span>
<span id="L263"><span class="lineNum">     263</span>              : The first variant returns a function which can be then evaluated at any `x⃗`.</span>
<span id="L264"><span class="lineNum">     264</span>              : The second variant directly evaluates the curl at some `x⃗`.</span>
<span id="L265"><span class="lineNum">     265</span>              : &quot;&quot;&quot;</span>
<span id="L266"><span class="lineNum">     266</span>              : function curl end</span>
<span id="L267"><span class="lineNum">     267</span>              : </span>
<span id="L268"><span class="lineNum">     268</span> <span class="tlaGNC">        5803 : function curl(f::F, x⃗::Vec3) where {F &lt;: Function}</span></span>
<span id="L269"><span class="lineNum">     269</span> <span class="tlaGNC">        5804 :     A = vector_gradient(f, x⃗)</span></span>
<span id="L270"><span class="lineNum">     270</span> <span class="tlaGNC">        5803 :     oftype(x⃗, (A[2, 3] - A[3, 2], A[3, 1] - A[1, 3], A[1, 2] - A[2, 1]))</span></span>
<span id="L271"><span class="lineNum">     271</span>              : end</span>
<span id="L272"><span class="lineNum">     272</span>              : </span>
<span id="L273"><span class="lineNum">     273</span> <span class="tlaGNC">        5826 : curl(f::F) where {F &lt;: Function} = x⃗ -&gt; curl(f, x⃗)</span></span>
        </pre>
              </td>
            </tr>
          </table>
          <br>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
            <tr><td class="versionInfo">Generated by: <a href="https://github.com//linux-test-project/lcov" target="_parent">LCOV version 2.0-1</a></td></tr>
          </table>
          <br>

</body>
</html>
