<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ewald summation for Biot–Savart · VortexPasta</title><meta name="title" content="Ewald summation for Biot–Savart · VortexPasta"/><meta property="og:title" content="Ewald summation for Biot–Savart · VortexPasta"/><meta property="twitter:title" content="Ewald summation for Biot–Savart · VortexPasta"/><meta name="description" content="Documentation for VortexPasta."/><meta property="og:description" content="Documentation for VortexPasta."/><meta property="twitter:description" content="Documentation for VortexPasta."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/fonts.css" rel="stylesheet" type="text/css"/><script src="../../assets/tomate.js"></script><script src="../../assets/sa.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">VortexPasta</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">VortexPasta.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/01-vortex_ring/">Vortex ring</a></li><li><a class="tocitem" href="../../tutorials/02-kelvin_waves/">Kelvin waves</a></li></ul></li><li><span class="tocitem">Explanations</span><ul><li><a class="tocitem" href="../VFM/">The vortex filament model</a></li><li class="is-active"><a class="tocitem" href>Ewald summation for Biot–Savart</a><ul class="internal"><li><a class="tocitem" href="#Splitting-the-Biot–Savart-integral"><span>Splitting the Biot–Savart integral</span></a></li><li><a class="tocitem" href="#Short-range-velocity"><span>Short-range velocity</span></a></li><li><a class="tocitem" href="#Long-range-velocity"><span>Long-range velocity</span></a></li><li><a class="tocitem" href="#Ewald-desingularisation"><span>Desingularisation</span></a></li><li><a class="tocitem" href="#Numerical-integration"><span>Numerical integration</span></a></li><li><a class="tocitem" href="#Ewald-parameters"><span>Parameter selection</span></a></li><li><a class="tocitem" href="#Ewald-method-for-the-streamfunction"><span>Ewald method for the streamfunction</span></a></li></ul></li></ul></li><li><span class="tocitem">Tips and tricks</span><ul><li><a class="tocitem" href="../../tips/parallelisation/">Parallelisation</a></li></ul></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../../modules/PaddedArrays/">PaddedArrays</a></li><li><a class="tocitem" href="../../modules/PredefinedCurves/">PredefinedCurves</a></li><li><a class="tocitem" href="../../modules/CellLists/">CellLists</a></li><li><a class="tocitem" href="../../modules/BasicTypes/">BasicTypes</a></li><li><a class="tocitem" href="../../modules/Quadratures/">Quadratures</a></li><li><a class="tocitem" href="../../modules/Filaments/">Filaments</a></li><li><a class="tocitem" href="../../modules/FilamentIO/">FilamentIO</a></li><li><a class="tocitem" href="../../modules/FindNearbySegments/">FindNearbySegments</a></li><li><a class="tocitem" href="../../modules/BiotSavart/">BiotSavart</a></li><li><a class="tocitem" href="../../modules/Reconnections/">Reconnections</a></li><li><a class="tocitem" href="../../modules/Timestepping/">Timestepping</a></li><li><a class="tocitem" href="../../modules/Diagnostics/">Diagnostics</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Explanations</a></li><li class="is-active"><a href>Ewald summation for Biot–Savart</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Ewald summation for Biot–Savart</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jipolanco/VortexPasta.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jipolanco/VortexPasta.jl/blob/master/docs/src/methods/Ewald.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="methods-Ewald"><a class="docs-heading-anchor" href="#methods-Ewald">Ewald summation for Biot–Savart</a><a id="methods-Ewald-1"></a><a class="docs-heading-anchor-permalink" href="#methods-Ewald" title="Permalink"></a></h1><p>The main originality of the VortexPasta solver is that it adapts the <a href="https://en.wikipedia.org/wiki/Ewald_summation">Ewald summation</a> method to accelerate the computation of the Biot–Savart law along vortex filaments. See for example <a href="../../references/#Arnold2005">Arnold and Holm (2005)</a> for a nice introduction to Ewald methods applied to the electrostatic interaction between point charges.</p><p>The adaptation of these methods to the vortex filament model is described in <a href="../../references/#Polanco2024">Polanco (2024)</a>. That paper also explains the role of the different parameters entering the method on accuracy and performance.</p><ul><li><a href="#Splitting-the-Biot–Savart-integral">Splitting the Biot–Savart integral</a></li><li><a href="#Short-range-velocity">Short-range velocity</a></li><li><a href="#Long-range-velocity">Long-range velocity</a></li><li class="no-marker"><ul><li><a href="#1.-Estimating-the-vorticity-in-Fourier-space">1. Estimating the vorticity in Fourier space</a></li><li><a href="#2.-Coarse-grained-vorticity-and-velocity-in-Fourier-space">2. Coarse-grained vorticity and velocity in Fourier space</a></li><li><a href="#Ewald-notes-kmax">3. Notes on required resolution</a></li><li><a href="#4.-Physical-velocity-at-filament-locations">4. Physical velocity at filament locations</a></li></ul></li><li><a href="#Ewald-desingularisation">Desingularisation</a></li><li><a href="#Numerical-integration">Numerical integration</a></li><li><a href="#Ewald-parameters">Parameter selection</a></li><li><a href="#Ewald-method-for-the-streamfunction">Ewald method for the streamfunction</a></li></ul><h2 id="Splitting-the-Biot–Savart-integral"><a class="docs-heading-anchor" href="#Splitting-the-Biot–Savart-integral">Splitting the Biot–Savart integral</a><a id="Splitting-the-Biot–Savart-integral-1"></a><a class="docs-heading-anchor-permalink" href="#Splitting-the-Biot–Savart-integral" title="Permalink"></a></h2><p>The basic idea of the method is to split the Biot–Savart integral into short- and long-range parts:</p><p class="math-container">\[\begin{align*}
    \bm{v}(\bm{x})
    &amp;= \frac{Γ}{4π} ∮_{\mathcal{C}}
    \frac{(\bm{s} - \bm{x}) \times \mathrm{d}\bm{s}}{|\bm{s} - \bm{x}|^3}
    \\
    &amp;= \frac{Γ}{4π} ∮_{\mathcal{C}}
    \Big[ g^{&lt;}(|\bm{s} - \bm{x}|) + g^{&gt;}(|\bm{s} - \bm{x}|) \Big]
    \frac{(\bm{s} - \bm{x}) \times \mathrm{d}\bm{s}}{|\bm{s} - \bm{x}|^3}
    \\
    &amp;= \bm{v}^{&lt;}(\bm{x}) + \bm{v}^{&gt;}(\bm{x})
\end{align*}\]</p><p>where the <em>short-range</em> and <em>long-range</em> scalar functions <span>$g^&lt;(r)$</span> and <span>$g^&gt;(r)$</span> have the properties:</p><ol><li><span>$g^&lt;(r) + g^&gt;(r) = 1$</span> for all <span>$r &gt; 0$</span>;</li><li><span>$g^&lt;(r)$</span> decays exponentially with <span>$r$</span>, so that long-range interactions can be neglected beyond some cut-off distance <span>$r_\text{cut}$</span> when computing the short-range velocity <span>$\bm{v}^&lt;$</span>;</li><li><span>$g^&gt;(r) / r^2$</span> is non-singular and smooth at <span>$r = 0$</span>, which implies that <span>$g^&gt;(r)$</span> must <em>quickly</em> tend to 0 as <span>$r → 0$</span>. In periodic domains, this enables the use of the fast Fourier transform (FFT) to efficiently estimate long-range interactions.</li></ol><p>The traditional choice of splitting functions satisfying all these properties is:</p><p class="math-container">\[\begin{align*}
    g^&lt;(r) &amp;= \operatorname{erfc}(αr) + \frac{2αr}{\sqrt{π}} e^{-α^2 r^2}
    \\
    g^&gt;(r) &amp;= \operatorname{erf}(αr) - \frac{2αr}{\sqrt{π}} e^{-α^2 r^2}
\end{align*}\]</p><p>Here <span>$\operatorname{erf}$</span> and <span>$\operatorname{erfc}$</span> are respectively the <a href="https://en.wikipedia.org/wiki/Error_function">error function</a> and the <a href="https://en.wikipedia.org/wiki/Error_function#Complementary_error_function">complementary error function</a>, which satisfy <span>$\operatorname{erf}(z) + \operatorname{erfc}(z) = 1$</span>. Above we have introduced the <strong>Ewald splitting parameter</strong> <span>$α$</span>, which is the inverse of a length scale. This parameter is purely numerical and, in theory, its choice has no impact on the final result <span>$\bm{v}(\bm{x})$</span>. In practice this is the case as long as other numerical parameters are well chosen (see discussion further below).</p><p>The two splitting functions are plotted below. In the horizontal axis, the scale <span>$r$</span> is non-dimensionalised by the splitting parameter <span>$α$</span>. Note that the long-range splitting function is smooth at <span>$r = 0$</span> and has the Taylor expansion <span>$g^&gt;(r) = \frac{4}{3 \sqrt{π}} (αr)^3 + \mathcal{O}(r^5)$</span>. Also plotted are the two error functions. Note in particular that, for small <span>$r$</span>, <span>$\operatorname{erf}(αr) = 2αr/\sqrt{π} + \mathcal{O}(r^3)$</span>.</p><p><img src="../splitting_functions.svg" alt/></p><details class="admonition is-details"><summary class="admonition-header">Code for this figure</summary><div class="admonition-body"><pre><code class="language-julia hljs">using SpecialFunctions: erf, erfc
using CairoMakie
rs = 2.0.^(-4:0.1:3)
gs(αr) = erfc(αr) + 2αr / sqrt(π) * exp(-αr^2)  # short-range
gl(αr) =  erf(αr) - 2αr / sqrt(π) * exp(-αr^2)  # long-range
xticks = LogTicks(-4:1:3)
yticks = LogTicks(-16:4:0)
fig = Figure(size = (600, 400), fontsize = 18)
ax = Axis(fig[1, 1]; xticks, yticks, xscale = log2, yscale = log10, xlabel = L&quot;αr&quot;, ylabel = &quot;Splitting function&quot;)
ylims!(ax, 1e-17, 4)
ls = lines!(ax, rs, gs.(rs); label = L&quot;g^&lt;(r)&quot;)
ll = lines!(ax, rs, gl.(rs); label = L&quot;g^&gt;(r)&quot;)
lines!(ax, rs, erfc.(rs); label = L&quot;\mathrm{erfc}(αr)&quot;, linestyle = :dot, color = ls.color)
lines!(ax, rs, erf.(rs); label = L&quot;\mathrm{erf}(αr)&quot;, linestyle = :dot, color = ll.color)
let rs = 2.0.^(range(-4, -1; length = 3)), color = :grey20  # plot ~r^3 slope
    ys = @. 0.2 * rs^3
    lines!(ax, rs, ys; linestyle = :dash, color)
    text!(ax, rs[2], ys[2]; text = L&quot;r^3&quot;, align = (:left, :top), color)
end
let rs = 2.0.^(range(-4, -2; length = 3)), color = :grey20  # plot ~r^1 slope
    ys = @. 0.5 * (2 / sqrt(π)) * rs
    lines!(ax, rs, ys; linestyle = :dash, color)
    text!(ax, rs[2], ys[2]; text = L&quot;r&quot;, align = (:left, :top), color)
end
axislegend(ax; position = (0, 0), labelsize = 20)
save(&quot;splitting_functions.svg&quot;, fig)</code></pre></div></details><p>For small <span>$αr$</span>, the long-range splitting function goes to zero as <span>$r^3$</span>, consistently with its Taylor expansion. This means that, as we wanted, <span>$g^&gt;(r) / r^2$</span> is non-singular and smooth at <span>$r = 0$</span>.</p><h2 id="Short-range-velocity"><a class="docs-heading-anchor" href="#Short-range-velocity">Short-range velocity</a><a id="Short-range-velocity-1"></a><a class="docs-heading-anchor-permalink" href="#Short-range-velocity" title="Permalink"></a></h2><p>As seen in the figure above, the short-range splitting function is dominant for small <span>$αr$</span>, while it decays exponentially to 0 for large <span>$αr$</span>. In particular, for <span>$r ≳ 5/α$</span>, its value decays below about <span>$10^{-10}$</span>, meaning that it is safe to set the cut-off distance <span>$r_\text{cut}$</span> around this value.</p><p>Therefore, the short-range velocity is obtained as</p><p class="math-container">\[\bm{v}^&lt;(\bm{x}) =
\frac{\Gamma}{4π} ∫_{|\bm{s} - \bm{x}| &lt; r_\text{cut}}
g^&lt;(|\bm{s} - \bm{x}|)
\frac{(\bm{s} - \bm{x}) \times \mathrm{d}\bm{s}}{|\bm{s} - \bm{x}|^3}\]</p><p>i.e. the integral is performed over vortex points which are sufficiently close to the point of interest <span>$\bm{x}$</span>. Moreover, integrals are estimated using <a href="#Numerical-integration">numerical integration</a>.</p><p>Note that one can use a <a href="../../modules/CellLists/#CellLists">cell lists algorithm</a> to further speed-up the search for nearby points.</p><h2 id="Long-range-velocity"><a class="docs-heading-anchor" href="#Long-range-velocity">Long-range velocity</a><a id="Long-range-velocity-1"></a><a class="docs-heading-anchor-permalink" href="#Long-range-velocity" title="Permalink"></a></h2><p>The long-range velocity <span>$\bm{v}^&gt;$</span> has a simple physical interpretation. Indeed, it can be shown, by differentiating the splitting functions defined above, that its associated long-range vorticity <span>$\bm{ω}^&gt;(\bm{x}) ≡ \bm{∇} × \bm{v}^&gt;(\bm{x})$</span> is nothing else that a Gaussian-filtered version of the actual vorticity field induced by the vortex filaments (which is singular).</p><p>More precisely, the long-range vorticity is given by the convolution <span>$\bm{ω}^&gt; = H ∗ \bm{ω}$</span>, where <span>$H(\bm{r}) = (α / \sqrt{π})^3 \, e^{-α^2 r^2}$</span> is a 3D Gaussian kernel. Intuitively, this means that the long-range velocity <span>$\bm{v}^&gt;$</span> corresponds to the velocity induced by a coarse-grained version of the vortex filaments. In this view, vortices are not &quot;infinitesimal&quot; anymore, but are closer to the smooth vortices which we are used to see in classical viscous fluids. In periodic domains, such a smooth vorticity field can be accurately and efficiently expanded in Fourier series, and the curl operator can be readily inverted in Fourier space to obtain the coarse-grained velocity field <span>$\bm{v}^&gt;$</span>.</p><h3 id="1.-Estimating-the-vorticity-in-Fourier-space"><a class="docs-heading-anchor" href="#1.-Estimating-the-vorticity-in-Fourier-space">1. Estimating the vorticity in Fourier space</a><a id="1.-Estimating-the-vorticity-in-Fourier-space-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Estimating-the-vorticity-in-Fourier-space" title="Permalink"></a></h3><p>The idea is to first expand the (<em>actual</em>) vorticity field in Fourier series:</p><p class="math-container">\[\bm{ω}(\bm{x}) = Γ ∮_{\mathcal{C}} δ(\bm{x} - \bm{s}) \, \mathrm{d}\bm{s}
= ∑_{\bm{k}} \hat{\bm{ω}}(\bm{k}) \, e^{i \bm{k} ⋅ \bm{x}}
\quad\text{for } \bm{k} ∈ \bm{K}.\]</p><p>Here <span>$L$</span> is the domain period (assumed the same in all directions for simplicity), and <span>$\bm{K} = \left\{ \frac{2π \bm{n}}{L}, \bm{n} ∈ \mathbb{Z}^3 \right\}$</span> is the set of wavenumbers associated to the Fourier series expansion. The Fourier coefficients <span>$\hat{\bm{ω}}(\bm{k})$</span> are given by</p><p class="math-container">\[\hat{\bm{ω}}(\bm{k})
= \frac{1}{L^3} ∫ \bm{ω}(\bm{x}) \, e^{-i \bm{k} ⋅ \bm{x}} \, \mathrm{d}\bm{x}
= \frac{Γ}{L^3} ∮_{\mathcal{C}} e^{-i \bm{k} ⋅ \bm{s}} \, \mathrm{d}\bm{s}\]</p><p>To estimate this integral, we discretise the curves defining the support <span>$\mathcal{C}$</span> of the vortex filaments, leading to a weighted sum over discrete points <span>$\bm{x}_i$</span>:</p><p class="math-container">\[\hat{\bm{ω}}(\bm{k})
≈ \frac{Γ}{L^3} ∑_{j} \bm{w}_i \, e^{-i \bm{k} ⋅ \bm{x}_i}\]</p><p>The weights are related to the length of the discrete segments and to the quadrature rule used to estimate the integrals over segments (see the <a href="#Numerical-integration">Numerical integration</a> section). The important point here is that, since the discrete points are generally not on an equispaced grid, one cannot directly use the fast Fourier transform (FFT) to efficiently evaluate these coefficients. Nevertheless, they can be efficiently and accurately estimated using the <a href="https://en.wikipedia.org/wiki/Non-uniform_discrete_Fourier_transform#Nonuniform_fast_Fourier_transform">non-uniform FFT</a> (NUFFT) algorithm. More precisely, this corresponds to a <a href="https://finufft.readthedocs.io/en/latest/math.html">type-1 NUFFT</a>, which converts from non-uniform sources in physical space to uniform wavenumbers <span>$\bm{k}$</span> in Fourier space.</p><h3 id="2.-Coarse-grained-vorticity-and-velocity-in-Fourier-space"><a class="docs-heading-anchor" href="#2.-Coarse-grained-vorticity-and-velocity-in-Fourier-space">2. Coarse-grained vorticity and velocity in Fourier space</a><a id="2.-Coarse-grained-vorticity-and-velocity-in-Fourier-space-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Coarse-grained-vorticity-and-velocity-in-Fourier-space" title="Permalink"></a></h3><p>Once we have obtained the <span>$\hat{\bm{ω}}(\bm{k})$</span> coefficients, obtaining the Fourier coefficients for the coarse-grained vorticity and coarse-grained velocity is straightforward. The former is obtained by convolution with a Gaussian, which is simply a product in Fourier space:</p><p class="math-container">\[\hat{\bm{ω}}^&gt;(\bm{k})
= \hat{\bm{ω}}(\bm{k}) \, e^{-k^2 / 4α^2}, \quad\text{where } k = |\bm{k}|\]</p><p>Similarly, the curl operator can be easily inverted in Fourier space to get the coarse-grained velocity:</p><p class="math-container">\[\hat{\bm{v}}^&gt;(\bm{k})
= \frac{i \bm{k}}{k^2} × \hat{\bm{ω}}^&gt;(\bm{k})
= \frac{i \bm{k}}{k^2} × \hat{\bm{ω}}(\bm{k}) \, e^{-k^2 / 4α^2}
\quad\text{for } k ≠ 0\]</p><div class="admonition is-warning"><header class="admonition-header">Zero mean vorticity condition</header><div class="admonition-body"><p>The velocity is well defined only if <span>$\hat{\bm{ω}}(\bm{0}) = \bm{0}$</span>, that is, if the mean vorticity of the vortex filament system is zero. Otherwise we get division by zero, which is related to the fact that we&#39;re dealing with an infinitely periodic system and energy diverges with a non-zero mean vorticity.</p><p>This condition is automatically satisfied when dealing with closed vortex filaments. This may however not be the case for infinite filaments (for instance, putting a single straight infinite filament in the domain is ill-defined).</p></div></div><h3 id="Ewald-notes-kmax"><a class="docs-heading-anchor" href="#Ewald-notes-kmax">3. Notes on required resolution</a><a id="Ewald-notes-kmax-1"></a><a class="docs-heading-anchor-permalink" href="#Ewald-notes-kmax" title="Permalink"></a></h3><p>Above we have assumed that we can evaluate Fourier coefficients for any wavenumber <span>$\bm{k}$</span>. In fact, for practical reasons, we cannot evaluate all coefficients <span>$\hat{\bm{ω}}(\bm{k})$</span> for every possible <span>$\bm{k}$</span>, and we need to set the number of wavenumbers <span>$N$</span> to compute in each direction (this is the parameter one tunes in NUFFT implementations). In other words, we need to truncate the estimations at some maximum wavenumber, namely the Nyquist frequency, which is related to <span>$N$</span> by <span>$k_\text{max} = π N / L$</span>.</p><p>Similarly to the cut-off distance in physical space, one can expect that the appropriate value of <span>$k_\text{max}$</span> (which is an inverse length scale) to get good accuracy should be proportional to the Ewald splitting parameter <span>$α$</span>. A rule of thumb is to choose a wavenumber at which the Gaussian factor <span>$e^{-k_{\text{max}}^2 / 4α^2}$</span> matches the desired accuracy. For instance, at <span>$k_{\text{max}} = 8α$</span>, this factor has dropped to about <span>$10^{-7}$</span> (see figure below). Of course, one can vary the <span>$k_\text{max} / α$</span> ratio depending on the wanted accuracy.</p><p><img src="../gaussian_kalpha.svg" alt/></p><details class="admonition is-details"><summary class="admonition-header">Code for this figure</summary><div class="admonition-body"><pre><code class="language-julia hljs">using CairoMakie
ks_α = range(0, 12.2; step = 0.1)
xticks = 0:12
yticks = LogTicks(-16:2:0)
ys = @. exp(-ks_α^2 / 4)
lines(
    ks_α, ys;
    axis = (yscale = log10, xticks, yticks, xlabel = L&quot;k/α&quot;, ylabel = L&quot;\exp \, \left[ -k^2 / 4α^2 \right]&quot;,),
    figure = (fontsize = 20, size = (600, 400),),
)
save(&quot;gaussian_kalpha.svg&quot;, current_figure())</code></pre></div></details><h3 id="4.-Physical-velocity-at-filament-locations"><a class="docs-heading-anchor" href="#4.-Physical-velocity-at-filament-locations">4. Physical velocity at filament locations</a><a id="4.-Physical-velocity-at-filament-locations-1"></a><a class="docs-heading-anchor-permalink" href="#4.-Physical-velocity-at-filament-locations" title="Permalink"></a></h3><p>The last step is to evaluate, from the coarse-grained velocity <span>$\hat{\bm{v}}^&gt;(\bm{k})$</span> in Fourier space, the <em>physical</em> coarse-grained velocity <span>$\bm{v}^&gt;(\bm{s})$</span> on vortex filament locations <span>$\bm{s}$</span> (which, once again, are generally not on a regular grid). This operation can be written as:</p><p class="math-container">\[\bm{v}^&gt;(\bm{s}_i) = ∑_{\bm{k}} \hat{\bm{v}}^&gt;(\bm{k}) \, e^{i \bm{k} ⋅ \bm{s}_i}\]</p><p>for a set of locations <span>$\bm{s}_i ∈ \mathcal{C}$</span>. Note that in practice this sum is truncated to the chosen <span>$k_{\text{max}}$</span>.</p><p>This operation can be efficiently computed using a type-2 NUFFT (from uniform wavenumbers <span>$\bm{k}$</span> to non-uniform locations <span>$\bm{x}$</span>), which can be understood as an interpolation of the coarse-grained velocity field on the chosen points.</p><p>From the above steps, we can directly write the large-scale velocity at <span>$\bm{s}_i$</span> from the geometry of vortex lines:</p><p class="math-container">\[\newcommand{\dd}{\mathrm{d}}
\newcommand{\svec}{\bm{s}}
\newcommand{\sj}{\svec_i}
\newcommand{\kvec}{\bm{k}}
\begin{align*}
\bm{v}^&gt;(\sj) &amp;=
∑_{\kvec ≠ \bm{0}}
\frac{i}{k^2} \, e^{-k^2 / 4α^2} \kvec × \hat{\bm{ω}}(\kvec) \, e^{i \kvec ⋅ \sj}
\\
&amp;=
\frac{iΓ}{L^3} ∑_{\kvec ≠ \bm{0}} \frac{e^{-k^2 / 4α^2}}{k^2} ∮_{\mathcal{C}} e^{i \kvec ⋅ (\sj - \svec)} \, \kvec × \dd \svec
\\
&amp;=
\frac{Γ}{L^3} ∑_{\kvec ≠ \bm{0}} \frac{e^{-k^2 / 4α^2}}{k^2} ∮_{\mathcal{C}} \sin[\kvec ⋅ (\svec - \sj)] \, \kvec × \dd \svec
\end{align*}\]</p><p>which is analogous to the term for long-range electrostatic forces in e.g. <a href="../../references/#Arnold2005">Arnold and Holm (2005)</a>, Eq. (17).</p><h2 id="Ewald-desingularisation"><a class="docs-heading-anchor" href="#Ewald-desingularisation">Desingularisation</a><a id="Ewald-desingularisation-1"></a><a class="docs-heading-anchor-permalink" href="#Ewald-desingularisation" title="Permalink"></a></h2><p>As discussed in the <a href="../VFM/#VFM-desingularisation">VFM page</a>, the Biot–Savart integral must be desingularised if the velocity is to be evaluated on a point <span>$\bm{x} = \bm{s}_i$</span> belonging itself to the curve.</p><p>In this case, the actual velocity that we want to compute is</p><p class="math-container">\[\newcommand{\vvec}{\bm{v}}
\newcommand{\svec}{\bm{s}}
\newcommand{\sj}{\svec_i}
\begin{align*}
\vvec(\sj)
&amp;= \vvec_{\text{local}}(\sj) + \vvec_{\text{non-local}}(\sj)
\\
&amp;= \vvec_{\text{local}}(\sj) +
\Big[ \vvec^&lt;_{\text{non-local}}(\sj) + \vvec^&gt;_{\text{non-local}}(\sj) \Big]
\end{align*}\]</p><p>which basically means that both short-range and long-range components should skip the computation of their respective integrals in the vicinity of <span>$\bm{s}_i$</span>, and that the <a href="../VFM/#VFM-desingularisation">expression for the local velocity</a> should be used instead.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The terms <em>local</em>/<em>non-local</em> and <em>short</em>/<em>long</em>-range are completely orthogonal and <strong>should not be confused</strong>! The first pair of terms refer to the VFM while the second pair refers to Ewald summation. For example, as discussed right below, it is possible (and it makes sense) to compute the <em>local long-range</em> velocity component.</p></div></div><p>For the short-range component, it is straightforward to skip the local part of the modified Biot–Savart integral: one just integrates over segments within the cut-off distance, but excluding the two segments which are in direct contact with <span>$\bm{s}_i$</span> (the <span>$\mathcal{C}_i$</span> region represented in the trefoil figure of the <a href="../VFM/#VFM-desingularisation">VFM page</a>).</p><p>In the case of the long-range component special care is needed, as the procedure detailed above computes the full (coarse-grained) Biot–Savart integral, including the &quot;singular&quot; region. As discussed above, the modified long-range integral is actually not singular, so this is not a problem. But it means that we now need to subtract the <em>local</em> long-range velocity:</p><p class="math-container">\[\newcommand{\vvec}{\bm{v}}
\newcommand{\svec}{\bm{s}}
\newcommand{\dd}{\mathrm{d}}
\newcommand{\sj}{\svec_i}
\vvec^&gt;_{\text{local}}(\sj)
= \frac{Γ}{4π} ∫_{\mathcal{C}_i} g^&gt;(|\svec - \sj|) \frac{(\svec - \sj) × \dd \svec}{|\svec - \sj|^3}\]</p><p>which can be numerically computed using the same method as for the <em>non-local</em> short-range velocity.</p><p>To summarise, in practice the velocity on a vortex position <span>$\bm{s}_i$</span> is computed as</p><p class="math-container">\[\newcommand{\vvec}{\bm{v}}
\newcommand{\svec}{\bm{s}}
\newcommand{\sj}{\svec_i}
\vvec(\sj)
= \vvec_{\text{local}}(\sj)
+ \vvec^&lt;_{\text{non-local}}(\sj)
- \vvec^&gt;_{\text{local}}(\sj)
+ \vvec^&gt;(\sj)\]</p><p>where the first term is computed using an analytical expression based on Taylor expansions, the second and third terms are estimated by numerical integration (using quadratures), and the fourth term is indirectly computed using (non-uniform) fast Fourier transforms.</p><h2 id="Numerical-integration"><a class="docs-heading-anchor" href="#Numerical-integration">Numerical integration</a><a id="Numerical-integration-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-integration" title="Permalink"></a></h2><p>Both the short-range and long-range computations use quadrature rules to approximate line integrals using numerical integration. The general strategy that has been implemented is to perform integrals segment-by-segment, and to use a quadrature rule of few points for each segment.</p><p>To be more explicit, say that we have a single closed vortex line (for example the <a href="../VFM/#VFM-desingularisation">trefoil in the VFM page</a>) and that we want to compute the short-range non-local velocity induced by the vortex on <span>$\bm{s}_i$</span>:</p><p class="math-container">\[\newcommand{\vvec}{\bm{v}}
\newcommand{\svec}{\bm{s}}
\newcommand{\sj}{\svec_i}
\newcommand{\sdiff}{\svec - \sj}
\newcommand{\sdiffx}{\svec(ξ) - \sj}
\newcommand{\dd}{\mathrm{d}}
\newcommand{\Ccal}{\mathcal{C}}
\newcommand{\Cj}{\Ccal_i}
\begin{align*}
\vvec^&lt;(\sj)
&amp;= \frac{Γ}{4π} ∫_{\Ccal ∖ \Cj} g^&lt;(|\sdiff|) \frac{(\sdiff) × \dd\svec}{|\sdiff|^3}
\\
&amp;= \frac{Γ}{4π}
  ∑_{j = 1}^N\vphantom{∑}&#39;
  ∫_{ξ_j}^{ξ_{j + 1}} g^&lt;(|\sdiffx|) \frac{(\sdiffx) × \svec&#39;(ξ)}{|\sdiffx|^3} \, \dd ξ,
  \quad j ∉ \{i - 1, i\}
\end{align*}\]</p><p>Here <span>$N$</span> is the number of discretisation points of the curve, and the prime over the summation symbol indicates that the indices <span>$j ∈ \{i - 1, i\}$</span> (corresponding to the two segments in contact with <span>$\bm{s}_i$</span>) should be excluded. So the integral is split onto <span>$N - 2$</span> line integrals. The next step is to approximate each of these integrals using a quadrature rule:</p><p class="math-container">\[\newcommand{\vvec}{\bm{v}}
\newcommand{\svec}{\bm{s}}
\newcommand{\sj}{\svec_i}
\newcommand{\sdiff}{\svec - \sj}
\newcommand{\sdiffx}{\svec(ξ) - \sj}
\newcommand{\sdiffm}{\svec(ξ_m) - \sj}
\newcommand{\dd}{\mathrm{d}}
\newcommand{\Ccal}{\mathcal{C}}
\newcommand{\Cj}{\Ccal_i}

∫_{ξ_j}^{ξ_{j + 1}} f(ξ) \, \dd\svec(ξ)
≈ ∑_{m = 1}^M w_m f(ξ_m),\]</p><p>where <span>$w_m$</span> and <span>$ξ_m ∈ [ξ_j, ξ_{j + 1}]$</span> are appropriately-chosen quadrature weights and points, respectively. In practice, we use <a href="https://en.wikipedia.org/wiki/Gaussian_quadrature#Gauss%E2%80%93Legendre_quadrature">Gauss–Legendre quadratures</a> with few (typically ~4) points per segment.</p><h2 id="Ewald-parameters"><a class="docs-heading-anchor" href="#Ewald-parameters">Parameter selection</a><a id="Ewald-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Ewald-parameters" title="Permalink"></a></h2><p>As detailed above, this method introduces a few parameters which must be tuned for accuracy and performance. In fact, <strong>most of these parameters are related</strong> and should not be treated independently. For instance, the physical- and Fourier-space cut-offs <span>$r_\text{cut}$</span> and <span>$k_\text{max}$</span> are clearly related to the Ewald splitting parameter <span>$α$</span>. As described in <a href="../../references/#Polanco2024">Polanco (2024)</a>, these can be related by a unique non-dimensional parameter <span>$β = α r_\text{cut} = k_\text{max} / 2α$</span> controlling the accuracy of the method.</p><p>In practice, one recommended way of setting the parameters is as follows:</p><ol><li><p>Start by setting the <strong>physical domain period</strong> <span>$L$</span>. It is convenient and standard practice to choose <span>$L = 2π$</span>, which means that the corresponding wavenumbers <span>$\bm{k}$</span> in long-range computations will be integers (in general, <span>$k = 2πn/L$</span> with <span>$n = 0, ± 1, ± 2, \ldots$</span>). But in principle one can choose any positive value of <span>$L$</span>.</p></li><li><p>Set the <strong>number of Fourier modes</strong> <span>$N$</span> in each direction. Choosing <span>$N$</span> also sets the <strong>maximum resolved wavenumber</strong> <span>$k_{\text{max}} = πN/L$</span> as well as the <strong>physical grid spacing</strong> <span>$δ = L/N$</span> associated to the long-range fields. The value of <span>$N$</span> should be tuned to have a good balance between the time spent on short-range and long-range computations.</p></li><li><p>Now set the non-dimensional parameter <span>$β$</span> to the desired accuracy. For example, <span>$β = 3.5$</span> roughly gives <span>$10^{-6}$</span> relative accuracy.</p></li><li><p>From <span>$β$</span> and <span>$k_{\text{max}}$</span>, one obtains the remaining parameters <span>$α = k_{\text{max}} / 2β$</span> and <span>$r_\text{cut} = β / α$</span>.</p></li></ol><p>For simplicity here we have assumed that the domain size <span>$L$</span> and the resolution <span>$N$</span> are the same in all directions, but things are easy to generalise to different <span>$L$</span> and <span>$N$</span> per direction. In all cases, one usually wants the physical grid spacing <span>$δ = L/N$</span> (or equivalently the maximum resolved wavenumber <span>$k_{\text{max}}$</span>) to be the same in all directions.</p><div class="admonition is-info"><header class="admonition-header">Size of FFTs</header><div class="admonition-body"><p>It may also be a good idea to &quot;round&quot; the chosen value of <span>$N$</span> so that the FFTs performed in long-range computations have sizes described by powers of 2 or 3 (for which the FFT is most efficient). Note that, to reduce aliasing errors, the NUFFT oversamples the data from <span>$N$</span> to <span>$Ñ = σN &gt; N$</span>, and this <span>$Ñ$</span> is the actual size of the performed FFTs. As an example, by default the <a href="../../modules/BiotSavart/#VortexPasta.BiotSavart.NonuniformFFTsBackend"><code>NonuniformFFTsBackend</code></a> in VortexPasta uses an oversampling of <span>$σ = 3/2$</span>. Therefore, choosing <span>$N = 85 ≈ 2/3 × 128$</span> leads to FFTs of size <span>$Ñ = 128 = 2^7$</span>, which is what we want.</p></div></div><p>Another parameter to choose is the <strong>size of the quadrature rules</strong> for numerical integration. Using Gauss–Legendre quadratures, integrals seem to converge quite fast using a small number of quadrature nodes per filament segment. Typically, using 3 nodes seems to be enough when using <a href="../../modules/Filaments/#VortexPasta.Filaments.QuinticSplineMethod">quintic splines</a> to describe filaments.</p><h2 id="Ewald-method-for-the-streamfunction"><a class="docs-heading-anchor" href="#Ewald-method-for-the-streamfunction">Ewald method for the streamfunction</a><a id="Ewald-method-for-the-streamfunction-1"></a><a class="docs-heading-anchor-permalink" href="#Ewald-method-for-the-streamfunction" title="Permalink"></a></h2><p>As in the case of the velocity, the <a href="../VFM/#Biot-Savart-streamfunction">Biot–Savart integral for the streamfunction</a> decays slowly with the distance <span>$r = |\bm{x} - \bm{s}|$</span>, and its computation can be accelerated using Ewald summation. In fact, the Ewald summation method exposed above for the velocity is derived from that for the streamfunction, which is simpler and closer to the way the Ewald method is usually introduced in electrostatics (where the electrostatic potential is the analogue of the streamfunction).</p><p>In the case of the streamfunction, the idea of Ewald summation is to split the singular and slowly-decaying Green&#39;s function <span>$G(\bm{r})$</span> onto a smooth long-range component <span>$G^&gt;(\bm{r})$</span> and a short-range fast-decaying component <span>$G^&lt;(\bm{r})$</span>. The standard way of doing this is via the identity:</p><p class="math-container">\[G(\bm{r}) = \frac{1}{4πr}
= \frac{\operatorname{erfc}(αr)}{4πr} + \frac{\operatorname{erf}(αr)}{4πr}
= G^&lt;(\bm{r}) + G^&gt;(\bm{r}),\]</p><p>where <span>$\operatorname{erf}$</span> and <span>$\operatorname{erfc}$</span> are respectively the error function and the complementary error function already introduced <a href="#Splitting-the-Biot–Savart-integral">above</a>, and <span>$α$</span> is the same <strong>Ewald splitting parameter</strong> introduced in that section.</p><p>This leads to modified Biot–Savart integrals for the short-range and long-range streamfunction. For example, the short-range integral is given by:</p><p class="math-container">\[\bm{ψ}^&lt;(\bm{x}) =
(G^&lt; ∗ \bm{ω})(\bm{x}) =
\frac{Γ}{4π} ∮_{\mathcal{C}}
\frac{\operatorname{erfc}(α |\bm{x} - \bm{s}|)}{|\bm{x} - \bm{s}|} \, \mathrm{d}\bm{s}\]</p><p>Taking the curl of those integrals eventually leads to the <span>$g^&lt;(\bm{r})$</span> and <span>$g^&gt;(\bm{r})$</span> splitting functions that we used for the velocity.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../VFM/">« The vortex filament model</a><a class="docs-footer-nextpage" href="../../tips/parallelisation/">Parallelisation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Friday 28 June 2024 14:52">Friday 28 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
